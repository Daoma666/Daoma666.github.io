[{"title":"秒懂汉诺塔原理函数递归","url":"/2018/04/15/秒懂汉诺塔原理函数递归/","content":"\n## 秒懂汉诺塔原理函数递归\n\n　　想当年大一刚学C语言递归那一块儿的时候，遇到了“汉诺塔”问题，我的老天，那段时期想哭好吗，深刻的打击了我的编程热情，本身我就自觉智商不高，于是一直就没搞懂过这个问题，指导最近看了《JavaScript语言精粹》，才发现递归并没有那么难。。。我之前对于递归的了解只限于一个函数调用它自身，所以一直懵懵懂懂，现在需要重新认识一下它：\n\n### 递归函数是干啥用的\n\n　　递归函数就是会直接或间接调用自身的一种函数。它把一个问题分解为一组相似的子问题，每一个都用一个*寻常解*去解决。也就是说，递归用一般的方式去解决**每个**子问题。\n\n### 汉诺塔是什么\n\n　　因为这是篇笔记，相信每个想了解汉诺塔原理的人都懂它是什么，怎么玩，但是就算你会玩，你不会写代码(大佬除外)。。。我就是从这个时候觉得自己智商比别人低的，不过这是我刚接触编程的时候。到现在接触了两三年的编程，我深感周围大佬没多少(可能因为我双非一本非计算机专业的缘故)，当初那些一看就会的人大部分接触的早O__O，人家初中高中奥数什么的早就接触啦，对于我们这种普通学生来说(我相信你要是985,211不会来看我的博客的)，大部分像我这样的人(为了不让大佬们黑我)都是学以致用的，参考别人的摸出门路了才会用，所以接下来我写的，应该都能懂。\n\n### 汉诺塔递归代码\n\n　　有时搜一篇资料，先看到源码，哇看不懂，再看原理，哇更不懂；也可能先看到原理，没代码我怎么会看懂，再看源码，哇原理我都看不懂看代码怎么会懂。。。所以这就陷入了死循环，至于能不能看懂，就看个人的喜好和悟性了，我的习惯是先看源码。\n```bash\n\t<pre>\n\t\t<script type=\"text/javascript\">\n\t\t\tvar hanoi=function(n,src,aux,dst){\n\t\t\t\tif(disc>0){\n\t\t\t\t\t//第一步\n\t\t\t\t\thanoi(n-1,src,dst,aux);\n\t\t\t\t\t//第二步\n\t\t\t\t\tdocument.writeln(\"Move disc \"+n+\" from \"+src+\" to \"+dst);\n\t\t\t\t\t//第三步\n\t\t\t\t\thanoi(n-1,aux,src,dst);\n\t\t\t\t}\n\t\t\t};\n\t\t\thanoi(3,\"Src\",\"Aux\",\"Dst\");\n\t\t\thanoi(4,\"Src\",\"Aux\",\"Dst\");\n\t\t</script>\n\t</pre>\n```\n\n### 汉诺塔递归原理\n\n　　你可以发现它看上去非常的简单，一共就三步，毕竟hanoi函数就是把一堆圆盘从一根柱子移到另一根柱子，必要时使用辅助的柱子。函数的参数解释如下：\n1.n是一开始由小到大排在src柱子上的圆盘数量\n2.src代表起始柱子\n3.aux(auxiliary)代表辅助柱子\n4.dst(destination)代表目标柱子\n\n　　hanoi函数把问题分解为了三个子问题，\n\n#### 第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。\n#### 第二步：移动下面最大的圆盘到目标柱子上。\n#### 第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。\n\n　　然后通过递归地调用自身(只是参数不同)去处理一对圆盘的移动，从而解决那些子问题。\n\n### 对递归原理的理解\n\n　　hanoi(3,\"Src\",\"Aux\",\"Dst\");代表把3个圆盘**从**Src柱子**借助**Aux柱子移动**到**Dst柱子。每一个大问题里包含三个子问题:如果起始柱子上有盘子，先把disc-1个较小的圆盘都放到辅助柱子上，然后把较大的放到目标柱子上，最后在把那disc-1个较小的圆盘放到目标柱子上。\n\n　　相信读到这里的人都搞懂了**怎么把这个大问题分解为3个子问题**，并且发现如果按着原理思路来写，即可写出代码。但是过了不一会儿你就会产生疑问，因为你大问题上懂了，但不明白为啥每个子问题都可以这么用呢？每个子问题内为什么也起作用呢？\n\n　　所以说之前的我和现在的我差在了哪里，不是智商，而是思考的方式不对！！你是不是正在苦苦思考这段代码的每一步，然后把一步步的执行过程都写出来了，想搞懂递归呢？结果就是蛋疼！你不但啥也没搞懂，还白白浪费了这段推代码的时间！正确的打开方式是这样的——**递归当然只能以递归的思路理解，把它展开纯属自讨苦吃**。\n\n　　递归思路，说白了是如下三步：\n\n#### 1.对于问题N，如果N-1已经解决了，那么N是否很容易解决。\n\n　　举例来说，如果要把一个N层汉诺塔从src搬到dst，那么：\n\n　　如果前N-1层可以找别人搞定，咱只管搬第N层，会不会变得非常容易？\n\n　　你看，这一下就简单了：这时当它只有两层就好了，先把前N-1层看作一个整体，把它搬到aux；然后把最下面的第N层搬到dst；然后再把前N-1层从aux搬到dst。\n\n　　类似的，假如接到“搬前N-1层”这个任务的是我们，怎么搬呢？\n\n　　简单，像前东家一样，把前N-2层外包出去，我们只搬第N-1层——其实和前面讨论过的“外包N-1层，只搬第N层”完全一样嘛。\n\n　　依此类推，一层层“外包”下去——我不管你们有多伤脑筋，反正只要你们把我外包给你的活干了，我就能干了我的活！\n\n　　这一步就是**递推*。\n\n###### 注意这里的搬法：搬第N层，就需要把前N-1层搬两次(起始到辅助，辅助再到目标)，另外再把第N层搬一次(起始到目标)；\n###### 搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。\n###### an=2*a(n-1)+1\n###### a(n-1)=2*a(n-2)+1\n###### ......\n###### a2=2*a1+1\n###### a1=1\n###### 很容易知道，an需要搬2^n-1次。\n\n#### 2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。\n\n　　第一层怎么搬？\n\n　　太简单了，让搬哪搬哪。\n\n　　换句话说，到此，**递推**就到了极限，简单粗暴直接做就可以了。\n\n#### 3.既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。\n\n　　这一步就是**回归**。\n\n　　如上三步加起来，就是**递归**。\n\n　　推而广之，任何问题，不管规模为N时有多复杂，只要把N-1那块“外包”给别人做之后，我们在这个基础上可以轻易完成N，那么它很可能就适合用“递归”解决。\n\n　　那么，怎么最终确定它能不能用“递归”做呢？\n\n##### 看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。 \n\n　　容易看出，**“递归”其实和“数学归纳法”的思路非常像**：证明N=1时成立；证明若N=n-1成立，则N=n时也成立；如上两步得证，则命题在n>1时一定成立（n为自然数）。你看，我们没必要从1开始逐一验证每个自然数，只要证明了“基础条件”、再证明了“递推条件”，大自然的规律会帮我们搞定一切。\n\n　　换句话说，只要我们：\n\n##### 1、写程序告诉电脑“如何分解一个问题”(即把汉诺塔问题分解为如上三步)\n\n##### 2、写程序告诉电脑“当该问题分解到最简时如何处理”(即第二步中的直接把它从src移到dst)\n\n　　那么，“具体如何递推、如何回归”这个简单问题就不要再操心了，电脑自己能搞定。\n\n　　——写出问题分解方法、写出分解到最简后如何解决，这是我们的任务；把问题搞定，是电脑的任务。这就是递归的魅力。\n\n　　正是由于这种“我提供思路你搞定细节”的特点，“一切皆递归”的函数系语言才被称为“声明式编程”（而不是必须一步一步指导电脑如何做的“命令式编程”）。\n\n[更多的关于汉诺塔递归问题可以参考](https://www.zhihu.com/question/24385418,\"如何理解汉诺塔的递归？\")\n\n　　\n\n\n　　\n\n\n\n"},{"title":"JS中的取整","url":"/2018/04/15/JS中的取整/","content":"\n## JS中的取整\n\n### Math.ceil()——>天花板，向上取整\n\n　　-9 ——> 0 ——> 9，沿着这个方向无论正负都向上取整。\n\n### Math.floor()——>地板，向下取整\n\n　　-9 <—— 0 <—— 9，沿着这个方向无论正负都向下取整。\n\n### 如何像其它语言那样向零取整\n\n　　先给Function.prototype添加method()方法使得该方法对所有函数可用：\n```bash\n\tFunction.prototype.method=function(name,func){\n\t\tthis.prototype[name]=func;//方法调用模式，this绑定到该对象，即Function，再更新Function对象新增新的name属性\n\t\treturn this;\n\t}\n```\n　　然后给Number.prototype添加向零取整方法interger()，具体如下：\n```bash\n\tNumber.method(\"integer\",function(){\n\t\treturn Math[this<0 ? \"ceil\" : \"floor\"](this);\n\t});\n\talert((-5.9).integer());\n```\n\n### Math.round()——>把一个数字四舍五入为最接近的整数\n\n　　正数很正常:5.4——>5 , 5.5——>6\n　　负数有点小注意:-5.4——>-5, -5.5——>-5 , -5.51——>-6\n"},{"title":"阻止事件的一些操作","url":"/2018/04/14/阻止事件的一些操作/","content":"\n## 阻止事件冒泡或捕获\n\n　　有时会遇到如下情况，本元素和父层元素都有事件，但我们只想要本元素事件激活，即要阻止事件冒泡\nHTML:\n```bash\n\t<!DOCTYPE html>\n\t<html>\n\t\t<head>\n\t\t\t<meta charset=\"UTF-8\">\n\t\t\t<title></title>\n\t\t\t\n\t\t</head>\n\t\t<body>\n\t\t\t<button onclick=\"clickBtn(event)\">Push Me</button>\n\t\t</body>\n\t\t<script type=\"text/javascript\">\n\t\t\tdocument.onclick=function(){\n\t\t\t\talert(\"body\");\n\t\t\t}\n\t\t\tfunction clickBtn(event){\n\t\t\t\tevent= event ? event : window.event;\n\t\t\t\talert(\"button\");\n\t\t\t\tevent.stopPropagation();\n\t\t\t\t//event.cancelBubble=true;\n\t\t\t}\n\t\t</script>\n\t</html>\n```\n### cancelBubble\n\n　　cancelBubble原本是IE独有，经测试发现它也可以在Chrome和Firefox中阻止冒泡，那是因为人家Chrome，Firefox 考虑周到，提供了这么一种可选的方式。 但是，cancelBubble已经不在标准中了，相信迟早它们会移除这一特性的。\n\n### DOM的stopPropagation()方法\n\n　　这是DOM层次的方法，用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。两者的区别为：\n　　IE不支持事件捕获，因而只能取消事件冒泡，但stopPropagation()可以同时取消事件捕获和冒泡。\n\n## 阻止事件默认行为\n\n　　下面是一个阻止右键菜单栏事件的小程序\n```bash\n\t<script type=\"text/javascript\">\n\t\tdocument.oncontextmenu=function(event){\n\t\t\tevent= event ? event : window.event;\n\t\t\t/*下面这三种方法都可以*/\n\t\t\t//event.preventDefault();\n\t\t\t//event.returnValue=false;\n\t\t\treturn false;\n\t\t}\n\t</script>\n```\n\n### returnValue=false\n　　也是原本IE的方法，它也可以在它也可以在Chrome和Firefox中阻止事件默认行为。\n\n### DOM的preventDefault()方法\n　　简单直观，直接阻止默认的行为，可以用在多个情况。\n"},{"title":"变量提升","url":"/2018/04/14/变量提升/","content":"\n## 变量提升\n\n　　最近发现了一个小问题：\n```bash\n\tvar x=\"global value\";\n\tfunction getValue(){\n\t\talert(x);//undefined\n\t\tvar x=\"local value\";\n\t\talert(x);//local value\n\t}\n\tgetValue();\n```\n　　我们可以发现第一个alert(x)结果为undefined，这就跟JS的**变量提升**有关系了。\n　　var关键字声明变量，无论声明在何处，都会被视为声明在函数的*最顶部*(不在函数内即在全局作用域的最顶部)，这就是函数的**变量提升**。所以上面的代码实际上是：\n```bash\n\tvar x=\"global value\";\n\tfunction getValue(){\n\t\tvar x; //普通的变量初始化就是undefined，所以就好理解了\n\t\talert(x);\n\t\tvar x=\"local value\";\n\t\talert(x);\n\t}\n\tgetValue();\n```"},{"title":"text-indent: -9999px;作用","url":"/2018/04/11/text-indent-9999px-作用/","content":"\n## text-indent: -9999px;作用\n\n　　最近在做星级评分系统作业时遇到了这个写法。\nHTML:\n```bash\n\t<span>点击星星就能打分</span>\n\t<ul>\n\t\t<li class=\"\"><a href=\"javascript:;\">1</a></li>\n\t\t<li class=\"\"><a href=\"javascript:;\">2</a></li>\n\t\t<li class=\"\"><a href=\"javascript:;\">3</a></li>\n\t\t<li class=\"\"><a href=\"javascript:;\">4</a></li>\n\t\t<li class=\"\"><a href=\"javascript:;\">5</a></li>\n\t</ul>\n```\nCSS:\n```bash\n\t#star li{\n\t\twidth: 24px;\n\t\tfloat: left;\n\t\tcursor: pointer;\n\t\ttext-indent: -9999px;/*<a>之间有文字，有时为了搜索引擎需要,但我们实际的星星上不想要文字，则添加了这个属性隐藏它*/\n\t\tbackground: url(img/star.png) no-repeat;\n\t}\n```\n　　text-indent:-9999px 一般用于隐藏文字。比如LOGO 部分，因为SEO(Search Engine Optimization)搜索引擎优化 的需要，所以要有文字在，但事实上显示的时候用了图片代替，所以就要使用text-indent:-9999px; 把它从界面上隐藏掉。\n　　text-indent 是缩进，使用9999 是为了让他的缩进足够大，大分辨率下也能缩到不见。\n"},{"title":"offsetLeft和style.left","url":"/2018/04/11/offsetLeft和style-left/","content":"\n## offsetLeft和style.left\n\n### offsetLeft\n\n　　1.如果父辈元素中有定位的元素，那么就返回距离当前元素最近的定位元素边缘的距离。\n　　2.如果父辈元素中没有定位元素，那么就返回相对于body左边缘距离。\n\n### 两者的区别\n\n　　1. style.left 返回的是字符串，如28px，offsetLeft返回的是数值28，如果需要对取得的值进行计算，还用offsetLeft比较方便。\n　　2. style.left是读写的，offsetLeft是只读的，所以要改变元素的位置，只能修改style.left。\n　　3. style.left的值需要事先定义，否则取到的值为空。而且必须要定义在html里，offsetLeft的值随时可以取到。\n"},{"title":"JS清空数组的方法","url":"/2018/04/10/JS清空数组的方法/","content":"\n### ①splice\n```bash\n\tvar ary = [1,2,3,4]; \n\tary.splice(0); //不用写要删的长度，直接从0全删掉\n```\n\n### ②length=0\n```bash\n\tvar ary = [1,2,3,4]; \n\tary.length=0; \n```\n　　这种方式很有意思，其它语言如Java，其数组的length是只读的，不能被赋值。而JS中则可以。\n\n### ③赋值为[]\n```bash\n\tvar ary = [1,2,3,4]; \n\tary = []; // 赋值为一个空数组以达到清空原数组\n```\n　　方式2 保留了数组其它属性，方式3 则未保留。很多人认为方式2的效率很高些，因为仅仅是给length重新赋值了，而方式3则重新建立个对象。经 测试 恰恰是方式3的效率高。测试代码：\n```bash\n\tvar a=[];\n\tfor(var i=0;i<1000000;i++){\n\t\ta.push(i);\n\t}\n\tvar start=new Date();\n\ta=[];\n\tvar end=new Date();\n\talert(end-start);\n```\n　　可以多试几个浏览器，结果是方式3更快一点点。"},{"title":"内联元素和块元素","url":"/2018/04/07/内联元素和块元素/","content":"\n## 内联元素和块元素\n\n### ①块级元素:默认100%撑满外层盒子的宽度（浏览器显示区域），独占一行，垂直排列，里能用行内元素，可以设置宽高\n　　|-->div 没有任何CSS属性（主要用在大框架）\n　　|-->p     自带上下外边据  （用在段落）\n　　|-->h1-h6   自带上下外边据，自带字体大小（用在栏目大标题）\n　　|-->ul li       自带上下外边据，li自带圆点 （用在列表，多个元素大小一致）\n　　|-->dl dt dd   用在带标题的列表上 \n\n### ②行内元素（内联元素）:默认宽度只有本身所占的宽度，默认水平排列，不支持宽高 ，margin padding左右有效果 上下没有效果\n　　|-->a  超链接  自带标签颜色、鼠标放上颜色，点击时的颜色，点击过颜色，下划线\n　　|--> span \n　　|-->em、i（默认斜体）\n　　|-->strong,b（默认加粗）\n　　|-->u（默认下划线）\n   \n### ③行内块级元素:默认宽度只有本身所占的宽度，默认水平排列，支持宽高，受到父级text-align影响，可以居中\n　　|-->img 图片 \n　　|-->input 输入框\n　　|-->select  下拉菜单\n　　|-->textarea 输入区域\n\nIE6----------------BUG----------------------\n块级元素转化成行内块级元素   IE6不支持\n行内元素转化成行内块级元素 IE6支持\n\n块级元素加上position:absolute fixed（定位）或者浮动 宽度不是100% 是本身内容的宽度\n行内元素加上position:absolute fixed（定位）或者浮动  就会变成块级元素\n\n## display:block; display:inline;和display:inline-block;\n\n### block：使用此属性后，元素会被显示为块级元素，元素会进行换行，默认宽度为撑满外层盒子的宽度(因为块元素霸道)。\n### inline：使用此属性后，元素会被显示为内联元素，元素则不会换行，默认宽度为内容的宽度。\n### inline-block：是使元素以块级元素的形式呈现在行内。意思就是说，让这个元素显示在同一行不换行，但是又可以控制高度和宽度，这相当于行内元素的增强。\n　　应用：\n　　1.display:inline-block把一个元素变成块级元素，但他的大小只是他本身内容的大小并不撑满外围盒子，如下图所示：\n　　![图片放在GitHub仓库里了也显示不出来...](https://github.com/Daoma666/JS-CSS_train1/blob/master/img/display.jpg)所以在一道练习中出现下面的情况：\n```bash\n\t<li><a href=\"javascript:;\">手写</a></li>\n```\n　　若不把a变成块元素，则a上的背景不会撑满整个li。\n\n　　2.li是块元素，原本会换行，是竖着一列的布局，但改为inline-block并在父元素指定了width后，则会以块级元素的形式呈现在行内，不换行，但能控制高度宽度，这样就可以变成一行行排列的布局了。\n\n## css属性\n　　| ----------①盒子模型：width、height，padding、border、margin\n 　　　注意事项：padding 上下左右 全部相加       margin 上下取最大  左右相加     margin-top如想父级元素不受影响，父级元素要加overflow:hidden\n　　| ----------②-1 背景相关：background背景缩写:background-color,background-image,background-repeat,background-attachment,background-position\n　　| ----------②-2 文本样式：font-size文字大小/line-height行高、color文本颜色、text-align水平位置、font-family文字字体、letter-spcing文字间隔、text-decoration文本样式\n　　| ----------②-3 UL li：list-style列表样式\n　　| ----------②-4 A链接：a{}\n　　　　a:link - 普通的、未被访问的链接\n　　　　a:visited - 用户已访问的链接\n　　　　a:hover - 鼠标指针位于链接的上方\n　　　　a:active - 链接被点击的时刻\n　　| ----------③选择器    style 优先级最高  |   ID选择器   #xxx  id=\"xxx\"  |  类选择器 .xxx  class=\"xxx\"  |   元素选择器   p  | 后代选择器   .xxx .yyy\n　　| ----------④定位        float（浮动）  position（定位）：relative（相对）absolute（绝对）fixed（相对浏览器固定）"},{"title":"定位与浮动","url":"/2018/04/07/定位与浮动/","content":"\n## 元素加上浮动float后的影响\n\n　　0.float设计初衷就是为了实现文字环绕效果，[详情请见](http://www.cnblogs.com/liyunhua/p/4670908.html \"你所不了解的float(滥用float的怪异现象)\")\n　　1.浮动的参考对象：浮动的框可以向左或向右移动，直到它的外边缘碰到**包含框**或**另一个浮动框的边框**为止。\n　　2.父级元素受影响：该元素脱离文档流，使父级元素高度消失，在父级元素上加overflow:hidden 或 加height 或在父级元素上加一个clearfix类来修复父级元素的高度 (content 属性与 :before 及 :after 伪元素配合使用，定义元素之前或之后放置的生成内容。其中\\0020是空格的转义字符，一般直接写空格就行)\n```bash\n\t.clearfix:before, .clearfix:after { content: \"\\0020\"; display: block; height: 0; overflow: hidden; }  \n\t.clearfix:after { clear: both; }  \n\t.clearfix { zoom: 1; }  \n```\n　　3.设置了float的元素,**脱离了文档流，但没有脱离文本流**。也就是说当它后面还有元素时，其他元素会无视它所占据了的区域，直接在它身下布局。但是文字却会认同浮动元素所占据的区域，围绕它布局。 \n　　4.同级不加浮动的元素受影响：正常没加浮动的文档流元素，会无视该浮动元素   在没加浮动的元素上加 clear:both 来修复该元素上面浮动元素所占的高度\n\n## 定位详解\n\n　　值\t　　　　　　描述\n　　static\t　　　　默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。\n　　relative　　　位置被设置为 relative 的元素，可将其移至**相对于其本身**正常位置的地方，因此 \"left:20\" 会将元素移至元素正常位置左边 20 个像素的位置。\n　　absolute　　位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 **\"left\"、\"top\"、\"right\" 以及 \"bottom\" 属性**来规定。\n　　fixed　　　　位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 \"left\"、\"top\"、\"right\" 以及\"bottom\" 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。\n\n### 扩充详解　position:absolute\n\n　　这个顾名思义是绝对布局，在元素中设置之后，该元素会完全脱离文档流，它并不是相对于浏览器进行定位，**而是一层一层向上寻找父元素，直到寻找到第一个position不为static的祖先元素，它相对于这个祖先元素进行定位。**\n　　所以当你的父元素position:relative时，该子元素才会相对于你的父元素进行定位。如果任何一个祖先元素都没有设置position:relative，寻找到最外层的顶级元素html后自然不会继续寻找，所以这时才是相对于浏览器进行定位。\n　　我们可以看一个小例子：\nHTML:\n```bash\n\t<div id=\"outer\">\n\t\t<div id=\"inner\">\n\t\t\t<div id=\"deepinner\">\t\t\n\t\t\t</div>\n\t\t</div>\n\t</div>\n```\nCSS:\n```bash\n\t*{\n\t\tmargin: 0;\n\t\tpadding: 0;\t\n\t}\n\t#outer{\n\t\twidth: 500px;\n\t\theight: 500px;\n\t\tborder: 1px solid #000;\n\t\tmargin-left:100px;\n\t\tposition: relative;\n\t}\n\t#inner{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tposition: absolute;\n\t\tborder: 1px solid red;\n\t\tleft: 100px;\n\t\ttop: 100px;\n\t}\n\t#deepinner{\n\t\twidth:100px;\n\t\theight: 100px;\n\t\tposition: absolute;\n\t\tborder: 1px solid red;\n\t\tleft: 50px;\n\t}\n```\n　　可以发现deepinner层相对与inner层偏移了50px，所以可以证明absolute是**一层一层向上寻找父元素，直到寻找到第一个position不为static的祖先元素，它相对于这个祖先元素进行定位。**，这里deepinner层相对的就是inner层。\n\n### 元素加上absolute和fixed后的影响\n\n　　1.宽度改变：该元素宽度变成设置的宽度，如果无则是内部元素所占的宽度   可以加宽度修复，也可以不加，就使用自身内容大小\n　　2.元素类型改变：内联元素可以变成块级元素。\n　　3.文档流影响：元素完全脱离文档流，**同级的定位，后写的在上层**，可以通过z-index 解决层级"},{"title":"JS中style,currentStyle和getComputedStyle的区别以及获取css操作方法","url":"/2018/04/06/JS中style-currentStyle和getComputedStyle的区别以及获取css操作方法/","content":"\n## JS中style,currentStyle和getComputedStyle的区别以及获取css操作方法\n\n　　首先需要了解CSS的三种使用方法：\n　　1.行内样式\n```bash\n\t<!doctype html>\n\t<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>css行内样式</title>\n\t</head>\n\t<body>\n\t<div style=\"width:100px;height:100px;background:red;\"></div>\n\t\t\n\t</body>\n\t</html>\n```\n　　2.内嵌样式\n```bash\n\t!doctype html>\n\t<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>css内嵌样式</title>\n\t</head>\n\t<body>\n\t<style type=\"text/css\">\n\t#div{width:100px;height:100px;background:red;}\n\t</style>\n\t<div id=\"div\"></div>\n\t\t\n\t</body>\n\t</html>\n```\n　　3.外部样式\n```bash\n\t<!doctype html>\n\t<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>css内嵌样式</title>\n\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"XX.css\">\n\t</head>\n\t<body>\n\t<div id=\"div\"></div>\n\t\t\n\t</body>\n\t</html>\n```\n　　最近做了个小练习，点击h2想让ul元素在隐藏和显示中切换，但发现第一次点击总是无效，必须点到第二下以后才有想要的效果\nHTML:\n```bash\n\t<h2>播放列表...</h2>\n\t<ul>\n\t\t<li><a href=\"javascript:;\">玩家之徒 - 蔡依林</a></li>\n\t\t<li><a href=\"javascript:;\">原谅我就是这样的女生 - 戴佩妮</a></li>\n\t\t<li><a href=\"javascript:;\">猜不透 - 丁当</a></li>\n\t\t<li><a href=\"javascript:;\">自导自演 - 周杰伦</a></li>\n\t\t<li><a href=\"javascript:;\">浪漫窝 - 弦子</a></li>\n\t\t<li><a href=\"javascript:;\">流年 - 王菲</a></li>\n\t</ul>\n```\n\nJS:\n```bash\n\tvar oUl=document.getElementsByTagName(\"UL\")[0];\n\tvar oH2=document.getElementsByTagName(\"H2\")[0];\n\toH2.onclick=function(event){\n\t\toUl.style.display=oUl.style.display==\"block\"?\"none\":\"block\";\n\t}\n```\n\n　　原因为我以为ul默认为display:block; JS中的oUl.style.display能获取到block这个样式，但其实不然，**js的style属性只能获取行内样式**,所以一开始oUl.style.display=undefined，自然就不会第一下点击就隐藏了。\n　　解决方法是:在行内直接写入样式\n```bash\n\t<ul style=\"display: block;\">\n\t...\n\t</ul>\n```\n　　这样就能获取到了，所以在这里做一个总结：\n\n### ①style:各大浏览器都兼容,能设置样式和获取样式,但是获取不了外部样式,如果写了行内没有的样式,返回的是空值\n\n　　写法:ele.style.attr(获取),ele.style.attr=\"值\"(设置);\n　　注意只是获取不了外部样式，但可以设置外部样式。\n\n### currentStyle属性和getComputedStyle属性不能设置属性,只能获取\n### ②currentStyle:该属性只兼容IE,不兼容火狐和谷歌\n\n　　写法:ele.currentStyle[\"attr\"]或者ele.currentStyle.attr;\n\n### ③getComputedStyle:该属性是兼容火狐谷歌,不兼容IE9.0一下版本\n\n　　写法:window.getComputedStyle(ele,null)[attr]获取是window.getComputedStyle(ele,null).attr\n"},{"title":"网页导航栏小技巧","url":"/2018/04/03/网页导航栏小技巧/","content":"\n## 使用li+a构建网页导航栏\n\n　　首先说一下建导航栏时使用li+a而不是直接使用li的原因：一般导航都是具有超链接功能，a标签具有这个功能，而lis标签只是罗列信息列表，不具备链接功能。\n　　方法：一般我们在li中指定width，float;然后在a中使用display:block;再指定width和height，让它自动填充li即可。\n　　具体小例子见代码：\nHTML：\n```bash\n\t<div id=\"nav\">\n\t\t<ul>\n\t\t\t<li><a href=\"javascript:;\">站长之家</a></li>\n\t\t\t<li><a href=\"javascript:;\">行业资讯</a></li>\n\t\t\t<li><a href=\"javascript:;\">站长在线</a></li>\n\t\t\t<li><a href=\"javascript:;\">网站运营</a></li>\n\t\t\t<li><a href=\"javascript:;\">设计在线</a></li>\n\t\t\t<li><a href=\"javascript:;\">网络编程</a></li>\n\t\t\t<li><a href=\"javascript:;\">联盟资讯</a></li>\n\t\t\t<li><a href=\"javascript:;\">服务器</a></li>\n\t\t</ul>\n\t</div>\n```\nCSS：\n```bash\n\t#nav{\n\t\twidth: 730px;\n\t\tmargin: 20px auto;\n\t\tborder:1px solid blue;\n\t\tbackground: blue;\n\t}\n\t#nav ul{\n\t\tlist-style-type: none;\n\t\toverflow: hidden;\n\t\tmargin-left: 10px;\n\t}\n\t#nav ul li{\n\t\twidth: 80px;\n\t\tfloat: left;\n\t\tmargin-right: 10px;\t\t\t\n\t\tbackground: cornflowerblue;\n\t\tcursor: pointer;\n\t}\n\t#nav ul li a{\n\t\tdisplay: block;\n\t\twidth: 80px;\n\t\theight: 30px;\n\t\tline-height: 30px;\n\t\tpadding: 5px 0;\n\t\ttext-align: center;\n\t\ttext-decoration: none;\n\t\tcolor: #fff;\n\t}\n\t#nav ul li a:hover{\n\t\tfont-weight: 700;\n\t\tbackground: #aaa;\n\t}\n```\n　　麻雀虽小五脏俱全啊，涵盖了很多最近学到的知识点，算是在此纪念一下吧。"},{"title":"正则表达式摸门把级整理","url":"/2018/04/02/正则表达式摸门把级整理/","content":"\n### ①常用的元字符 (一些有特异功能的用来方便匹配的字符)\n\n　　代码　　说明\n　　.\t　　匹配除换行符以外的任意字符\n　　\\w　　匹配字母或数字或下划线或汉字\n　　\\s　　匹配任意的空白符\n　　\\d　　匹配数字\n　　\\b　　匹配单词的开始或结束\n　　^\t　　匹配字符串的开始\n　　$\t　　匹配字符串的结束\n\n　　^\\d{5,12}$　　因为使用了^和$，所以检测的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个字符串必须是5到12个数字。\n\n### ②常用的限定符 (表示它前面的字符重复的次数)\n\n　　代码　　说明\n　　*\t　　重复零次或更多次\n　　+\t　　重复一次或更多次\n　　?\t　　重复零次或一次\n　　{n}　　重复n次\n　　{n,}　　重复n次或更多次\n　　{n,m}\t　重复n到m次\n\n　　\\(?0\\d{2}[) -]?\\d{8}　　首先是一个转义字符\\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现0次或1次(?)，最后是8个数字(\\d{8})。\n\n### ③字符范围 \n\n　　代码　　说明\n　　[]　　　　匹配方括号中任意字符\n　　[0-9]　　代表的含意与\\d就是完全一致的：匹配任意一位数字\n\n### ④分枝条件\n\n　　代码　　说明\n　　|　　　　匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n　　\n　　\\d{5}-\\d{4}|\\d{5}　　这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。\n\n### ⑤分组\n\n　　代码　　说明\n　　()　　重复单个字符,直接在字符后面加上限定符就行了；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了\n\n　　(\\d{1,3}\\.){3}\\d{1,3}　　是一个简单的IP地址匹配表达式。  \\d{1,3}匹配1到3位的数字，(\\d{1,3}\\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。\n\n### ⑥反义\n\n　　代码/语法\t说明\n　　\\W　　　　匹配任意不是字母，数字，下划线，汉字的字符\n　　\\S　　　　匹配任意不是空白符的字符\n　　\\D　　　　匹配任意非数字的字符\n　　\\B　　　　匹配不是单词开头或结束的位置\n　　[^x]　　　　匹配除了x以外的任意字符\n　　[^aeiou]　　　　匹配除了aeiou这几个字母以外的任意字符\n\n　　<a[^>]+>　　匹配用尖括号括起来的以a开头的字符串。\n\n　　具体请参考：[快速入门正则表达式](http://www.jb51.net/tools/zhengze.html \"快速入门正则表达式\")\n"},{"title":"加载图片的小技巧","url":"/2018/03/31/加载图片的小技巧/","content":"\n## image的onload事件和complete属性\n\n　　在做一个\"鼠标移过，修改图片路径\"作业的时候，想要附加一个功能：即图片不能显示的话，就给把该图片设置为一个替代的loading图片。\nHTML:\n```bash\n\t<li class=\"first\">\n\t\t<img src=\"img/big_1.jpg\">\n\t\t<div id=\"loading\" style=\"display: none;\"></div>\n\t</li>\n```\nJS:\n```bash\n\tfor(var i=1;i<oImg.length;i++){\n\t\toImg[i].onmousemove=function(){\n\t\t\tvar img=new Image();\n\t\t\timg.src=oImg[0].src=this.src.replace(/small/,\"big\");\n\t\t\tloading.style.display=\"block\";\n\t\t\timg.complete?loading.style.display=\"none\":oImg[0].onload=function(){\n\t\t\t\tloading.style.display=\"none\";\n\t\t\t}\n\t\t}\n\t}\n```\n　　在这里我们可以**用complete来判断图片是否加载完毕**，如果加载完毕，则把loading图片所在的那层隐藏掉。\n　　如果未加载完毕或遇到错误，则执行\n```bash\n\toImg[0].onload=function(){\n\t\tloading.style.display=\"none\";\n\t}\n```\n　　这里**onload事件表示等图片加载完成后要进行的操作**，所以接着上面的逻辑，则可以当图片加载完毕后再把loading图片所在层隐藏，若是图片出现错误，则会一直显示loading图片。\n\n　　大家可以注意到，代码里使用了**new Image()**方法做图片预加载,用没有挂载到dom树上的img对象请求图片。请求成功后图片会被缓存，这时再给真实img元素的src赋值就可以直接使用缓存的图片了,优点是可以加快页面渲染速度。但只可惜我现在才疏学浅，并没看懂在该例中有啥用。。。\n　　[详细用法请见](https://blog.csdn.net/dcb_ripple/article/details/52175842,\"js 中的Image对象\")\n　　[预加载的简便理解](http://www.jb51.net/article/43507.htm,\"js中Image对象以及对其预加载处理示例\")\n"},{"title":"一些零星的JS，CSS知识","url":"/2018/03/27/一些零星的JS，CSS知识/","content":"\n## CSS 使用border画三角形\n\n　　盒模型中上下左右边框交界处呈现平滑的斜线. 利用这个特点, 通过设置不同的上下左右边框宽度或者颜色可以得到小三角, 小梯形等。[具体链接](http://caibaojian.com/css-border-triangle.html \"CSS三角形的实现原理及运用\")\n\n## CSS 实现居中的方法\n\n### 使用width和margin实现水平居中\n　　width指定完宽度，就可以直接margin:0 auto;实现左右居中了\n\n### 使用text-align实现水平居中\n　　使内联元素居中，所以要在想居中的内联元素的父元素中使用\n\n### 使用top,left和margin实现水平竖直的居中\n\n　　方法就是top: 50%;left: 50%;然后margin: -所在盒子宽度/2 0 0 -所在盒子高度/2;(可用于弹窗弹出到页面正中间)\n\n### 使用line-height实现文本垂直居中\n\n　　方法为：把line-height设置为父容器的高度就可以实现文本垂直居中。具体原理请见：[行高原理](https://www.imooc.com/article/7767 \"CSS行高（line-height）及文本垂直居中原理\")\n\n## js中{}大括号,[]中括号使用详解\n\n### { }大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数。\n\n```bash\n\tvar mayun={\n\t\tname: \"cocl\",\n\t\tage: function(){\n\t\t\talert(\"21\");\n\t\t}\n\t}\n\tmayun.age();\n```\n\n### [ ]中括号，表示一个数组，也可以理解为一个数组对象。 \n"},{"title":"JS for-in语句的使用","url":"/2018/03/26/JS-for-in语句的使用/","content":"\n## JS for-in语句的使用\n\n　　*  js中for循环一般用于遍历数组\n　　*  for-in一般用于循环遍历对象的属性 \n　　虽然数组在js中也是对象，技术上说，我们可以使用for-in循环数组，如下：\n```bash\n\tvar oSkin=document.getElementById(\"skin\").getElementsByTagName(\"LI\");\n\tfor(var p in oSkin){\n\t\talert(p);\n\t}\n```\n　　此时输出(假设oSkin包含了3个LI)为0,1,2,length,item,namedItem，原因为：for-in如果遍历的是数组，那么i是代表这个数组的索引值，如果遍历的是个对象，那么i代表的是这个数组的属性值。因为oSkin是个HTTPCollection对象，所以它是一个对象数组里面装了3个LI对象，于是就会既有索引值，又有它自己的属性。\n　　所以要想遍历该数组的三个LI，需要：\n```bash\n\tfor(var p in oSkin){\n\t\toSkin[p].doSomeThing();\n\t}\n```\n　　题外话：今天在经过了主题制作者大佬的点拨下，准备趁着在学校的最后一个学期用*Socket.io+JS*写一个*聊天室系统*，这样也算有个项目可以去实习了哈哈(想的挺美，可惜现在写不出来)，所以还是要务实基础啊，加油！\n"},{"title":"CSS 使用overflow:hidden清除浮动","url":"/2018/03/26/CSS-使用overflow-hidden清除浮动/","content":"\n## CSS 使用overflow:hidden清除浮动\n\n　　今天做了一道网页换肤的练习，但发现了其中的两个小问题，详情如下：\n```bash\n\t<div id=\"outer\">\n\t\t<ul id=\"skin\">\n\t\t\t<li id=\"red\" title=\"红色\"></li>\n\t\t\t<li id=\"green\" title=\"绿色\"></li>\n\t\t\t<li id=\"blue\" title=\"蓝色\"></li>\n\t\t</ul>\n\t\t<ul id=\"nav\">\n\t\t\t\t<!--\n                \tjavascript: 是一个伪协议javascript:是表示在触发<a>默认动作时，执行一段JavaScript代码，\n                \t而 javascript:;表示什么都不执行，这样点击<a>时就没有任何反应。\n                -->\n\t\t\t\t<li><a href=\"javascript:;\">新闻</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">娱乐</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">体育</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">电影</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">音乐</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">旅游</a></li>\n\t\t</ul>\n\t</div>\n```\n　　在div里有两个ul，对它们的li分别都设置了float: left后发现：\n　　1.  这两个ul中的li都脱离了文档流，跑到一行上去了\n　　2.  为ul设置过黑色背景，但都消失了\n　　于是我使用了br来换行，但发现原作者并没有这样做，这不由得让我产生了疑问。在反复查看源码后，我发现是overflow: hidden;在起作用，遂到网上一查发现，它并不只有**隐藏溢出**的功能，还有**清除浮动**和**解除坍塌**的功能。原理如下：\n　　浮动的元素(两个ul中的li)脱离文档元素， 不占据空间，所以跑到了一行上。 不浮动的元素(ul,div)会直接无视掉这个元素。因为我们没有设置父ul的高度，父ul无视了自己的两个孩子，其高度变为0，所以父ul没有显现。 解决方法就是：\n　　1.  如果只想换行，给ul添加overflow:hidden属性即可，清除浮动，恢复它原先占据的ul的位置\n　　2.  为父ul添加overflow:hidden属性用以清除浮动，使得父ul显现\n\n　　若想更细致的查看该属性的用法：[详细链接](https://blog.csdn.net/hukaihe/article/details/51298665 \"深入理解：overflow:hidden——溢出,坍塌,清除浮动\")\n"},{"title":"JS中&&和||的奇怪用法","url":"/2018/03/25/JS中-和-的奇怪用法/","content":"## JS中&&和||的奇怪用法\n\n　　最近正在学 JS，找了点练习来做，然后看到如下的代码：\n```bash\n\tfor (var i = 0; i < oBtn.length; i++)\n\t{\n\t\toBtn[i].index = i;\n\t\toBtn[i].onclick = function ()\n\t\t{\n\t\tthis.index == oBtn.length - 1 && (oDiv.style.cssText = \"\");\n\t\tchangeStyle(oDiv, oAtt[this.index], oVal[this.index]);\n\t\t}\n\t}\n```\n　　然后我上网搜了一下明白了 var c=a||b;或var c=a&&b;这种情况时\n**a && b :如果执行 a 后返回 true，则执行 b 并返回 b 的值；如果执行 a 后返回 false，则整个表达式返回 a 的值，b 不执行**\n**a || b :如果执行 a 后返回 true，则整个表达式返回 a 的值，b 不执行；如果执行 a 后返回 false，则执行 b 并返回 b 的值**\n\n　　所以这句就好理解了this.index == oBtn.length - 1 && (oDiv.style.cssText = \"\");\n　　这可以算是一种炫技代码⊙﹏⊙，相当于：\n```bash\n\tif(this.index == oBtn.length - 1){\n\t\toDiv.style.cssText = \"\";\n\t}\n```"},{"title":"A Front-end newbie","url":"/2018/03/25/A-Front-end-newbie/","content":"## 新手上路啦\n\n　　忙活了三天搭起了个人的博客，虽然只是开了一个框架，但看到属于自己的页面那一刻，心情是很激动的.作为一只准备投身前端领域的小菜鸟，这一个月越发的感受到了前端的魅力，也见识了前端的深邃，自己目前的水平也就是刚对JS和CSS入了门，上论坛看大家讨论的一堆名词连听都没听说过，所以革命还需努力啦！  \n　　鉴于目前已大三下学期，马上就要找实习了，故在文章最后分享一下最近看到一句话：“你第一个月的工资=你之前看过的所有技术性书籍价值的总和”，我感觉这是非常有道理的，小时候读书少，现在有动力读相关技术的书了，也算是一个好兆头。\n　　最后分享一下搭建博客的过程中用到的教程：\n　　1.  GitHub搭建博客 [具体教程](https://blog.csdn.net/u012075670/article/details/54581015 \"如何用github搭建自己的个人网站\")\n　　2.  Hexo完善博客       [具体教程](https://www.cnblogs.com/visugar/p/6821777.html \"hexo从零开始到搭建完整\")\n　　3.  使用markdown来写博客(ps:要是想要段首缩进可以切换到输入法全角模式打两个空格) [语法参考](https://www.w3cschool.cn/markdownyfsm/cbx1e7.html \"Markdown 语法说明\")\n　　那今天就先到这里啦，我们下篇博客再会！\n"},{"title":"Hello World","url":"/2018/03/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n\n### Generate static files\n\n``` bash\n$ hexo generate or $ hexo g\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Debug\n\n``` bash\n$ hexo s --debug\n```\n\nMore info: [Server](https://hexo.io/zh-cn/docs/commands.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy or $ hexo d\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]
[{"title":"JS中的数值运算","url":"/2018/05/31/JS中的数值运算/","content":"## 虽然有不少坑但是比较可靠的parseInt\n\n#### Number.parseInt(string,radix) 默认接收两个参数\n\n　　第一个参数是默认是** string **类型值，如果不是，会通过抽象的 ToString 强制转化成 string 类型的值。这其中就会有强制类型转换过程中的各种坑\n\n　　第二个参数是 number 类型的进制，如果不是，会通过抽象的 ToNumber 强制转化成 number 类型的值，范围是 2-36，通过强制类型转换后如果是其他值会返回 NaN。在 ES5 之前如果没有传入这个参数，会根据第一个参数的开头来判断进制，0 开头的字符串会判断成八进制，也就是很多人提到的老黄历坑。ES5 之后已经解决，不传这个参数默认十进制。但是这个参数容易被忽略，尤其是在和 map 之类的也容易忽略后续可选参数的函数搭配使用的时候，比如\n\n```bash\n['10', '10', '10', '10'].map(parseInt) // 结果是 [10, NaN, 2, 3]\n['10', '10', '10', '10'].map(x=>parseInt(x,10)) //正确的做法\n```\n\n　　所以如果只是用 parseInt 来 “取整”，一个良好的习惯是**永远记得设置第二个参数为 10**\n\n## 巧妙使用位操作符\n\n　　JavaScript 中的 number 类型的值都是使用 IEEE 754 标准的 **64 位**双精度浮点型存储，即* 1 位符号位 + 11 位指数部分 + 52 位尾数部分 *。用来表示整数时，安全的范围是 **53 位**，超出这个返回可能会造成精度丢失\n\n1. 使用**按位或**向下取整(数值不够大才能用)\n\n```bash\nvar num=-9999999.1234;\nvar int=num|0;\nconsole.log(int);   //-9999999\n\nvar num=-9999999999.1234;\nvar int=num|0;\nconsole.log(int);   //-1410065407\n```\n\n2. 按位非（按位取反）任意数值x相当于-(x+1)\n\n```bash\nconsole.log(~1);    //-2\nconsole.log(~0);    //-1\nconsole.log(~-1);   //0\n\nconsole.log(~NaN);  //-1\nconsole.log(~[]);   //-1\n```\n\n　　我们可以发现：**-1 是唯一一个经过 ~ 运算返回假值0的值**（包括其他那些特殊的值比如 NaN、{}、[] 等都不会返回假值）\n\n　　所以字符串和数组的 indexOf 函数查找失败会返回 -1，这时候就可以用：\n\n```bash\nif(~str.indexOf('str')) // 来表示查找失败\n```\n\n比判断 >= 0 或者 != -1 更优雅，跟用 !! 来判断非假值有异曲同工之妙\n\n## 其它的骚操作\n\n　　JS取0~9的一个随机数可以用: \n```bash\n(Math.random()+\"\").slice(-1);   //eg从0.984652315464中复制最后一个数字4 \n```"},{"title":"JS中new运算符详解","url":"/2018/05/27/JS中new运算符详解/","content":"\n## JS中new运算符和原型链继承\n\n　　看下面的这些东西之前，先好好看看高程的第六章面向对象部分！里面提到了很多基本概念，比如：\n\n1. 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。\n\n2. 对原型所做的修改,能够立即在所有实例中得到反映。\n\n　　因为new运算符会返回一个指向构造器函数原型的对象，所以*通常*情况下this就指向返回的这个对象。\n\n　　其中**new运算符**创建对象的过程，实际上就是：\n\n1. 先克隆Object.prototype对象，得到一个空对象，并把它的prototype属性指向构造器函数的原型对象\n2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）\n3. 执行构造函数中的代码\n4. 返回新对象\n\n　　在Chrome和Firefox等向外暴露了对象__proto__属性的浏览器下，我们可以通过下面这段代码理解new运算的过程：\n\n```bash\nfunction Person(name){\n\tthis.name=name;\n};\n\nPerson.prototype.getName=function(){\n\treturn this.name;\n};\nvar objectFactory=function(){\n\tvar obj=new Object(),\t\t\t\t\t//1. 先克隆Object.prototype对象，得到一个空对象\n\tConstructor=[].shift.call(arguments);\t\t//把第一个参数赋给Constructor变量\n\tobj.__proto__=Constructor.prototype;\t\t//1.指向正确的原型\n\tvar ret=Constructor.apply(obj,arguments);\t//2. 将构造函数的作用域赋给新对象+3. 执行构造函数中的代码\n\treturn typeof ret === \"object\" ? ret : obj;\t//4. 返回新对象\n};  \n\nvar a=objectFactory(Person,\"sven\");\n\nconsole.log(a.name);//sven\nconsole.log(a.getName());//sven\nconsole.log(Object.getPrototypeOf(a) === Person.prototype);//true\n```\n\n　　然后我们就能理解构造器模式是如何创建对象的了：\n\n```bash\nfunction Point(x=10,y=6){\n\tthis.x=x;\n\tthis.y=y;\n}\nPoint.prototype.z=20;\nPoint.prototype.getX=function(){\n\talert(this.x);//不要忘了这里的this也是动态绑定的\n}\n\nvar p=new Point();//此时Point函数里的this动态绑定到p对象上，都是给p加的x,y属性\n\np.getX();               //10 this绑定到p上，相当于alert(p.x)\nalert(p.__proto__.x);   //undefined\np.__proto__.getX()      //undefiend this绑定到p的原型对象上也就是构造器原型对象上，当然没有x啦\nalert(p.z);             //20 虽然p对象本身没有z属性，但如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型\n```\n相关理解图示：[原型继承示意图](https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%9B%BE.jpg?raw=true \"原型继承示意图\")\n\n"},{"title":"实现slideUp/Down效果","url":"/2018/05/20/实现slideUp-Down效果/","content":"\n## 实现slideUp/Down效果\n\n　　最近做网页时，想做一个点击标题滑动出内容的模块，然后看了下参考的源码，结果发现有好几种做法。\n\n#### 第一种最简单，就是使用JQuery的slideUp/Down方法，一步搞定\n\n#### 第二种使用JS配合CSS3的transition属性，但是在该例子中transition需要处理与display的关系，两者貌似搭配起来不会产生效果\n\n　　解决方法是使用setTimeout延时display: none;的操作，因为我最终没有采用这种方法，留待以后检测。\n\n#### 第三种使用纯JS实现，即设置setTimeout来控制层的高度实现滑入滑出效果"},{"title":"Git多人协作","url":"/2018/05/19/Git多人协作/","content":"\n## Git多人协作\n\n　　首先肯定需要对Git的基本操作有一定的认识，这里肯定要放上浅显易懂的：[廖雪峰老师的Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 \"廖雪峰老师的Git教程\")\n\n　　看完后我们就应该对Git有个大体的认识了，然后一般用Git的人中我们分两类：一类就是自己在用着玩，那看完上面的教程差不多就可以自己去摸索了；第二类就是想要多人协作，进行一个项目开发或协同作业，所以我在这里就记一下这几天搞多人协作这块儿踩过的坑。\n\n　　首先干一件事肯定是有个目标，我最近正在和同班同学搞一个网站的小项目，我们前端部分用的VSCode码代码，然后发现里面内置了Git，于是我们就兴冲冲的准备使用，经过一段时间摸索，自己add、commit、push到自己的GitHub时一点问题都没有，于是我们就准备多人协作了，在疯狂网上查找后，我们试出了三种方法。\n\n#### 第一种：fork别人的库成为自己的，然后clone到自己电脑上操作，操作完push到自己的GitHub上，再去自己的GitHub上发起pull request发给项目原作者，经原作者审核后merge\n\n　　具体操作可见：[GitHub上如何进行PR(Pull Request)操作](https://blog.csdn.net/qq_33429968/article/details/62219783 \"GitHub上如何进行PR(Pull Request)操作\")\n\n　　这样可行，但各位仁兄不觉得太过麻烦了吗......而且还需要审核，对于那种开源项目来说肯定是有必要的，但如果就是想四五个人协同作业的话，可以选用下面两种方法。\n\n#### 第二种：进入需要多人协作的项目中配置其它成员的公钥SSH key，然后其他成员即可拥有同等的权限，无需审核\n\n　　如下图：![多人协作方法2](https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/Git1.png?raw=true \"配置其它成员的公钥\")\n\n　　这个方法有一个缺点，那就是需要其他成员把自己的SSH与自己的Github远程库解绑，才能被项目拥有者绑定到这个项目上，所以这就不方便其他成员操作自己的GitHub了。\n\n#### 第三种：添加其他成员为项目协作者collaborators，其他成员也可拥有同等的权限，无需审核\n\n　　如下图：![多人协作方法3](https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/Git2.png?raw=true \"添加其他成员为项目协作者\")\n\n　　综上看如果你是个小项目想多人协作的话，这是最简便的方法，不过这里需要注意一点：项目拥有者发送邀请后，被邀请协作的成员需要去自己的**GitHub注册邮箱**里面找一封确认信！！！可能被标记为**垃圾邮件**了！一定要确认，否则无法完成！\n\n　　最后多人协作肯定会有冲突发生，以后再更新一下解决冲突的方法。\n"},{"title":"JS中this的指向","url":"/2018/05/15/JS中this的指向/","content":"\n## JS中this的指向\n\n    JavaScript中的this总是指向一个对象，而具体指向哪个对象是在**运行时**基于函数的执行环境动态绑定的。\n\n\t有位人说A.apply(x,array);等价于(A.bind(x))(array),现在看着挺对的，留待以后验证。\n\n#### 方法调用模式\n\n　　当函数作为对象的方法被调用时，this指向该对象。\n\n#### 普通函数调用模式\n\n　　this总是指向全局对象，在浏览器中，这个全局对象就是window对象。\n\n    但在使用**严格模式**\"use strict\";时，this在函数调用模式不会指向全局对象window,而是undefined。\n\n#### 构造器调用模式\n\n　　因为new运算符会返回一个指向构造器函数原型的对象，所以*通常*情况下this就指向返回的这个对象。\n\n　　**关于new运算符的内部具体操作请见我博客中的“JS中new运算符详解”！**\n\n　　但还有特殊的情况，比如构造器**显式的返回了一个object类型的对象**时，new调用构造器则会最终返回这个对象，而不是我们期待的this。\n\n#### Function.prototype.apply调用模式\n\n　　详情见我博客中的“JS中的apply()使用详解”一文，它的第一个参数可以改变函数体内this对象的指向。\n\n　　如果我们传入的第一个参数是**null或undefined**，函数体内的this会指向全局对象，在浏览器中则是window。\n\n```bash\nvar func=function(a,b,c){\n    alert(this===window);//true\n};\nfunc.apply(null,[1,2,3]);\nfunc.apply(undefined,[1,2,3]);\n```\n\n　　但如果是在**严格模式**下，则会严格执行第一个参数指定了函数体内this对象的指向，即传进来null，this就指向null;传进来undefined,this就指向undefined\n\n```bash\nvar func=function(a,b,c){\n    \"use strict\";\n    alert(this===null);//true\n};\nfunc.apply(null,[1,2,3]);\n```\n\n#### 闭包中的this指向\n\n　　每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此闭包中永远不可能直接访问外部函数中的这两个变量，this一定是在这个闭包被调用时动态绑定的。如果想使用外层函数的this，最常用的方法就是找一个变量把它保存下来(eg:that)。\n\n### 利用apply实现的bind函数\n\n　　Function.prototype.bind，用来**指定函数内部的this指向**，其*简化版*实现可以这样模拟：\n\n```bash\nFunction.prototype.bind=function(context){\n\tvar that=this;//保存方法调用模式下被调用的原函数\n\treturn function(){//闭包返回一个新函数（可访问外层函数的变量和参数）\n\t\treturn that.apply(context,arguments);//改变that原函数的内部this指向为我们指定的context\n\t}\n};\n\nvar obj1={\n\tname: \"Daoma\",\n};\n\nvar func=function(){\n\talert(this.name);\n};\n\nfunc();//未定义\n\nvar func=function(){\n\talert(this.name);\n}.bind(obj1);\n\t\nfunc();//Daoma\n```\n\n　　通常我们还会实现的稍微复杂一点，可以往func函数中预先填入一些参数：\n\n```bash\nFunction.prototype.bind=function(){\n\tvar that=this,\n\t\tcontext=[].shift.call(arguments),//将第一个元素删掉并返回\n\t\targs=[].slice.call(arguments);//用slice的另一个功能将剩余的参数类数组转换成数组\n\treturn function(){\n\t\t//这里运用了函数柯里化的思想，组合两次分别传入的参数，作为新函数的参数\n\t\treturn that.apply(context,[].concat.call(args,[].slice.call(arguments)));\n\t}\n};\n\t\nvar obj1={\n\tname: \"daoma\",\n};\n\nvar func=function(a,b,c,d){\n\talert(this.name);\n\talert([a,b,c,d]);\n}.bind(obj1,1,2);\n\nfunc(3,4);//即可以传参两次拼到一起\n```\n\n补充bind和call的返回值\n\n1. fun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n　　返回由指定的this值和初始化参数改造的**原函数拷贝**\n\n2. fun.call(thisArg, arg1, arg2, ...)\n\n　　返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。\n\n最后我还有一个需要填的问题坑，留待以后实力提高后解决：[JavaScript中Apply调用模式的this指向问题](https://segmentfault.com/q/1010000014969567?_ea=3765087 \"JavaScript中Apply调用模式的this指向问题JavaScript中Apply调用模式的this指向问题\")"},{"title":"arguments类数组对象详解","url":"/2018/05/15/arguments类数组对象详解/","content":"\n## arguments类数组对象详解\n\n#### arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。\n\n　　它不能像数组一样，进行排序操作或者往集合里添加一个新的元素。\n\n#### 所以我们经常非常频繁的找Array.prototype对象借用方法。\n\n　　像Array.prototype.slice可以把arguments转成真正的数组；想截去arguments列表中头一个元素时，又可以借用Array.prototype.shift方法。\n\n　　要了解这种机制的实现原理，需要查看一下V8引擎的源码，比如Array.prototype.push：\n\n```bash\nfunction ArrayPush(){\n\tvar n=TO_UINT32(this.length); //被push的对象的length\n\tvar m=%_ArgumentsLength(); //push的参数个数\n\tfor(var i=0;i<m;i++){\n\t\tthis[i+n]=%_Arguments(i);  //复制元素\n\t}\n\tthis.length=n+m; //修正length属性的值\n\treturn this.length;\n}\n```\n\n　可见Array.prototype.push实际上是一个**属性复制**的过程，把参数按照下标依次添加到被push的**对象**上面，顺便修改了这个对象的属性。所以只要是个对象，不管是数组对象还是类数组对象，都可以操作。"},{"title":"CSS使用border构建图标","url":"/2018/05/14/CSS使用border构建图标/","content":"\n## CSS使用border构建图标\n\n### 使用border画三角形\n\n　　盒模型中上下左右边框交界处呈现平滑的斜线. 利用这个特点, 通过设置不同的上下左右边框宽度或者颜色可以得到小三角, 小梯形等。[具体链接](http://caibaojian.com/css-border-triangle.html \"CSS三角形的实现原理及运用\")\n\n### 画朝上朝下的√小图标\n\n　　使用border可以画很多与三角形有关的东东，比如我们经常见到的向上向下的“对号图标”就是使用两层border叠加生成的。\n  ![border对号小图标](https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/border%E5%AF%B9%E5%8F%B7%E5%B0%8F%E5%9B%BE%E6%A0%87.png?raw=true)\n\n　　首先我们需要一个div和两个i，两个i就是用来叠加生成对号图标用的。\n\nHTML:\n\n```bash\n<div class=\"bottom\"><!-- 这里换成top就是向上的对号-->\n\t<i class=\"arrow1\"></i>\n\t<i class=\"arrow2\"></i>\n</div>\n```\n\nCSS:\n\n```bash\n.bottom{\n\twidth: 20px;\n\theight: 20px;\n\tposition: relative;\n}\n.bottom .arrow1,.bottom .arrow2{\n\tdisplay: block;\n\tposition: absolute;\n\twidth: 0px;/*宽高设为0才能上下左右的border显示为三角形*/\n\theight: 0px;\n\tborder-left: 8px dashed transparent;/*transparent主要为了应用在网页中不盖住底色*/\n\tborder-right: 8px dashed transparent;\n}\n```\n\n　　然后下面关键的就来了，我们给第一个*<i>*只设置上边框的话在这种情况下是个三角形：![border1.png](https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/border1.png?raw=true)\n\n　　然后我们可以给第二个*<i>*再设置一个白色的三角形然后用绝对定位的偏移使它下移盖住灰色三角形的一部分：![border2.png](https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/border2.png?raw=true)\n\n```bash\n.bottom .arrow1{\n\tborder-top: 8px solid #999;\n\tborder-bottom: 8px dashed transparent;\n}\n.bottom .arrow2{\n    top: -2px;\n    border-top: 8px solid #fff;\n    border-bottom: 8px dashed transparent;\n} \n```\n\n　　然后我们一开始的那个向下的对号图标就出现啦，向上同理啦，下面就是向上向下放在一起的完整版CSS。\n\n```bash\n.bottom,.top{\n\twidth: 20px;\n\theight: 20px;\n\tposition: relative;\n}\n.bottom .arrow1,.bottom .arrow2,.top .arrow1,.top .arrow2{\n\tdisplay: block;\n\tposition: absolute;\n\twidth: 0px;\n\theight: 0px;\n\tborder-left: 8px dashed transparent;\n\tborder-right: 8px dashed transparent;\n}\n.bottom .arrow1{\n\tborder-top: 8px solid #999;\n\tborder-bottom: 8px dashed transparent;\n}\n.bottom .arrow2{\n\ttop: -2px;\n\tborder-top: 8px solid #fff;\n\tborder-bottom: 8px dashed transparent;\n} \n.top .arrow1{\n\tborder-top: 8px dashed transparent;\n\tborder-bottom: 8px solid #999;\t\t\t\n}\n.top .arrow2{\n\ttop: 2px;\n\tborder-top: 8px dashed transparent;\n\tborder-bottom: 8px solid #fff;\n}\n```"},{"title":"我的前端学习路线","url":"/2018/05/13/我的前端学习路线/","content":"\n## 我的前端学习路线\n\n　　我确认往前端发展是从2018年大三的寒假开始的，因为本科由于兴趣选择了*数字媒体专业*，自然而然就往前端这边靠了。要具体说一说的话原因也非常简单：JS非常简约易上手，浏览器就是调试器，还可以用代码构建形形色色的可视化页面，完美贴合我这种半计算机半艺术的专业。\n\n　　干任何事都有个起点，因为我的专业是半计算机专业，这就意味着操作系统原理、汇编、计算机网络这些CS的课程基本都没有，有了也是非常水的讲着玩玩，所以我的**起点水平**也就是对计算机语言的基础知识基本掌握，面向对象的原理（继承、封装、多态）了解过没怎么用过；数据结构会基本的栈、队列、排序、二叉树这些，而且还是只知道原理不会用（不过前端走到现在从没用过，基本pop(),push(),sort()什么的JS都给你封装好了）；前端相关知识HTML、CSS基本标签、属性会用，JS基本语法会用，基本DOM操作会用，jQuery了解过一点。\n\n　　其它的废话我就不多说了，这里着重记录一下我的学习历程，具体分为：我的书单、网上资源。\n\n## 我的前端书单（分先后顺序，书名后跟着难度和推荐度）\n\n　　我从小就不爱读书，爱看电影，因为感觉书非常无聊，不如电影动态的好看，但是到了现在要学技术了，就必须看书了，不知道大家有没有过这种体验：看动画片一集的时间看漫画能看十集，所以读书而且是读技术书对于**快速**增长学识非常关键。\n\n#### 1.《Head First HTML 与 CSS》  难度：0星  推荐度：3星\n\n　　都称作是最最基本的无脑入门书，也有一些HTML5的新内容，对于我这种零零碎碎学了些前端的人正适合当作第一本书看。\n\n#### 2.《JavaScript高级程序设计》  难度：2星  推荐度：5星\n\n　　结合了网上各类大神的推荐和自己的水平，没有去看犀牛书而是看了这本，总体感觉非常系统的带你巩固了一下JS，如果是小白建议就看完第13章事件，基本上就可以完成一些简单页面了，后面的内容什么时候用到了或对JS彻底入门了再去看即可（因为看到第13章JS才算摸到门把）。\n\n#### 3.《JavaScript语言精粹》  难度：3星  推荐度：5星\n\n　　当时看北妈的推荐读的这本，真的是如北妈所说：“读一页相当于《JavaScript高级程序设计》的十页”，看了这本书你基本就可以对原型、继承、闭包等有深刻的了解了，吃透这本小薄书我感觉**JS才算真正入门了**。\n\n#### 4.《图解CSS3：核心技术与开发实践》 难度：1星 推荐度：3星\n\n　　因为只是基本的CSS了解过，对CSS3并不是很了解，所以看了这本书，但因为是14年的有时候还需要看最新的CSS参考手册自己去挨个试试，总体还不错。\n\n#### 5.《CSS世界》  难度：3星  推荐度： 5星\n\n　　很多的CSS属性你知道是什么，但你搭配起来会出现一堆奇奇GAYGAY的问题，所以这本书就帮你了解CSS各属性间的关系和深层用法，我第一遍看因为没什么项目经验所以很多也只是看了，但是没用过所以没有概念，以后做的东西多了再回来看收获更多。\n\n#### 6.《JavaScript设计模式与开发实践》\n\n　　最近正在看，看完再评价。\n\n#### 7.《算法》\n\n　　最近正在看，感觉还是要了解一下算法，为了找工作也好，以后实际需要也好。\n\n\n## 我的其它书单\n\n　　学校的那些专业课的书就不说了，只提一下看过的觉得对前端这方面有点用的书单：\n\n#### 1.《3D数学基础：图形与游戏开发》  难度：2星  推荐度： 4星\n\n　　看这书会基本的C++和高中数学即可，起码能对计算机图形学的最基础有点认识了，能知道物体在3D空间是如何通过代码进行运动的了，CSS3的transform变形函数里的translate()、rotate()、scale()等与之相关很大。\n\n#### 2.《图解TCP/IP》  难度：2星  推荐度： 3星\n\n　　暂时为了以后与计算机网络打交道，先了解一下，但是因为很多名词从来没见过，看过了也就看过了，没有任何概念，所以现在还看不出来有什么用，只是对TCP/IP模型那些宏观上的东西有点感觉。\n　　\n"},{"title":"JS的面向对象","url":"/2018/05/13/JS的面向对象/","content":"\n　　最近刚开始看《JavaScrit设计模式与开发实践一书》，感觉着实不错，让我对JS的面向对象有了更多的认识，下面就来总结一下：\n\n　　首先要了解的一点是：JavaScript是**动态类型语言**，与Java，C++这些*静态类型语言*不同，它无需类型检测。\n\n## 多态\n\n　　多态就是将“做什么”和“谁去做以及怎样去做”分离开，也就是将“不变的事物”与“可能改变的事物”分离开来，然后把不变的部分隔离出来，把可变的部分*封装*起来，这样即可实现：同一操作作用于不同的对象，可以产生不同的解释和不同的执行结果。\n\n　　多态最根本的作用就是通过**把过程化的条件分支语句转化为对象的多态性**，从而消除这些条件分支语句。\n\n## 封装\n\n　　因为JavaScript没有一些语言中的public,private,protected等关键字，所以只能依赖**变量的作用域**来实现封装特性，而且只能模拟出public和private这两种封装性。\n\n　　一般通过函数来创建作用域（如闭包就是实现了公开方法访问私有变量），但最新的ES6提供了let关键字，和Symbol创建私有属性，现在我还没看，等着一定会去了解。\n\n## 继承\n\n　　关于原型链继承请参考博客“JS中new运算符详解”和高程6.3节（一定要先搞懂跟new有关的构造器模式，再去看原型链）\n\n　　JavaScript是一门基于原型的面向对象语言，它的对象系统就是使用**原型模式**来搭建的，所以它**绝大部分的**遵守原型编程范型的基本规则，即：\n\n1. 绝大部分的数据都是对象\n2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并*克隆*它\n3. 对象会记住它的原型\n4. 如果对象无法响应某个请求，它会把这个请求委托给它的*构造器的原型*\n\n#### 1. 绝大部分的数据都是对象\n\n　　JavaScript中的根对象是Object.prototype对象，它是一个空对象，所有的对象都是从Object.prototype对象克隆而来的，Object.prototype对象就是它们的原型。\n\n#### 2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它\n\n　　JavaScript的函数既可以作为普通函数被调用，也可以被new运算符作为构造器被调用，其中的new运算符实际上就是克隆了一个原型的过程。\n\n　　**关于new运算符的内部具体操作请见我博客中的“JS中new运算符详解”！**\n\n#### 3. 对象会记住它的原型\n\n　　JavaScript给对象提供了一个名为__proto__的隐藏属性（这是浏览器的实现，规范里应该是不可访问的[[prototype]]），该属性默认指向它的构造器的原型对象。\n\n　　所以*__proto__*就是对象跟“对象构造器的原型”联系起来的纽带。\n\n#### 4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型\n\n　　JavaScript的对象最初都是由Object.prototype对象克隆而来的，乍一看我们只能得到单一的继承自Object.prototype的对象，但**对象构造器的原型**并不仅限于Object.prototype上，而是可以动态指向其他对象。\n\n　　所以我们一般通过设置构造器的prototype来实现原型继承：\n\n```bash\nvar A=function(){};\nA.prototype={name:\"Daoma666\"};\nvar B=function(){};\nB.prototype=new A();\nvar b=new B();\nconsole.log(b.name);//Daoma666\n```\n\n　　在执行时，引擎做了什么事：\n\n1. 首先尝试遍历对象b中所有属性，但没有找到name这个属性\n2. 查找name属性的请求被委托给对象b的构造器原型，它被b.__proto__记录着并且指向B.prototype，即new A()创建出来的对象，即一个指向构造器A的prototype的对象。\n3. 然而在该对象中依然没有找到name属性，于是请求继续委托给这个对象构造器的原型A.prototype。\n4. 然后在这里找到了name属性，并返回它的值\n\n　　最后我们还要注意一点，如果在A.prototype也没找到name属性时，请求会被传递给A.prototype的构造器原型Object.prototype，因为根对象是个空对象，且原型是null，所以这次请求就到此为止，b.name返回undefined。\n\n*******************************************************************************\n\n　　现在我们就能理解ECMAScript5提供的克隆对象的Object.create方法了，它天然的实现了原型继承。\n\n```bash\nObject.create=function(obj){\n    var F=function(){};\n    F.prototype=obj;\n    return new F();\n}\n```\n\n　　即上面的代码可以这样实现：\n\n```bash\nvar A=function(){};\nA.prototype={name:\"Daoma666\"};\nvar b=Object.create(new A());\nconsole.log(b.name);//Daoma666\n```\n\n　　此外还有需要注意的几点：\n1. Object.create()来创建对象比通过构造器创建对象要慢\n2. 设置构造器的prototype实现原型继承时，除了根对象，任何对象都会有一个原型；但通过Object.create(null)可以创建出没有原型的对象。"},{"title":"JS中insertAdjacentHTML()方法","url":"/2018/05/12/JS中insertAdjacentHTML-方法/","content":"\n## JS中insertAdjacentHTML()方法\n\n　　一般我们在写JS时，想在一个DOM节点中插入HTML代码，这时有三种方法：\n\n#### 1.使用innerHTML\n\n　　缺点是会把原先该节点的代码全部覆盖掉。\n\n#### 2.使用insertBefore(),appendChild()方法\n\n　　缺点一是麻烦，需要先createElement()创建一个节点，再插入内容，最后再append到DOM树中。二是性能低下，具体见：[DOM appendHTML实现及insertAdjacentHTML](http://www.zhangxinxu.com/wordpress/?p=3210http://www.zhangxinxu.com/wordpress/?p=3210 \"小tip: DOM appendHTML实现及insertAdjacentHTML\")\n\n#### 3.使用insertAdjacentHTML()方法，更加灵活\n\n　　insertAdjacentHTML 方法：在指定的地方插入html标签语句\n\n　　原型：insertAdajcentHTML(swhere,stext)\n\n　　参数：\n\n　　swhere: 指定插入html标签语句的地方，\n\n　　stext:要插入的内容\n\n　　有四种值可用：\n\n1. beforeBegin: 插入到标签开始标记前\n\n2. afterBegin:插入到标签开始标记之后\n\n3. beforeEnd:插入到标签结束标记前\n\n4. afterEnd:插入到标签结束标记后\n"},{"title":"CSS实现居中的方法","url":"/2018/05/09/CSS实现居中的方法/","content":"\n## CSS实现居中的方法\n\n#### 1.使用width和margin实现水平居中\n\n　　width指定完宽度，就可以直接margin:0 auto;实现水平居中了\n\n#### 2.使用text-align实现水平居中\n\n　　使内联元素居中，所以要在想居中的内联元素的父元素中使用\n\n#### 3.使用top,left和margin实现水平垂直的居中（但不如下面第4种方法简单）\n\n　　方法就是top: 50%;left: 50%;然后margin: -所在盒子宽度/2 0 0 -所在盒子高度/2;(可用于弹窗弹出到页面正中间)\n\n#### 4.使用 margin:auto 实现块级元素水平垂直的居中\n\nHTML:\n\n```bash\n\t<div class=\"father\">\n\t    <div class=\"son\"></div>\n\t</div>\n```\n\nCSS:\n\n```bash\n\t.father {\n\t    width: 300px; height: 150px;\n\t    background-color: #f0f3f9;\n\t    position:relative;\n\t}\n\t.son { \n\t/*重要部分*/\n\t    position: absolute; \n\t    top: 0; right: 0; bottom: 0; left: 0;\n\t    margin: auto;\n\t/*重要部分*/\n\t    width: 200px; height: 100px;\n\t    background-color: #cd0000;\n\t    \n\t}\n```\n\n#### 5.使用line-height实现内联元素垂直居中\n\n　　如果该内联元素只有单行文本，那么连height都不用设置，直接设置一个line-height属性就可以。\n\n　　原理为**line-height=行距+font-size**，即行距的上下等分机制。具体见《CSS世界》一书中5.2.2节，其中还有多行文本或替换元素的垂直居中如何用line-height和vertical-align实现。"},{"title":"CSS属性值的百分比","url":"/2018/04/30/CSS属性值的百分比/","content":"\n## CSS属性值的百分比\n\n　　经常能见到CSS属性值出现百分比，之前一直也没有整理过，现在为了以后不迷糊，遂整理一下。\n\n### 百分比单位\n\n#### 1.乘以包含块的宽度：margin, padding, left, right, text-indent, width, max-width, min-width \n\n　　其中padding和margin的百分比值无论是水平方向还是**垂直方向**均是相对于**包含块宽度**计算的！\n\n#### 2.乘以包含块的高度：top, bottom, height, max-height, min-height \n\n　　关于**包含块（containing block）**的概念，不能简单地理解成是父元素。如果是静态定位和相对定位，包含块一般就是其父元素。但是对于绝对定位的元素，包含块应该是离它最近的 position 为 absolute、relative、或者 fixed 的祖先元素。对固定定位的元素，它的包含块是视口（viewport）。\n\n#### 3.乘以元素(border-box)的宽度：border-radius\n\n#### 4.乘以元素的字体大小：line-height \n\n#### 5.乘以元素的行高 ：vertical-align\n\n　　vertical-align只能应用于内联元素和display值为table-cell的元素！ \n\n#### 6.background-position中的百分比单位与CSS中其它百分比单位都不一样！具体见“前端配合设计师之background-position定位图片”这篇Blog\n\n#### 7.字体大小中的百分比 font-size 中的百分比值应该乘以元素所继承到的字体大小，也就是父元素的字体大小\n\n　　这里再提一下常用的字体单位em和ex。\n　　em——是一个相对于font-size的相对单位,因此line-height: 1.5em;就是和当前font-size相乘后的值。 ex——相当于字体中的“x”的高度。\n\n### 百分比的继承\n\n　　如果使用*数值*作为line-height的属性值，那么所有子元素继承的都是这个值；如果使用*百分比相对值*作为属性值，那么所有的子元素继承的是最终的计算值。\n\nCSS:\n\n```bash\n    body{\n\t\tfont-size: 14px;\n\t\tline-height: 1.5;/*子元素继承的line-height都是1.5*/\n\t\tline-height: 150%;/*子元素继承的line-height是14px*150%=21px*/\n\t\tline-height: 1.5em;/*子元素继承的line-height14px*1.5em=21px*/\n\t}\n\th3,p{\n    \tmargin: 0;\n\t}\n\th3{\n\t\tfont-size: 32px;\n\t}\n\tp{\n\t\tfont-size: 20px;\n\t}    \n```\n\nHTML:\n\n```bash\n    <h3>标题呵呵哈哈哈</h3>\n\t<p>内容啊啊啊啊啊</p>\n```\n　　所以一般推荐使用*数值*来操作line-height属性，比如1.5或15px，其中1.5默认就是1.5em，即相对于当前font-size的1.5倍。"},{"title":"前端配合设计师之background-position定位图片","url":"/2018/04/29/前端配合设计师之background-position定位图片/","content":"\n## 前端配合设计师之background-position定位图片\n\n　　我们经常遇到UI设计师把同一类部件的小图片都放在一张图片里的情况，小图片就是整图分割后的各个部分，把各个部分放在一张图片上，而不是是分别存储成单独的图片，其目的就是要**减少http请求次数，节省时间和带宽**。对于我们前端来说，就是要把对应的小图片应用到适当的位置，这里就需要background-position属性。\n\n　　这里需要搞清楚关于定位的一些东西：\n\n1.两个值前面一个是横向的定位，我们称为x轴方向定位。后面一个值是纵向的定位，我们称为y轴方向定位。**如果只有一个值，那默认的就是x轴方向，这时y轴方向就默认的是上下居中对齐，也就是center**。\n\n#### 2.背景图片定位的坐标原点就是对应容器元素的“左上角”，即元素padding的外边缘。（这个值可以通过background-origin进行定义）\n\n#### 3.x y值分别表示背景图片的左上角顶点相对于坐标原点（也就是容器的左顶点）的值。\n\n4.x y的值可以用px或百分比来表示。\n\n#### 5.当x y用百分比单位时，其表现与CSS中其他的百分比单位表现都不一样。\n\n　　比如一个图片：\n```bash\n\timg { position: absolute; left: 100%; }\n```\n　　一定是在容器外部，但像background-position:100% 100%就是定位在容器内的右下角。\n\n　　那background-position百分比表示的背景图片的左上角顶点对应的容器坐标位置该如何计算呢？\n\n　　具体公式为：\n\n##### positionX = (容器的宽度-图片的宽度) * percentX;\n##### positionY = (容器的高度-图片的高度) * percentY;\n\n　　然后这样算出来的positionX和positionY就是相对于上面第三条结论的x和y，这就不难懂为什么background-position:100% 100%就是定位在容器内的右下角了吧。\n\n6、x y也可以用“left、right、top、bottom、center”这五个关键字来表示，但注意：用“left、right、top、bottom、center”来表示的时候，“应用的是对齐规则，而不是坐标规则”。x为left是表示图片的左边和容器的左边对齐，为right的时候表示图片的右边和容器的右边对齐，y为top的时候表示图片的顶部和容器的顶部对齐，为bottom时表示图片的底部和容器的底部对齐，x y等于center的时候表示居中对齐。\n\n7、x y用百分比或者px表示的时候，其值可以为负数。我们应用坐标规则就很容易理解负数表示的意义，x为负数时候表示图片左顶点在容器左顶点的左侧，y为负数时表示图片的左顶点在容器的左定点的上方。也就是向左和向上超出容器的范围。\n\n##### 但是这里要注意，有的情况下用百分比的负数时并不会像你想的那样向左和向上超出容器的范围，因为第5条中介绍的百分比定位规则，就算你\n\n```bash\n\tbackground-position: -50% -50%;\n```\n\n　　图片会像background-position: 40px 10px;一样定位在容器内部，此时就可能是你**图片的长度大于容器的长度**导致的，因为此时：\n\n##### positionX = (容器的宽度-图片的宽度) * -50% 的结果是个正值\n##### positionY = (容器的高度-图片的高度) * -50% 的结果也是个正值\n\n　　所以就不难理解为什么会出现像background-position: 40px 10px;这样的效果了。\n\n　　详细请参考：[background百分比定位<position>值简介](http://www.zhangxinxu.com/wordpress/2015/03/background-object-position-value-percent/ \"CSS <position>值简介理解background百分比定位\")\n\n"},{"title":"JS中sort方法详解","url":"/2018/04/25/JS中sort方法详解/","content":"\n## JS中sort方法详解\n\n　　sort() 方法用于对数组的元素进行排序,并返回排序后的数组。默认排序顺序是根据字符串Unicode码点(**注意这里不是按ASCII编码排序**，这里按Unicode编码排序要和平常两个字符串的<,>,<=,>=,一位位字符按ASCII编码排序区分开。)\n\n#### 语法：arrayObject.sort(func)；参数func可选，规定排序顺序，必须是函数。\n\n　　注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照Unicode字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。\neg:\n\n```bash\n\tvar scores = [1, 10, 21, 2]; \n\tscores.sort(); \n\t// [1, 10, 2, 21]\n\t// 注意10在2之前,\n\t// 因为在 Unicode码点 指针顺序中\"10\"在\"2\"之前\n```\n\n　　如果想按照其他标准进行排序，就需要提供**比较函数**，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有**两个参数 a 和 b**，其返回值如下：\n\n#### 如果返回一个负数，则第一个参数应该排列在前面，即在排序后的数组中 a 应该出现在 b 之前。\n#### 如果 返回 0，表示a 等于 b，则a 和 b 的相对位置不变。（注意这里和排序算法的稳定性有关）\n#### 如果返回一个正数，则第二个参数应该排列在前面。\n\n　　所以，比较函数格式如下：\n\n```bash\n\tfunction compare(a, b) {\n\t\tif (a < b ) {        // 按某种排序标准进行比较, a 小于 b\n\t\t\treturn -1;\n\t\t}\n\t\tif (a > b ) {\n\t    \treturn 1;\n\t\t}\n\t\t// a must be equal to b\n\t\treturn 0;\n\t}\n```\n\n　　要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列:\n\n```bash\n\tfunction compareNumbers(a, b) {\n\t\treturn a - b;\n\t}\n```\n\n　　你可能还有疑问，就是为什么比较函数要放两个参数？我们可以拿V8引擎(Chrome浏览器的JS引擎)来理解。\n\n　　V8引擎使用C++开发，如果学过一点点数据结构课的话，肯定接触过排序这一块儿，什么快速排序、插入排序、冒泡排序的，然后**大部分排序算法，步骤分解之后，最细节的操作都是两个数的相互比较**，Chrome浏览器用的V8引擎就使用了快速排序。下面就贴一段当年学数据结构的时候快排的代码，V8的源码肯定不是这么简单，肯定是一种复杂的经过了各种优化（比如改善了稳定性，内存等）但基本的快排就是这样：左边右边一块儿往中间排，排出一个个有序的子段，然后再一个个子段中递归的排。\n\n#### 排序稳定性是指排序后数组中的相等值的相对位置没有改变，而不稳定性排序则会改变相等值的相对位置。\n\nC++快速排序算法(这里是从小到大的正序算法):\n```bash\n\tvoid quick_sort(int left,int right){\n        if(left>right){\n            return; \n        } \n        int pivot=data[left],low=left,high=right;\n        while(low<high){\n            while(low<high && data[high]>=pivot){\n                high--;\n            }\n            data[low]=data[high];\n            while(low<high && data[low]<=pivot){\n                low++;\n            }\n            data[high]=data[low];\n        }\n        data[low]=pivot;\n        quick_sort(left,low-1);\n        quick_sort(low+1,right);\n    }\n```\n\n　　所以这样就清楚了，我们只要设置好了比较函数func(a,b)规定了每两个数排序的正逆序，就可以对整个数组进行快速排序，但要注意的是，**因为快速排序是不稳定排序，所以sort方法也是不稳定的**。\n\n　　我们还可以令**对象数组**排序，这里是加强版排序，首先按last排序，然后按照first排序。\n\nJS:\n```bash\n\tvar s=[\n\t\t{first:\"Tom\",last:\"cruse\"},\n\t\t{first:\"Jack\",last:\"awddwa\"},\n\t\t{first:\"Aommy\",last:\"rththr\"},\n\t\t{first:\"Fuck\",last:\"ererg\"},\n\t\t{first:\"Shit\",last:\"nbnb\"},\n\t\t{first:\"Jessy\",last:\"awddwa\"}\n\t];\n\tvar by=function(name,minor){\n\t\treturn function(o,p){\n\t\t\tvar a,b;\n\t\t\tif(typeof o==='object' && typeof p==='object' && o && p){\n\t\t\t\ta=o[name];\n\t\t\t\tb=p[name];\n\t\t\t\tif(a===b){\n\t\t\t\t\t//这里的minor(o,p)实际上是by('first')(o,p)\n\t\t\t\t\treturn typeof minor ===  'function' ? minor(o,p) : 0;\n\t\t\t\t}\n\t\t\t\tif(typeof a=== typeof b){\n\t\t\t\t\treturn a<b?-1:1;\n\t\t\t\t}\n\t\t\t\treturn typeof a < typeof b ? -1 : 1;\n\t\t\t}else{\n\t\t\t\tthrow{\n\t\t\t\t\tname: 'Error',\n\t\t\t\t\tmessage: 'Expected an object when sorting by '+name\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t};\n\t//因为by函数使用了闭包，这里的带两个参数的比较函数实际上是by(name)函数,即func(o,p)=by(name)(o,p)\n\t//一个函数当参数的时候只写函数名即可,所以写成sort(by('last'))就行\n\ts.sort(by(\"last\",by(\"first\")));\n\tfor(var i in s){\n\t\tconsole.log(s[i].first+\" \"+s[i].last);\n\t}\n```\n\n　　更多关于sort()的内容，请见[MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort \"Array.prototype.sort()\")"},{"title":"label标签和任意高度元素展开收起的骚操作","url":"/2018/04/24/label标签和任意高度元素展开收起的骚操作/","content":"\n## label标签和任意高度元素展开收起的骚操作\n\n　　*<label>* 标签为 input 元素定义标注（标记）。\n\n　　*<label>* 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。\n\n　　*<label>* 标签的 for 属性应当与相关元素的 id 属性相同。\n\nHTML:\n\n```bash\n\t<input id=\"check\" type=\"checkbox\">\n\t<p>:checked 选择器匹配每个已被选中的 input 元素（只用于单选按钮和复选框）。</p>\n\t<div class=\"element\">\n\t  <p>若指定了label标签的for属性和input标签的id属性相同的话，则可以实现两者的关联，在该例子里就是label也可以点击触发:checked</p>\n\t</div>\n\t<label for=\"check\" class=\"check-in\">更多↓</label>\n\t<label for=\"check\" class=\"check-out\">收起↑</label>\n```\n\nCSS:\n\n```bash\n\t/*把复选框隐藏掉*/\n\tinput[type=\"checkbox\"]{\n\t\tposition: absolute;\n\t\tclip: rect(0,0,0,0);/*clip属性裁剪出一个绝对定位元素的可见尺寸*/\n\t}\n\t/*实现任意高度元素展开收起 的骚操作*/\n\t.element {\n\t  max-height: 0;\n\t  overflow: hidden;\n\t  transition: max-height 1.25s;\n\t}\n\t:checked ~ .element {\n\t  max-height: 666px; /*一个足够大的最大高度值*/\n\t}\n\t/*为了更美观，实现两个label的显示交替*/\n\t:checked ~ .check-in{\n\t\tdisplay: none;\n\t}\n\t.check-out{\n\t\tdisplay: none;\n\t}\n\t:checked ~ .check-out{\n\t\tdisplay: block;\n\t}\n```"},{"title":"CSS特殊的按钮闪烁效果","url":"/2018/04/21/CSS特殊的按钮闪烁效果/","content":"\n## CSS特殊的按钮闪烁效果\n\n　　本来想练习线性渐变做按钮的，但无意中发现了一个闪烁的效果，具体见代码\n\nHTML:\n\n```bash\n\t<div>\n\t\t<a href=\"javascript:void(0)\" class=\"button cyan\">Daoma666</a>\n\t</div>\n```\n\nCSS：\n\n```bash\n\tbody>div{\n\t\t\ttext-align: center;\n\t\t\tdisplay: block;\n\t\t\twidth: 800px;\n\t\t\tmargin: 50px auto;\n\t\t}\n\t.button\n\t{\n\t\tfont-family: Arial,helvetica,sans-serif;\n\t\tfont-size: 13px;\n\t\tcolor: #000;\n\t\ttext-decoration: none;\n\t\tdisplay: inline-block;\n\t\ttext-align: center;\n\t\tpadding: 7px 20px 9px;\n\t\tmargin: .5em .5em .5em 0;/*根据相应字体大小font-size来定，在这个类里1em=13px*/\n\t\tcursor: pointer;\n\t\ttext-shadow: 0 1px 1px rgba(0,0,0,0.4);\n\t\ttext-transform: capitalize;\n\t\ttransition: 0.1s linear;\n\t}\n\t.cyan {\n\t\tbackground: rgb(130,207,241);\n\t\tbackground: -webkit-linear-gradient(to bottom,  rgba(130,207,241,1) 0%,rgba(56,174,234,1) 100%);\n\t\tbackground: linear-gradient(to bottom,  rgba(130,207,241,1) 0%,rgba(56,174,234,1) 100%);\n\t\tborder: 1px solid #3cafcf;\n\t}  \n\t.cyan:hover {\n\t\tbackground: rgb(153,216,244);\n\t\t/*background: -webkit-linear-gradient(to bottom,  rgba(153,216,244,1) 0%,rgba(79,183,236,1) 100%);\n\t\tbackground: linear-gradient(to bottom,  rgba(153,216,244,1) 0%,rgba(79,183,236,1) 100%);*/\n\t\t//原先这里的background打错了，导致渐变无效，然后就出现了闪烁效果，感觉比较抓人眼球。\n\t}\n```"},{"title":"JS中的apply()使用详解","url":"/2018/04/18/JS中的apply-使用详解/","content":"\n## JS中的apply()使用详解\n\n### apply(要绑定给this的值,参数数组)方法用来调用函数及扩展作用域\n\n#### eg:Function.apply(obj,args)方法能接收两个参数，其中\n#### obj:这个对象将代替Function函数里的this对象\n#### args:这个是数组，它将作为参数传给Function(args);　　 \n　　之前我一直从语义上蒙圈，还以为是Function调用啥啥啥，结果不是。。。而是**obj.Function(args)**，即obj调用Function函数并传入参数数组args。\n\n### call和apply的意思一样,只不过是参数要一个一个列出来.  \n  \n#### eg:Function.call(obj,[param1[,param2[,…[,paramN]]]])  \n#### obj：这个对象将代替Function函数里的this对象  \n#### params：这个是一个参数列表\n\n具体见一个例子：\n```bash\n\tfunction Person(name,age){\n\t\tthis.name=name;\n\t\tthis.age=age;\n\t}\n\tfunction Student(name,age,grade){\n\t\tPerson.apply(this,arguments);\n\t\tthis.grade=grade;\n\t}\n\tvar student=new Student(\"MaYun\",21,\"大三\");\n\talert(student.name+\" \"+student.age+\" \"+student.grade);\n```\n\n### 代码解析 \n\n　　这里Student里虽然没有给name和age属性赋值的语句，但调用了Person构造函数。所以var student=new Student(\"MaYun\",21,\"大三\");new出来的Student构造函数里：\n\n　　因为遵循**构造器调用模式**(new)中this被绑定到**新对象**(即student)，所以\n\n　　Person.apply(this,arguments);就相当于Person.apply(student,arguments);就相当于student.Person(name,age,grade);\n\n　　此时Person中的this.name=name;this.age=age;中的this因为属于**方法调用模式**被绑定到**调用该方法的对象**上，所以就相当于student.name=name;student.age=age;\n\n#### 巧妙使用apply(this,args)的args参数\n\n　　如果见到apply(null,args);这种写法，这样其实不算调用什么东东了，只是可以将一个args数组默认的转换为一个参数列表(即[param1,param2,param3] 转换为 param1,param2,param3)来传惨。\n\n### 比如下面的例子想得到数组中最大的一项 。\n\n```bash\n\tvar array=[50,60,70,90,100];\n\tvar max=Math.max(array);\n\talert(max); //NaN\n\tmax=Math.max.apply(null,array);\n\talert(max); //100\t\n```\n　　因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组  \n  \n　　但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的这个特点可以得到一个数组中最大的一项  。\n\n### 同样的push方法没有提供push一个数组中的每一项\n\n```bash\n\tvar a1=[\"a\",\"b\",\"c\"];\n\tvar a2=[\"a\",\"b\",\"c\"];\n\tvar b=[\"x\",\"y\",\"z\"];\n\ta1.push(b);\n\talert(a1.length);//4,即把b数组作为单个元素push了,a1=[\"a\",\"b\",\"c\",[\"x\",\"y\",\"z\"]]\n\tArray.prototype.push.apply(a2,b);\n\talert(a2.length);//6,即把b数组中的每一项都push了,a2=[\"a\",\"b\",\"c\",\"x\",\"y\",\"z\"]\n```\n\n　　因为push方法会修改原数组，所以这里用了a1和a2两个数组来作例子。"},{"title":"闭包与模仿块作用域","url":"/2018/04/18/闭包与模仿块作用域/","content":"\n## 闭包与模仿块作用域\n\n　　最近看《JavaScript语言精粹》真是一页的含量顶其它书的十页啊，受益匪浅，在这里整理一下闭包的一些东东吧。\n\n　　首先我也忘了之前有没有整理过关于原型的一些用法，先给出一段代码：\n\n```bash\nFunction.prototype.method=function(name,func){\n\tthis.prototype[name]=func;\n\treturn this;\n}\n```\n\n　　具体要是忘了的话，去看原型那节，作用是给Function对象的原型添加了一个method方法，用于往该原型里新增方法，这样继承自Function对象的子对象们都会动态更新它们的方法。\n\n　　然后就是我们主要整理的东西了：\n```bash\nString.method(\"deentityify\",function(){\n\tvar entity={\n\t\tquot: '\"',\n\t\tlt: '<',\n\t\tgt: '>'\n\t};\n\treturn function(){\n\t\treturn this.replace(/&([^&;]+);$/g,function(a,b){\n\t\t\tvar r=entity[b];\n\t\t\treturn typeof r === \"string\" ? r : a;\n\t\t});\n\t};\n}());\ndocument.writeln(\"&lt;body&gt;&quot;HAHAHA&quot;&lt;body&gt;\".deentityify())//<body>\"HAHAHA\"<body>\n```\n\n　　这段代码的主要功能是：给String对象添加一个deentityify方法。它的任务是寻找字符串中的HTML字符实体并把它们替换为对应的字符。\n　　这里有四个需要注意的点：\n\n#### 1.模仿块作用域\n\n```bash\n(function(){\n\tvar s=\"test\";\n}())\n```\n\n　　JS中函数可以用来构造函数作用域，在函数里面可以看到外面的变量，但在函数外面则无法看到函数里面的变量，这是因为函数中搜索变量的过程是由内到外沿着作用域链逐层搜索，一直搜索到全局对象为止。\n\n　　因为JS将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。所以最外层的把整个函数包起来的圆括号表示：将函数声明转换成函数表达式。\n\n　　这段代码实际上定义并立即**调用**了一个匿名函数，其中最后的*()*圆括号是**调用运算符**。\n\n　　要注意()调用运算符立刻调用了我们刚刚构造出来的函数，这个调用创建并返回的函数才是deentityify()方法，\n　　即:\n\n```bash\ndeentityify=function(){\n\treturn this.replace(...);\n}\n```\n\n　　在匿名函数中定义的任何变量，都会在执行结束时被销毁，这样就可以减少闭包占用的内存问题。\n\n#### 2.闭包\n\n　　一个**函数**可以访问它被创建时所处的上下文环境，这称为**闭包**。例子中第一个return的函数就是一个闭包：\n\n```bash\nreturn function(){\n\treturn this.replace(/&([^&;]+);$/g,function(a,b){\n\t\tvar r=entity[b];\n\t\treturn typeof r === \"string\" ? r : a;\n\t});\n};\t\n```\n\n　　上面的函数可以访问到deentityify方法上下文环境定义的entity对象，所以这个函数就可以被称作**闭包**。\n\n　　在这里再讨论一下变量的生存周期：\n\n　　全局变量的生存周期是永久，除非我们主动销毁(=null)这个全局变量。\n\n　　在函数内用var关键字声明的局部变量，当退出函数时，会随着函数调用的结束而被销毁。\n\n　　但是如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。像上面的闭包，它可以访问到deentityify()被调用时产生的环境，所以局部变量entity因为能被外界访问，所以就不会被销毁，除非我们手动销毁。\n\n　　所以说闭包的作用有：\n\n1. 可以延长局部变量的生存周期。\n\n2. 可以封装变量\n\n#### 3.模块模式\n\n　　模块是一个提供接口却隐藏状态与实现的函数或对象。它利用函数作用域与闭包来创建被绑定对象与私有成员的关联，模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可访问到的地方。\n\n#### 4.String.prototype.replace()进阶用法\n\n　　我这也是第一次知道它的第二个参数可以是一个函数，且非常有用，具体见：[MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace \"replace详细用法\")\n\n##### 指定一个函数作为参数\n\n　　你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后， 该函数就会执行。 函数的**返回值**作为替换字符串。 (注意:上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被**多次调用**， 每次匹配都会被调用。\n\n　　下面是该函数的参数：\n\n　　变量名\t　　代表的值\n　　match\t　　匹配的子串。（对应于上述的$&。）\n　　p1,p2, ...　假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）\n　　offset　　匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）\n　　string　　被匹配的原字符串。\n\n　　代码中的正则表达式/&([^&;]+);$/g代表：从整个字符串中，从全局匹配出所有的以&开头，中间有1个或多个非&;的任意字符，然后以;结尾的字符串。\n"},{"title":"函数柯里化","url":"/2018/04/18/函数柯里化/","content":"\n## 函数柯里化\n\n　　函数柯里化Currying指的是**把函数与传递给它的参数相结合，产生出一个新的函数**。\n\n　　原理：Currying通过创建一个保存着原始函数(对象)和要被套用的参数的闭包来工作。它返回另一个函数，当函数被调用时，会返回调用原始函数(对象)的结果，并传递调用curry时的参数“加上”当前调用的参数。\"加上\"是通过Array.concat()方法连接两个参数数组。\n\n　　上面的原理balabala一大顿，我都没看懂，所以为了更容易懂，还是得看代码：\n\n```bash\n\tFunction.prototype.method=function(name,func){\n\t\tthis.prototype[name]=func;\n\t\treturn this;\n\t}\n\tFunction.method(\"curry\",function(){\n\t\tvar slice=Array.prototype.slice,\n\t\t\targs=slice.apply(arguments),\n\t\t\tthat=this;\n\t\treturn function(){\n\t\t\treturn that.apply(null,args.concat(slice.apply(arguments)));\n\t\t};\t\n\t});\n```\n\n　　然后接下来我们就可以看到它运用的结果\n\n```bash\n\tfunction add(num1,num2){\n\t\treturn num1+num2;\n\t}\n\tvar add1=add.curry(1);\n\talert(add1(6)); //7\n```\n\n　　这里的method方法中，要注意四点：\n\n#### 1.arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。\n　　第一个arguments是curry()函数的参数,return里的arguments是return function()的参数，这样可能听不懂，其实在例子中就是add1()函数里的参数。\n\n#### 2.正因为第一点，所以要想在最后使用args.concat，必须将arguments对象转换为一个真的数组，这里用Array.prototype.slice()方法，它可以将一个类数组（Array-like）对象/集合转换成一个新数组。\n　　具体见：[MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice \"Array.prototype.slice()\")\n\n#### 3.第一个that=this;中的this在这里属于方法调用模式，绑定到调用该方法的对象上，即一个Function对象。\n　　所以add.curry(1)，this被绑定到add函数对象上\n\n#### 4.调用函数的方法apply(要绑定给this的值,参数数组)\n　　具体可见博客中“JS中的apply()使用详解一节”。\n\n　　最后我们再结合代码来看curry方法的具体作用：\n\n```bash\n\tFunction.method(\"curry\",function(){\n\t\t//curry方法通过创建一个保存着原始函数和要被套用的参数的闭包来工作。\n\t\tvar slice=Array.prototype.slice,\n\t\t\targs=slice.apply(arguments),  //要被套用的参数\n\t\t\tthat=this;  //that=this保存着原始函数对象\n\t\treturn function(){ //闭包  && 它返回另一个函数\n\t\t\treturn that.apply(null,args.concat(slice.apply(arguments)));\n\t\t\t//当函数被调用时，会返回调用原始函数的结果，并传递调用curry时的参数“加上”当前调用的参数\n\t\t};\n\t});\n```\n\n　　所以当执行add1(6)时，相当于执行了add.apply(null,args.concat(slice.apply(arguments))),即执行了add(curry中的参数1,自己的参数6),所以放回1+6=7.\n\n#####　　这样就好理解柯里化的概念了：把函数与传递给它的参数相结合，产生出一个新的函数。\n\n　　add函数使用curry(参数)方法=>add.curry(参数);把函数与传递给它的参数 相结合，\n　　产生一个新的函数add1=>var add1=add.curry(1);\n　　用处就是可以用add1函数给原函数add传参，现阶段光是理论懂了，但是不懂具体用在哪，后期一定会再补充。"},{"title":"秒懂汉诺塔原理函数递归","url":"/2018/04/15/秒懂汉诺塔原理函数递归/","content":"\n## 秒懂汉诺塔原理函数递归\n\n　　想当年大一刚学C语言递归那一块儿的时候，遇到了“汉诺塔”问题，我的老天，那段时期想哭好吗，深刻的打击了我的编程热情，本身我就自觉智商不高，于是一直就没搞懂过这个问题，指导最近看了《JavaScript语言精粹》，才发现递归并没有那么难。。。我之前对于递归的了解只限于一个函数调用它自身，所以一直懵懵懂懂，现在需要重新认识一下它：\n\n### 递归函数是干啥用的\n\n　　递归函数就是会直接或间接调用自身的一种函数。它把一个问题分解为一组相似的子问题，每一个都用一个*寻常解*去解决。也就是说，递归用一般的方式去解决**每个**子问题。\n\n### 汉诺塔是什么\n\n　　因为这是篇笔记，相信每个想了解汉诺塔原理的人都懂它是什么，怎么玩，但是就算你会玩，你不会写代码(大佬除外)。。。我就是从这个时候觉得自己智商比别人低的，不过这是我刚接触编程的时候。到现在接触了两三年的编程，我深感周围大佬没多少(可能因为我双非一本非计算机专业的缘故)，当初那些一看就会的人大部分接触的早O__O，人家初中高中奥数什么的早就接触啦，对于我们这种普通学生来说(我相信你要是985,211不会来看我的博客的)，大部分像我这样的人(为了不让大佬们黑我)都是学以致用的，参考别人的摸出门路了才会用，所以接下来我写的，应该都能懂。\n\n### 汉诺塔递归代码\n\n　　有时搜一篇资料，先看到源码，哇看不懂，再看原理，哇更不懂；也可能先看到原理，没代码我怎么会看懂，再看源码，哇原理我都看不懂看代码怎么会懂。。。所以这就陷入了死循环，至于能不能看懂，就看个人的喜好和悟性了，我的习惯是先看源码。\n```bash\n\t<pre>\n\t\t<script type=\"text/javascript\">\n\t\t\tvar hanoi=function(n,src,aux,dst){\n\t\t\t\tif(disc>0){\n\t\t\t\t\t//第一步\n\t\t\t\t\thanoi(n-1,src,dst,aux);\n\t\t\t\t\t//第二步\n\t\t\t\t\tdocument.writeln(\"Move disc \"+n+\" from \"+src+\" to \"+dst);\n\t\t\t\t\t//第三步\n\t\t\t\t\thanoi(n-1,aux,src,dst);\n\t\t\t\t}\n\t\t\t};\n\t\t\thanoi(3,\"Src\",\"Aux\",\"Dst\");\n\t\t\thanoi(4,\"Src\",\"Aux\",\"Dst\");\n\t\t</script>\n\t</pre>\n```\n\n### 汉诺塔递归原理\n\n　　你可以发现它看上去非常的简单，一共就三步，毕竟hanoi函数就是把一堆圆盘从一根柱子移到另一根柱子，必要时使用辅助的柱子。函数的参数解释如下：\n1.n是一开始由小到大排在src柱子上的圆盘数量\n2.src代表起始柱子\n3.aux(auxiliary)代表辅助柱子\n4.dst(destination)代表目标柱子\n\n　　hanoi函数把问题分解为了三个子问题，\n\n#### 第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。\n#### 第二步：移动下面最大的圆盘到目标柱子上。\n#### 第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。\n\n　　然后通过递归地调用自身(只是参数不同)去处理一对圆盘的移动，从而解决那些子问题。\n\n### 对递归原理的理解\n\n　　hanoi(3,\"Src\",\"Aux\",\"Dst\");代表把3个圆盘**从**Src柱子**借助**Aux柱子移动**到**Dst柱子。每一个大问题里包含三个子问题:如果起始柱子上有盘子，先把disc-1个较小的圆盘都放到辅助柱子上，然后把较大的放到目标柱子上，最后在把那disc-1个较小的圆盘放到目标柱子上。\n\n　　相信读到这里的人都搞懂了**怎么把这个大问题分解为3个子问题**，并且发现如果按着原理思路来写，即可写出代码。但是过了不一会儿你就会产生疑问，因为你大问题上懂了，但不明白为啥每个子问题都可以这么用呢？每个子问题内为什么也起作用呢？\n\n　　所以说之前的我和现在的我差在了哪里，不是智商，而是思考的方式不对！！你是不是正在苦苦思考这段代码的每一步，然后把一步步的执行过程都写出来了，想搞懂递归呢？结果就是蛋疼！你不但啥也没搞懂，还白白浪费了这段推代码的时间！正确的打开方式是这样的——**递归当然只能以递归的思路理解，把它展开纯属自讨苦吃**。\n\n　　递归思路，说白了是如下三步：\n\n#### 1.对于问题N，如果N-1已经解决了，那么N是否很容易解决。\n\n　　举例来说，如果要把一个N层汉诺塔从src搬到dst，那么：\n\n　　如果前N-1层可以找别人搞定，咱只管搬第N层，会不会变得非常容易？\n\n　　你看，这一下就简单了：这时当它只有两层就好了，先把前N-1层看作一个整体，把它搬到aux；然后把最下面的第N层搬到dst；然后再把前N-1层从aux搬到dst。\n\n　　类似的，假如接到“搬前N-1层”这个任务的是我们，怎么搬呢？\n\n　　简单，像前东家一样，把前N-2层外包出去，我们只搬第N-1层——其实和前面讨论过的“外包N-1层，只搬第N层”完全一样嘛。\n\n　　依此类推，一层层“外包”下去——我不管你们有多伤脑筋，反正只要你们把我外包给你的活干了，我就能干了我的活！\n\n　　这一步就是**递推*。\n\n###### 注意这里的搬法：搬第N层，就需要把前N-1层搬两次(起始到辅助，辅助再到目标)，另外再把第N层搬一次(起始到目标)；\n###### 搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。\n###### an=2*a(n-1)+1\n###### a(n-1)=2*a(n-2)+1\n###### ......\n###### a2=2*a1+1\n###### a1=1\n###### 很容易知道，an需要搬2^n-1次。\n\n#### 2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。\n\n　　第一层怎么搬？\n\n　　太简单了，让搬哪搬哪。\n\n　　换句话说，到此，**递推**就到了极限，简单粗暴直接做就可以了。\n\n#### 3.既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。\n\n　　这一步就是**回归**。\n\n　　如上三步加起来，就是**递归**。\n\n　　推而广之，任何问题，不管规模为N时有多复杂，只要把N-1那块“外包”给别人做之后，我们在这个基础上可以轻易完成N，那么它很可能就适合用“递归”解决。\n\n　　那么，怎么最终确定它能不能用“递归”做呢？\n\n##### 看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。 \n\n　　容易看出，**“递归”其实和“数学归纳法”的思路非常像**：证明N=1时成立；证明若N=n-1成立，则N=n时也成立；如上两步得证，则命题在n>1时一定成立（n为自然数）。你看，我们没必要从1开始逐一验证每个自然数，只要证明了“基础条件”、再证明了“递推条件”，大自然的规律会帮我们搞定一切。\n\n　　换句话说，只要我们：\n\n##### 1、写程序告诉电脑“如何分解一个问题”(即把汉诺塔问题分解为如上三步)\n\n##### 2、写程序告诉电脑“当该问题分解到最简时如何处理”(即第二步中的直接把它从src移到dst)\n\n　　那么，“具体如何递推、如何回归”这个简单问题就不要再操心了，电脑自己能搞定。\n\n　　——写出问题分解方法、写出分解到最简后如何解决，这是我们的任务；把问题搞定，是电脑的任务。这就是递归的魅力。\n\n　　正是由于这种“我提供思路你搞定细节”的特点，“一切皆递归”的函数系语言才被称为“声明式编程”（而不是必须一步一步指导电脑如何做的“命令式编程”）。\n\n[更多的关于汉诺塔递归问题可以参考](https://www.zhihu.com/question/24385418,\"如何理解汉诺塔的递归？\")\n\n　　\n\n\n　　\n\n\n\n"},{"title":"JS中的取整","url":"/2018/04/15/JS中的取整/","content":"\n## JS中的取整\n\n### Math.ceil()——>天花板，向上取整\n\n　　-9 ——> 0 ——> 9，沿着这个方向无论正负都向上取整。\n\n### Math.floor()——>地板，向下取整\n\n　　-9 <—— 0 <—— 9，沿着这个方向无论正负都向下取整。\n\n### 如何像其它语言那样向零取整\n\n　　先给Function.prototype添加method()方法使得该方法对所有函数可用：\n```bash\n\tFunction.prototype.method=function(name,func){\n\t\tthis.prototype[name]=func;//方法调用模式，this绑定到该对象，即Function，再更新Function对象新增新的name属性\n\t\treturn this;\n\t}\n```\n　　然后给Number.prototype添加向零取整方法interger()，具体如下：\n```bash\n\tNumber.method(\"integer\",function(){\n\t\treturn Math[this<0 ? \"ceil\" : \"floor\"](this);\n\t});\n\talert((-5.9).integer());\n```\n\n### Math.round()——>把一个数字四舍五入为最接近的整数\n\n　　正数很正常:5.4——>5 , 5.5——>6\n　　负数有点小注意:-5.4——>-5, -5.5——>-5 , -5.51——>-6\n"},{"title":"阻止事件的一些操作","url":"/2018/04/14/阻止事件的一些操作/","content":"\n## 阻止事件冒泡或捕获\n\n　　有时会遇到如下情况，本元素和父层元素都有事件，但我们只想要本元素事件激活，即要阻止事件冒泡\nHTML:\n```bash\n\t<!DOCTYPE html>\n\t<html>\n\t\t<head>\n\t\t\t<meta charset=\"UTF-8\">\n\t\t\t<title></title>\n\t\t\t\n\t\t</head>\n\t\t<body>\n\t\t\t<button onclick=\"clickBtn(event)\">Push Me</button>\n\t\t</body>\n\t\t<script type=\"text/javascript\">\n\t\t\tdocument.onclick=function(){\n\t\t\t\talert(\"body\");\n\t\t\t}\n\t\t\tfunction clickBtn(event){\n\t\t\t\tevent= event ? event : window.event;\n\t\t\t\talert(\"button\");\n\t\t\t\tevent.stopPropagation();\n\t\t\t\t//event.cancelBubble=true;\n\t\t\t}\n\t\t</script>\n\t</html>\n```\n### cancelBubble\n\n　　cancelBubble原本是IE独有，经测试发现它也可以在Chrome和Firefox中阻止冒泡，那是因为人家Chrome，Firefox 考虑周到，提供了这么一种可选的方式。 但是，cancelBubble已经不在标准中了，相信迟早它们会移除这一特性的。\n\n### DOM的stopPropagation()方法\n\n　　这是DOM层次的方法，用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。两者的区别为：\n　　IE不支持事件捕获，因而只能取消事件冒泡，但stopPropagation()可以同时取消事件捕获和冒泡。\n\n## 阻止事件默认行为\n\n　　下面是一个阻止右键菜单栏事件的小程序\n```bash\n\t<script type=\"text/javascript\">\n\t\tdocument.oncontextmenu=function(event){\n\t\t\tevent= event ? event : window.event;\n\t\t\t/*下面这三种方法都可以*/\n\t\t\t//event.preventDefault();\n\t\t\t//event.returnValue=false;\n\t\t\treturn false;\n\t\t}\n\t</script>\n```\n\n### returnValue=false\n　　也是原本IE的方法，它也可以在它也可以在Chrome和Firefox中阻止事件默认行为。\n\n### DOM的preventDefault()方法\n　　简单直观，直接阻止默认的行为，可以用在多个情况。\n"},{"title":"变量提升","url":"/2018/04/14/变量提升/","content":"\n## 变量提升\n\n　　最近发现了一个小问题：\n```bash\n\tvar x=\"global value\";\n\tfunction getValue(){\n\t\talert(x);//undefined\n\t\tvar x=\"local value\";\n\t\talert(x);//local value\n\t}\n\tgetValue();\n```\n\n　　我们可以发现第一个alert(x)结果为undefined，这就跟JS的**变量提升**有关系了。\n　　var关键字声明变量，无论声明在何处，都会被视为声明在函数的*最顶部*(不在函数内即在全局作用域的最顶部)，这就是函数的**变量提升**。所以上面的代码实际上是：\n\n```bash\n\tvar x=\"global value\";\n\tfunction getValue(){\n\t\tvar x; //普通的变量初始化就是undefined，所以就好理解了\n\t\talert(x);\n\t\tvar x=\"local value\";\n\t\talert(x);\n\t}\n\tgetValue();\n```\n　　\n　　下面我们就来整理一下变量提升：\n#### 1.我是变量声明，我会被提升在作用域顶端！\n\n```bash\n\tvar a;\n```\n\n#### 2.我是变量定义，我的声明部分会被提升，赋值部分不会被提升！\n\n```bash\n\tvar b=\"test\";\n```\n\n#### 3.我是函数定义，或者叫我函数表达式。其实我就是变量定义，只不过恰好被赋值的类型是函数，所以也只提升变量名(即提升声明部分)，不提升函数值！\n\n```bash\n\tvar c=function(){\n\t\tconsole.log(\"test\");\n\t}\n```\n\n#### 4.我是函数声明，所以我全部被提升了，包括函数名和函数体。另外，我的优先级比变量声明要高，名字和我相同的变量声明会被忽略！\n\n```bash\n\tfunction d(){\n\t\tconsole.log(\"test\");\n\t}\n```\n\n　　最后再补充一点，因为JS虽然有函数作用域，但没有块作用域，即函数中的参数和变量在函数外部是不可见的，而在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见。"},{"title":"text-indent: -9999px;作用","url":"/2018/04/11/text-indent-9999px-作用/","content":"\n## text-indent: -9999px;作用\n\n　　最近在做星级评分系统作业时遇到了这个写法。\nHTML:\n```bash\n\t<span>点击星星就能打分</span>\n\t<ul>\n\t\t<li class=\"\"><a href=\"javascript:;\">1</a></li>\n\t\t<li class=\"\"><a href=\"javascript:;\">2</a></li>\n\t\t<li class=\"\"><a href=\"javascript:;\">3</a></li>\n\t\t<li class=\"\"><a href=\"javascript:;\">4</a></li>\n\t\t<li class=\"\"><a href=\"javascript:;\">5</a></li>\n\t</ul>\n```\nCSS:\n```bash\n\t#star li{\n\t\twidth: 24px;\n\t\tfloat: left;\n\t\tcursor: pointer;\n\t\ttext-indent: -9999px;/*<a>之间有文字，有时为了搜索引擎需要,但我们实际的星星上不想要文字，则添加了这个属性隐藏它*/\n\t\tbackground: url(img/star.png) no-repeat;\n\t}\n```\n　　text-indent:-9999px 一般用于隐藏文字。比如LOGO 部分，因为SEO(Search Engine Optimization)搜索引擎优化 的需要，所以要有文字在，但事实上显示的时候用了图片代替，所以就要使用text-indent:-9999px; 把它从界面上隐藏掉。\n　　text-indent 是缩进，使用9999 是为了让他的缩进足够大，大分辨率下也能缩到不见。\n"},{"title":"offsetLeft和style.left","url":"/2018/04/11/offsetLeft和style-left/","content":"\n## offsetLeft和style.left\n\n### offsetLeft\n\n　　1.如果父辈元素中有定位的元素，那么就返回距离当前元素最近的定位元素边缘的距离。\n　　2.如果父辈元素中没有定位元素，那么就返回相对于body左边缘距离。\n\n### 两者的区别\n\n　　1. style.left 返回的是字符串，如28px，offsetLeft返回的是数值28，如果需要对取得的值进行计算，还用offsetLeft比较方便。\n　　2. style.left是读写的，offsetLeft是只读的，所以要改变元素的位置，只能修改style.left。\n　　3. style.left的值需要事先定义，否则取到的值为空。而且必须要定义在html里，offsetLeft的值随时可以取到。\n"},{"title":"JS清空数组的方法","url":"/2018/04/10/JS清空数组的方法/","content":"\n### ①splice\n```bash\n\tvar ary = [1,2,3,4]; \n\tary.splice(0); //不用写要删的长度，直接从0全删掉\n```\n\n### ②length=0\n```bash\n\tvar ary = [1,2,3,4]; \n\tary.length=0; \n```\n　　这种方式很有意思，其它语言如Java，其数组的length是只读的，不能被赋值。而JS中则可以。\n\n### ③赋值为[]\n```bash\n\tvar ary = [1,2,3,4]; \n\tary = []; // 赋值为一个空数组以达到清空原数组\n```\n　　方式2 保留了数组其它属性，方式3 则未保留。很多人认为方式2的效率很高些，因为仅仅是给length重新赋值了，而方式3则重新建立个对象。经 测试 恰恰是方式3的效率高。测试代码：\n```bash\n\tvar a=[];\n\tfor(var i=0;i<1000000;i++){\n\t\ta.push(i);\n\t}\n\tvar start=new Date();\n\ta=[];\n\tvar end=new Date();\n\talert(end-start);\n```\n　　可以多试几个浏览器，结果是方式3更快一点点。"},{"title":"内联元素和块元素","url":"/2018/04/07/内联元素和块元素/","content":"\n## 内联元素和块元素\n\n### ①块级元素:默认100%撑满外层盒子的宽度（浏览器显示区域），独占一行，垂直排列，里能用行内元素，可以设置宽高\n　　|-->div 没有任何CSS属性（主要用在大框架）\n　　|-->p     自带上下外边据  （用在段落）\n　　|-->h1-h6   自带上下外边据，自带字体大小（用在栏目大标题）\n　　|-->ul li       自带上下外边据，li自带圆点 （用在列表，多个元素大小一致）\n　　|-->dl dt dd   用在带标题的列表上 \n\n### ②行内元素（内联元素）:默认宽度只有本身所占的宽度，默认水平排列，不支持宽高 ，margin padding左右有效果 上下没有效果\n　　|-->a  超链接  自带标签颜色、鼠标放上颜色，点击时的颜色，点击过颜色，下划线\n　　|--> span \n　　|-->em、i（默认斜体）\n　　|-->strong,b（默认加粗）\n　　|-->u（默认下划线）\n   \n### ③行内块级元素:默认宽度只有本身所占的宽度，默认水平排列，支持宽高，受到父级text-align影响，可以居中\n　　|-->img 图片 \n　　|-->input 输入框\n　　|-->select  下拉菜单\n　　|-->textarea 输入区域\n\nIE6----------------BUG----------------------\n块级元素转化成行内块级元素   IE6不支持\n行内元素转化成行内块级元素 IE6支持\n\n块级元素加上position:absolute fixed（定位）或者浮动 宽度不是100% 是本身内容的宽度\n行内元素加上position:absolute fixed（定位）或者浮动  就会变成块级元素\n\n## display:block; display:inline;和display:inline-block;\n\n### block：使用此属性后，元素会被显示为块级元素，元素会进行换行，默认宽度为撑满外层盒子的宽度(因为块元素霸道)。\n### inline：使用此属性后，元素会被显示为内联元素，元素则不会换行，默认宽度为内容的宽度。\n### inline-block：是使元素以块级元素的形式呈现在行内。意思就是说，让这个元素显示在同一行不换行，但是又可以控制高度和宽度，这相当于行内元素的增强。\n　　应用：\n　　1.display:inline-block把一个元素变成块级元素，但他的大小只是他本身内容的大小并不撑满外围盒子，如下图所示：\n　　![内联元素与块级元素的关系](https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/display.jpg?raw=true)所以在一道练习中出现下面的情况：\n```bash\n\t<li><a href=\"javascript:;\">手写</a></li>\n```\n　　若不把a变成块元素，则a上的背景不会撑满整个li。\n\n　　2.li是块元素，原本会换行，是竖着一列的布局，但改为inline-block并在父元素指定了width后，则会以块级元素的形式呈现在行内，不换行，但能控制高度宽度，这样就可以变成一行行排列的布局了。\n\n## css属性\n　　| ----------①盒子模型：width、height，padding、border、margin\n 　　　注意事项：padding 上下左右 全部相加       margin 上下取最大  左右相加     margin-top如想父级元素不受影响，父级元素要加overflow:hidden\n　　| ----------②-1 背景相关：background背景缩写:background-color,background-image,background-repeat,background-attachment,background-position\n　　| ----------②-2 文本样式：font-size文字大小/line-height行高、color文本颜色、text-align水平位置、font-family文字字体、letter-spcing文字间隔、text-decoration文本样式\n　　| ----------②-3 UL li：list-style列表样式\n　　| ----------②-4 A链接：a{}\n　　　　a:link - 普通的、未被访问的链接\n　　　　a:visited - 用户已访问的链接\n　　　　a:hover - 鼠标指针位于链接的上方\n　　　　a:active - 链接被点击的时刻\n　　| ----------③选择器    style 优先级最高  |   ID选择器   #xxx  id=\"xxx\"  |  类选择器 .xxx  class=\"xxx\"  |   元素选择器   p  | 后代选择器   .xxx .yyy\n　　| ----------④定位        float（浮动）  position（定位）：relative（相对）absolute（绝对）fixed（相对浏览器固定）"},{"title":"CSS定位与浮动","url":"/2018/04/07/CSS定位与浮动/","content":"\n## 元素加上浮动float后的影响\n\n　　0.float设计初衷就是为了实现文字环绕效果，[详情请见](http://www.cnblogs.com/liyunhua/p/4670908.html \"你所不了解的float(滥用float的怪异现象)\")\n　　1.浮动的参考对象：浮动的框可以向左或向右移动，直到它的外边缘碰到**包含框**或**另一个浮动框的边框**为止。\n　　2.父级元素受影响：该元素脱离文档流，使父级元素高度消失，在父级元素上加overflow:hidden 或 加height 或在父级元素上加一个clearfix类来修复父级元素的高度 (content 属性与 :before 及 :after 伪元素配合使用，定义元素之前或之后放置的生成内容。其中\\0020是空格的转义字符，一般直接写空格就行)\n```bash\n\t.clearfix:before, .clearfix:after { content: \"\\0020\"; display: block; height: 0; overflow: hidden; }  \n\t.clearfix:after { clear: both; }  \n\t.clearfix { zoom: 1; }  \n```\n　　3.设置了float的元素,**脱离了文档流，但没有脱离文本流**。也就是说当它后面还有元素时，其他元素会无视它所占据了的区域，直接在它身下布局。但是文字却会认同浮动元素所占据的区域，围绕它布局。 \n　　4.同级不加浮动的元素受影响：正常没加浮动的文档流元素，会无视该浮动元素   在没加浮动的元素上加 clear:both 来修复该元素上面浮动元素所占的高度\n\n## 定位详解\n\n　　值\t　　　　　　描述\n　　static\t　　　　默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。\n　　relative　　　位置被设置为 relative 的元素，可将其移至**相对于其本身**正常位置的地方，因此 \"left:20\" 会将元素移至元素正常位置左边 20 个像素的位置。\n　　absolute　　位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 **\"left\"、\"top\"、\"right\" 以及 \"bottom\" 属性**来规定。\n　　fixed　　　　位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 \"left\"、\"top\"、\"right\" 以及\"bottom\" 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。\n\n### 扩充详解　position:absolute\n\n　　这个顾名思义是绝对布局，在元素中设置之后，该元素会完全脱离文档流，它并不是相对于浏览器进行定位，**而是一层一层向上寻找父元素，直到寻找到第一个position不为static的祖先元素，它相对于这个祖先元素进行定位。**\n　　所以当你的父元素position:relative时，该子元素才会相对于你的父元素进行定位。如果任何一个祖先元素都没有设置position:relative，寻找到最外层的顶级元素html后自然不会继续寻找，所以这时才是相对于浏览器进行定位。\n　　我们可以看一个小例子：\nHTML:\n```bash\n\t<div id=\"outer\">\n\t\t<div id=\"inner\">\n\t\t\t<div id=\"deepinner\">\t\t\n\t\t\t</div>\n\t\t</div>\n\t</div>\n```\nCSS:\n```bash\n\t*{\n\t\tmargin: 0;\n\t\tpadding: 0;\t\n\t}\n\t#outer{\n\t\twidth: 500px;\n\t\theight: 500px;\n\t\tborder: 1px solid #000;\n\t\tmargin-left:100px;\n\t\tposition: relative;\n\t}\n\t#inner{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tposition: absolute;\n\t\tborder: 1px solid red;\n\t\tleft: 100px;\n\t\ttop: 100px;\n\t}\n\t#deepinner{\n\t\twidth:100px;\n\t\theight: 100px;\n\t\tposition: absolute;\n\t\tborder: 1px solid red;\n\t\tleft: 50px;\n\t}\n```\n　　可以发现deepinner层相对与inner层偏移了50px，所以可以证明absolute是**一层一层向上寻找父元素，直到寻找到第一个position不为static的祖先元素，它相对于这个祖先元素进行定位。**，这里deepinner层相对的就是inner层。\n\n### 元素加上absolute和fixed后的影响\n\n　　1.宽度改变：该元素宽度变成设置的宽度，如果无则是内部元素所占的宽度   可以加宽度修复，也可以不加，就使用自身内容大小\n　　2.元素类型改变：内联元素可以变成块级元素。\n　　3.文档流影响：元素完全脱离文档流，**同级的定位，后写的在上层**，可以通过**z-index属性**来解决层级问题\n\n#### z-index可能出现的问题\n　　有时候可能会出现明明设置了absolute，z-index也设置的很大，但显示还是在另一个层的下面的情况，这时候就要注意这个节点所在树的第一个relative属性的父标签的z-index是不是太小,比如虽然图片所在div当前的层级很高，但是由于老爸的老爸不顶用，可怜了z-index=9999;如此强势的孩子也没有出头之日啊！"},{"title":"JS中style,currentStyle和getComputedStyle的区别以及获取css操作方法","url":"/2018/04/06/JS中style-currentStyle和getComputedStyle的区别以及获取css操作方法/","content":"\n## JS中style,currentStyle和getComputedStyle的区别以及获取css操作方法\n\n　　首先需要了解CSS的三种使用方法：\n\n#### 1.行内样式\n\n```bash\n\t<!doctype html>\n\t<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>css行内样式</title>\n\t</head>\n\t<body>\n\t<div style=\"width:100px;height:100px;background:red;\"></div>\n\t\t\n\t</body>\n\t</html>\n```\n\n#### 2.内嵌样式\n\n```bash\n\t!doctype html>\n\t<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>css内嵌样式</title>\n\t</head>\n\t<body>\n\t<style type=\"text/css\">\n\t#div{width:100px;height:100px;background:red;}\n\t</style>\n\t<div id=\"div\"></div>\n\t\t\n\t</body>\n\t</html>\n```\n\n#### 3.外部样式\n\n```bash\n\t<!doctype html>\n\t<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>css内嵌样式</title>\n\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"XX.css\">\n\t</head>\n\t<body>\n\t<div id=\"div\"></div>\n\t\t\n\t</body>\n\t</html>\n```\n\n　　最近做了个小练习，点击h2想让ul元素在隐藏和显示中切换，但发现第一次点击总是无效，必须点到第二下以后才有想要的效果\n\nHTML:\n\n```bash\n\t<h2>播放列表...</h2>\n\t<ul>\n\t\t<li><a href=\"javascript:;\">玩家之徒 - 蔡依林</a></li>\n\t\t<li><a href=\"javascript:;\">原谅我就是这样的女生 - 戴佩妮</a></li>\n\t\t<li><a href=\"javascript:;\">猜不透 - 丁当</a></li>\n\t\t<li><a href=\"javascript:;\">自导自演 - 周杰伦</a></li>\n\t\t<li><a href=\"javascript:;\">浪漫窝 - 弦子</a></li>\n\t\t<li><a href=\"javascript:;\">流年 - 王菲</a></li>\n\t</ul>\n```\n\nJS:\n\n```bash\n\tvar oUl=document.getElementsByTagName(\"UL\")[0];\n\tvar oH2=document.getElementsByTagName(\"H2\")[0];\n\toH2.onclick=function(event){\n\t\toUl.style.display=oUl.style.display==\"block\"?\"none\":\"block\";\n\t}\n```\n\n　　原因为我以为ul默认为display:block; JS中的oUl.style.display能获取到block这个样式，但其实不然，**js的style属性只能获取行内样式**,所以一开始oUl.style.display=undefined，自然就不会第一下点击就隐藏了。\n\n　　解决方法是:在行内直接写入样式\n\n```bash\n\t<ul style=\"display: block;\">\n\t...\n\t</ul>\n```\n\n　　这样就能获取到了，所以在这里做一个总结：\n\n#### 1.style:各大浏览器都兼容,能设置样式和获取样式,但是获取不了嵌入和外部样式,如果写了行内没有的样式,返回的是空值\n\n　　写法:ele.style.attr(获取),ele.style.attr=\"值\"(设置);\n\n　　**注意只是获取不了嵌入和外部样式，但可以设置样式。**\n\n##### currentStyle属性和getComputedStyle属性不能设置属性,只能获取\n\n#### 2.currentStyle:该属性只兼容IE\n\n　　Element.currentStyle 是一个与 window.getComputedStyle方法功能相同的属性。这个属性实现在旧版本的IE浏览器中.\n\n　　写法:ele.currentStyle[\"attr\"]或者ele.currentStyle.attr;\n\n#### 3.getComputedStyle:该属性是兼容火狐谷歌,不兼容IE9.0以下版本\n\n　　getComputeStyle返回的样式是一个实时的 CSSStyleDeclaration 对象，当元素的样式更改时，它会自动更新本身。详情见[MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle \"Window.getComputedStyle()\")\n\n　　写法:window.getComputedStyle(ele,null)[attr]获取是window.getComputedStyle(ele,null).attr\n\n　　关于它们的区别可以参考：[获取元素CSS值之getComputedStyle方法熟悉](http://www.zhangxinxu.com/wordpress/?p=2378 \"获取元素CSS值之getComputedStyle方法熟悉\")　　\n\n　　最后附上一段封装的获取CSS的代码\n\nJS:\n\n```bash\n\t//设置或读取CSS样式\n\tfunction css(obj,attr,value){\n\t\tswitch(arguments.length){\n\t\t\tcase 2://如果有两个参数可能是设置或读取样式\n\t\t\t\tif(typeof arguments[1] == \"object\"){//即attr是个数组对象就设置样式\n\t\t\t\t\tfor(var i in attr){\n\t\t\t\t\t\ti == \"opacity\" ? (obj.style[\"filter\"]=\"alpha(opacity=\"+attr[i]+\")\", \n\t\t\t\t\t\t\tobj.style[i]=attr[i]/100) : obj.style[i]=attr[i];\t\t\t\t\t\t\t   \n\t\t\t\t\t}\n\t\t\t\t}else{//attr是个字符串就读取CSS样式\n\t\t\t\t\treturn obj.currentStyle ? obj.currentStyle[attr] : getComputeStyle(obj,null)[attr]\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3://三个参数就是设置样式\n\t\t\t\tattr == \"opacity\" ? (obj.style[\"filter\"]=\"alpha(opacity=\"+value+\")\", \n\t\t\t\t\tobj.style[attr]=value/100) : obj.style[attr]=value;\n\t\t\t\tbreak;\n\t\t}\n\t}\n```"},{"title":"网页导航栏小技巧","url":"/2018/04/03/网页导航栏小技巧/","content":"\n## 使用li+a构建网页导航栏\n\n　　首先说一下建导航栏时使用li+a而不是直接使用li的原因：一般导航都是具有超链接功能，a标签具有这个功能，而lis标签只是罗列信息列表，不具备链接功能。\n　　方法：一般我们在li中指定width，float;然后在a中使用display:block;再指定width和height，让它自动填充li即可。\n　　具体小例子见代码：\nHTML：\n```bash\n\t<div id=\"nav\">\n\t\t<ul>\n\t\t\t<li><a href=\"javascript:;\">站长之家</a></li>\n\t\t\t<li><a href=\"javascript:;\">行业资讯</a></li>\n\t\t\t<li><a href=\"javascript:;\">站长在线</a></li>\n\t\t\t<li><a href=\"javascript:;\">网站运营</a></li>\n\t\t\t<li><a href=\"javascript:;\">设计在线</a></li>\n\t\t\t<li><a href=\"javascript:;\">网络编程</a></li>\n\t\t\t<li><a href=\"javascript:;\">联盟资讯</a></li>\n\t\t\t<li><a href=\"javascript:;\">服务器</a></li>\n\t\t</ul>\n\t</div>\n```\nCSS：\n```bash\n\t#nav{\n\t\twidth: 730px;\n\t\tmargin: 20px auto;\n\t\tborder:1px solid blue;\n\t\tbackground: blue;\n\t}\n\t#nav ul{\n\t\tlist-style-type: none;\n\t\toverflow: hidden;\n\t\tmargin-left: 10px;\n\t}\n\t#nav ul li{\n\t\twidth: 80px;\n\t\tfloat: left;\n\t\tmargin-right: 10px;\t\t\t\n\t\tbackground: cornflowerblue;\n\t\tcursor: pointer;\n\t}\n\t#nav ul li a{\n\t\tdisplay: block;\n\t\twidth: 80px;\n\t\theight: 30px;\n\t\tline-height: 30px;\n\t\tpadding: 5px 0;\n\t\ttext-align: center;\n\t\ttext-decoration: none;\n\t\tcolor: #fff;\n\t}\n\t#nav ul li a:hover{\n\t\tfont-weight: 700;\n\t\tbackground: #aaa;\n\t}\n```\n　　麻雀虽小五脏俱全啊，涵盖了很多最近学到的知识点，算是在此纪念一下吧。"},{"title":"正则表达式摸门把级整理","url":"/2018/04/02/正则表达式摸门把级整理/","content":"### 最上面放正则的优先级\n\n![正则优先级](https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E6%AD%A3%E5%88%99%E4%BC%98%E5%85%88%E7%BA%A7.jpg?raw=true \"正则优先级\")\n\n### ①常用的元字符 (一些有特异功能的用来方便匹配的字符)\n\n　　代码　　说明\n　　.\t　　匹配除换行符以外的任意字符\n　　\\w　　匹配字母或数字或下划线（等价于*[A-Za-Z0-9_]*）\n　　\\s　　匹配任意的空白符\n　　\\d　　匹配数字\n　　\\b　　匹配单词的开始或结束\n　　^\t　　匹配字符串的开始\n　　$\t　　匹配字符串的结束\n\n　　^\\d{5,12}$　　因为使用了^和$，所以检测的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个字符串必须是5到12个数字。\n\n### ②常用的限定符 (表示它前面的字符重复的次数)\n\n　　代码　　说明\n　　*\t　　重复零次或更多次\n　　+\t　　重复一次或更多次\n　　?\t　　重复零次或一次（还有**非贪婪模式**的用法）\n　　{n}　　重复n次\n　　{n,}　　重复n次或更多次\n　　{n,m}\t　重复n到m次\n\n　　\\(?0\\d{2}[) -]?\\d{8}　　首先是一个转义字符\\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现0次或1次(?)，最后是8个数字(\\d{8})。\n\n### ③字符范围 \n\n　　代码　　说明\n　　[]　　　　匹配方括号中任意字符\n　　[0-9]　　代表的含意与\\d就是完全一致的：匹配任意一位数字\n\n　　注意在字符范围中有很多元字符不需要转义，可以代表自身，如.?+等。常见在[]内需要转义的有**\\和]和-**\n\n　　注：如果想匹配任意汉字的话，可以使用：*[\\u4e00-\\u9fa5]*。\n\n　　有时也会见到[^\\x00-\\xff]，即匹配不是ASCII代码中十六进制代码00到ff的字符，即不是ASCII代码十进制0到255的字符，所以汉字包括在里面。\n\n### ④分枝条件\n\n　　代码　　说明\n　　|　　　　匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n　　\n　　\\d{5}-\\d{4}|\\d{5}　　这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。\n\n### ⑤分组\n\n　　代码　　说明\n　　()　　重复单个字符,直接在字符后面加上限定符就行了；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了\n\n　　(\\d{1,3}\\.){3}\\d{1,3}　　是一个简单的IP地址匹配表达式。  \\d{1,3}匹配1到3位的数字，(\\d{1,3}\\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。\n\n　　但使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：\n\n#### 常用分组语法\n\n　　分类\t　　代码/语法\t　　说明\n　　捕获\t　　(exp)\t　　　　匹配exp,并捕获文本到自动命名的组里\n　　　　　　(?<name>exp)\t　　　　匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)\n　　　　　　(?:exp)\t　　　匹配exp,**不捕获**匹配的文本，也不给此分组分配组号\n　　零宽断言　(?=exp)\t　　匹配exp前面的位置**(断言：是真的才执行。所以在这里是exp才会匹配它前面的字符)**\n　　　　　　　(?<=exp)\t　匹配exp后面的位置\n　　　　　　　(?!exp)\t　　匹配后面跟的不是exp的位置\n　　　　　　　(?<!exp)\t　　匹配前面不是exp的位置\n　　注释\t　　  (?#comment)　　这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读\n\n### ⑥反义\n\n　　代码/语法\t说明\n　　\\W　　　　匹配任意不是字母，数字，下划线，汉字的字符\n　　\\S　　　　匹配任意不是空白符的字符\n　　\\D　　　　匹配任意非数字的字符\n　　\\B　　　　匹配不是单词开头或结束的位置\n　　[^x]　　　　匹配除了x以外的任意字符\n　　[^aeiou]　　匹配除了aeiou这几个字母以外的任意字符\n\n　　<a[^>]+>　　匹配用尖括号括起来的以a开头的字符串。\n\n### ⑦零宽断言(环视、断言)\n\n　　环视，就是先从全局环顾一遍正则，（然后断定结果，）再做进一步匹配处理。 \n　　断言，就是先从全局环顾一遍正则，然后断定结果，再做进一步匹配处理。\n\n　　两个虽然字面不一样，意思却是同一个，都是做全局观望，再做进一步处理。\n\n　　环视的作用相当于对其所在位置加了一个附加条件，只有满足这个条件，环视子表达式才能匹配成功。\n\n　　代码/语法\t说明\n　　(?=exp)\t　　 先行断言：匹配后面是exp的数据**(断言：是真的才执行。所以在这里是exp才会匹配它前面的字符)**\n　　(?!exp)\t　　 先行否定断言：匹配后面不是exp的数据\n　　(?<=exp)　　后行断言：匹配前面是exp的数据 **（JS在ES6才支持后行断言）**\n　　(?<!exp)　　 后行否定断言：匹配前面不是exp的位置\n\neg:前端的一道笔试题：[模拟数字的千位符](https://segmentfault.com/q/1010000015106681 \"给一个数字的整数部分每三位加一个千位符\")\n\n### ⑧贪婪与懒惰\n\n　　当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为**贪婪匹配**。\n\n　　有时，我们更需要**懒惰匹配，也就是匹配尽可能少的字符**。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号**?**。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：\n\n　　a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。\n\n## JS中有两种方式创建正则表达式对象,eg:下面创建一个匹配字符串的正则表达式对象\n\n```bash\n//一、正则表达式字面量方法\nvar my_regexp1=/\"(?:\\\\.|[^\\\\\\\"])*\"/g;\n\n//二、RegExp构造器方法(此时有两个阶段，先经过字符串的转义，后再经过正则表达式的转义，所以经常需要双反斜杠进行转义)\nvar my_regexp2=new RegExp(\"\\\"(?:\\\\\\\\.|[^\\\\\\\\\\\\\\\"])*\",\"g\";\ndocument.writeln(my_regexp1.exec('\"Daoma is 666\"')[0]);\ndocument.writeln(my_regexp2.exec('\"Daoma \"is 666\"')[0]);\n```\n\n　　其它具体请参考：[快速入门正则表达式](http://www.jb51.net/tools/zhengze.html \"快速入门正则表达式\")"},{"title":"预加载图片的小技巧","url":"/2018/03/31/预加载图片的小技巧/","content":"\n## 预加载图片的小技巧\n\n　　　　在做ex5-5(跟随鼠标移动显示大图)作业的时候，想要实现一个功能：即图片不能显示的话，就给把该图片设置为一个替代的loading图片。\n\n#### 1.使用Image对象做图片预加载(preload)\n\n　　我们还是先来看一下代码：\n\nJS:\n\n```bash\n\taLi[i].onmouseover = function ()\n\t{\n\t\tvar oImg = document.createElement(\"img\");\n\t\t//图片预加载\n\t\tvar img = new Image();\t\t\t\n\t\timg.src = oImg.src = aLi[this.index].getElementsByTagName(\"img\")[0].src.replace(\".jpg\",\"_big.jpg\");\n\t\t//插入大图片\n\t\toBig.appendChild(oImg);\n\t\t//显示big层\n\t\toBig.style.display = oLoading.style.display = \"block\";\n\t\t//判断大图是否加载成功\n\t\timg.complete ? oLoading.style.display = \"none\" : (oImg.onload = function() {oLoading.style.display = \"none\";})\t\t\n\t};\n```\n\n　　*其实像下面这样写就可以，功能还很清晰，不知道ex5-5的原作者多var出来一个oImg有什么用???等以后我明白了再回来补充。*\n\n```bash\n\taLi[i].onmouseover = function ()\n\t{\n\t\t//图片预加载\n\t\tvar img = new Image();\t\t\t\n\t\timg.src = aLi[this.index].getElementsByTagName(\"img\")[0].src.replace(\".jpg\",\"_big.jpg\");\n\t\t//插入大图片\n\t\toBig.appendChild(img);\n\t\t//显示big层\n\t\toBig.style.display = oLoading.style.display = \"block\";\n\t\t//判断大图是否加载成功\n\t\timg.complete ? oLoading.style.display = \"none\" : (img.onload = function() {oLoading.style.display = \"none\";})\t\t\n\t};\n```\n\n　　下面是分析：\n　　首先要明白一点：\"<img>\"标签每出现一次，一个 Image 对象就会被创建。所以上面的oImg也是个Image对象。但是现在还不明白为何要多出来个它？？？\n\n　　**当定义Image对象的src属性时**，整个文档的读取、JavaScript 的运行都暂停，让浏览器专心的读取图片,所以定义img.src和oImg.src就相当于**给浏览器缓存(preload)了一张图片**。然后到真正要把图片加载到浏览器中**(即img.onload)**的时候，就可以立刻使用缓存的图片了。\n\n#### 2.使用Image对象的complete属性来判断浏览器是否已完成对图像的加载\n\n　　在该例子中，当我们第一次打开页面时，鼠标移入任意aLi[i]都是第一次，这时浏览器会缓存这张预加载的大图，但是**还没有将它加载到浏览器中**。所以第一次执行这段代码img.complete一定是返回false,则执行\n\n```bash\n\timg.onload=function(){\n\t\tloading.style.display=\"none\";\n\t}\n```\n\n　　这里oImg[0].onload的作用就是**把图片加载(load)到浏览器中**，然后**当图片加载完成后再执行花括号的内容**，即将oLoading图片所在层隐藏（这样就会出现第一次鼠标移入图片时的闪现loading图片的效果），若是图片出现错误，则会一直显示oLoading层的图片。\n\n　　然后等我们鼠标第2、3.....n次移入该aLi[i]层的时候，因为图片已经加载过一次，如果再有对该图片的请求(即img.src)时，由于浏览器已经缓存住这张图片了，不会再发起一次新的请求，而是直接从缓存中加载过来,此时img.complete就会一直返回true，所以oLoading层的图片就会一直被隐藏。\n\n　　[详细用法请见](https://blog.csdn.net/dcb_ripple/article/details/52175842 \"js中的Image对象\")\n　　[预加载的简便理解](http://www.jb51.net/article/43507.htm \"js中Image对象以及对其预加载处理示例\")"},{"title":"一些零星的HTML,CSS,JS知识","url":"/2018/03/27/一些零星的HTML,CSS,JS知识/","content":"\n## li标签中的a标签改变字体颜色color需要注意的地方\n\n　　最近遇到了想鼠标移到li上，但里面的a字体变色不成功的问题。查了一下因为<a>默认就有样式，所以不会继承父级的color等样式，这时候就需要显式让a继承li的color才行，即：\n\n```bash\nli{\n\tcolor: #fff;\n}\nli>a{\n\tcolor: inherit;\n}\n```\n\n## CSS想实现一个元素发生变动，改变另外元素的样式\n\n　　原先我一直以为CSS只能改变自身元素的样式，如果想自身变动又想要别的元素变动，必须借助JS才行，但发现并不是这样。\n\nHTML:\n\n```bash\n<div id=\"box\"></div>\n<p>就会发现你可以hover第一个层的时候，改变第二个层的样式。</p>\n<div></div>\n```\n\nCSS:\n\n```bash\ndiv{\n\twidth: 100px;\n\theight: 100px;\n\tbackground: red;\n\tborder: 3px double #000;\n}\n#box:hover ~ div{\n\tbackground: blue;\n}\t\n```\n\n## 结构伪类选择器:nth-child(n)需要注意的地方\n\n　　:nth-child选择的是**某父元素**的子元素，这个子元素并没有指定确切的类型，必须同时满足两个条件时方能有效果：\n\n　　1.是子元素\n　　2.该子元素刚好处在n那个位置\n\n　　但有时候经常会出现问题，比如在body下加*<script>*标签的时候：\n\nHTML:\n\n```bash\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title></title>\n\t\t<style type=\"text/css\">\n\t\t\t.a{\n\t\t\t\tdisplay: inline-block;\n\t\t\t\twidth: 150px;\n\t\t\t\theight: 150px;\n\t\t\t\tborder: 1px solid #cad5eb;\n\t\t\t\tbackground-color: #f0f3f9;\n\t\t\t}\n\t\t\tspan:nth-last-child(2){/*这里要2才行，不知道为什么*/\n\t\t\t\tline-height: 0;\n\t\t\t\tbackground: red;\n\t\t\t}\n\t\t\t\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<span class=\"a\"></span>\n\t\t<span class=\"a\">x-baseline</span>\n\t</body>\n\t<script type=\"text/javascript\">\n\t\tvar a=\"这里放script标签则会导致nth-child选择器出错？？？\";\n\t\tvar b=\"但是去掉script标签则会没事\";\n\t</script>\n</html>\n```\n\n#### 用于裁剪img图片的clip: rect(top,right,bottom,left);\n\n　　首先注意clip属性只能用于绝对定位元素，position:absolute或fixed。\n\n　　齐次top right bottom left分别指最终剪裁可见区域的上边，右边，下边与左边。而所有的数值都表示位置，且是相对于原始元素的左上角而言的。于是\n\n　　eg:rect(30px 200px 200px 20px)\n\n　　表示的含义就是：最终剪裁的矩形的上边距离原始元素的上边缘30像素；剪裁矩形的右边缘距离原元素左边缘的距离是200像素；剪裁矩形的下边缘距离原元素顶部的距离为200像素；剪裁矩形的左边缘距离原元素左边缘的距离时20像素。\n\n　　上面的表述又长有啰嗦又难以理解，你可以这样想象：饥饿N天的你突然面前出现了块香喷喷的大大的300厘米*300厘米方形手抓饼，你拔出自己随着携带的锋利的日本刀，在距离顶部30厘米的地方咔嚓一刀，然后在距离左边200厘米的地方咔嚓一刀，然后又以迅雷不及掩耳的速度在距离顶部200厘米和距离20厘米的地方咔嚓一刀。**啪啪四刀留下的中间的那块就是剪裁的内容了**。所以，您可以将top right bottom left理解为在这些位置拿大刀咔咔修剪。\n\n## js中{}大括号,[]中括号使用详解\n\n#### { }大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数。\n\n```bash\nvar mayun={\n\tname: \"cocl\",\n\tage: function(){\n\t\talert(\"21\");\n\t}\n}\nmayun.age();\n```\n\n#### [ ]中括号，表示一个数组，也可以理解为一个数组对象。 \n\n### map和forEach的异同:\n\n两者都可以逐个遍历数组, 但不同的是, map操作后可以返回一个新数组(意味着可以链式调用), forEach操作完就结束了.\n\nmap是数组的方法, 如果是一个Nodelist的话则用不了(虽然可以进行封装扩展). 而forEach数组和Nodelist都内置有这个方法."},{"title":"JS for-in语句的使用","url":"/2018/03/26/JS-for-in语句的使用/","content":"\n## JS for-in语句的使用\n\n#### js中for循环一般用于遍历数组\n#### for-in一般用于循环遍历对象的属性 \n　　\n　　因为JavaScript的数组其实就是对象，它把数组的下标转变成字符串，用其作为属性。所以下面两个对象类似：\n\n```bash\n\t//数组字面量\n\tvar numbers=[\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\"];\n\t//它很类似对象字面量\n\tvar numbers_object={\n\t\t\"0\":\"zero\",\"1\":\"one\",\"2\":\"two\",3:\"three\",4:\"four\",\"5\":\"five\"\n\t}\n```\n\n　　因为JavaScript的数组其实就是对象,所以for in语句可以用来遍历一个对象的所有属性，即：\n\n```bash\n\tvar numbers=[\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\"];\n\t//num只是该数组对象的属性\n\tfor(var num in numbers){\n\t\tconsole.log(num);//0,1,2,3,4,5 \n\t}\n\t//这样才能得到数组中的每一项\n\tfor(var num in numbers){\n\t\tconsole.log(numbers[num]);//\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\"\n\t}\n```\n　　但要注意for-in无法保证属性的顺序。"},{"title":"CSS 使用overflow:hidden清除浮动","url":"/2018/03/26/CSS-使用overflow-hidden清除浮动/","content":"\n## CSS 使用overflow:hidden清除浮动\n\n　　今天做了一道网页换肤的练习，但发现了其中的两个小问题，详情如下：\n```bash\n\t<div id=\"outer\">\n\t\t<ul id=\"skin\">\n\t\t\t<li id=\"red\" title=\"红色\"></li>\n\t\t\t<li id=\"green\" title=\"绿色\"></li>\n\t\t\t<li id=\"blue\" title=\"蓝色\"></li>\n\t\t</ul>\n\t\t<ul id=\"nav\">\n\t\t\t\t<!--\n                \tjavascript: 是一个伪协议javascript:是表示在触发<a>默认动作时，执行一段JavaScript代码，\n                \t而 javascript:;表示什么都不执行，这样点击<a>时就没有任何反应。\n                -->\n\t\t\t\t<li><a href=\"javascript:;\">新闻</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">娱乐</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">体育</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">电影</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">音乐</a></li>\n\t\t\t\t<li><a href=\"javascript:;\">旅游</a></li>\n\t\t</ul>\n\t</div>\n```\n　　在div里有两个ul，对它们的li分别都设置了float: left后发现：\n　　1.  这两个ul中的li都脱离了文档流，跑到一行上去了\n　　2.  为ul设置过黑色背景，但都消失了\n　　于是我使用了br来换行，但发现原作者并没有这样做，这不由得让我产生了疑问。在反复查看源码后，我发现是overflow: hidden;在起作用，遂到网上一查发现，它并不只有**隐藏溢出**的功能，还有**清除浮动**和**解除坍塌**的功能。原理如下：\n　　浮动的元素(两个ul中的li)脱离文档元素， 不占据空间，所以跑到了一行上。 不浮动的元素(ul,div)会直接无视掉这个元素。因为我们没有设置父ul的高度，父ul无视了自己的两个孩子，其高度变为0，所以父ul没有显现。 解决方法就是：\n　　1.  如果只想换行，给ul添加overflow:hidden属性即可，清除浮动，恢复它原先占据的ul的位置\n　　2.  为父ul添加overflow:hidden属性用以清除浮动，使得父ul显现\n\n　　若想更细致的查看该属性的用法：[详细链接](https://blog.csdn.net/hukaihe/article/details/51298665 \"深入理解：overflow:hidden——溢出,坍塌,清除浮动\")\n"},{"title":"JS中&&和||的奇怪用法","url":"/2018/03/25/JS中-和-的奇怪用法/","content":"## JS中&&和||的奇怪用法\n\n　　最近正在学 JS，找了点练习来做，然后看到如下的代码：\n```bash\n\tfor (var i = 0; i < oBtn.length; i++)\n\t{\n\t\toBtn[i].index = i;\n\t\toBtn[i].onclick = function ()\n\t\t{\n\t\tthis.index == oBtn.length - 1 && (oDiv.style.cssText = \"\");\n\t\tchangeStyle(oDiv, oAtt[this.index], oVal[this.index]);\n\t\t}\n\t}\n```\n　　然后我上网搜了一下明白了 var c=a||b;或var c=a&&b;这种情况时\n**a && b :如果执行 a 后返回 true，则执行 b 并返回 b 的值；如果执行 a 后返回 false，则整个表达式返回 a 的值，b 不执行**\n**a || b :如果执行 a 后返回 true，则整个表达式返回 a 的值，b 不执行；如果执行 a 后返回 false，则执行 b 并返回 b 的值**\n\n　　所以这句就好理解了this.index == oBtn.length - 1 && (oDiv.style.cssText = \"\");\n　　这可以算是一种炫技代码⊙﹏⊙，相当于：\n```bash\n\tif(this.index == oBtn.length - 1){\n\t\toDiv.style.cssText = \"\";\n\t}\n```"},{"title":"A Front-end newbie","url":"/2018/03/25/A-Front-end-newbie/","content":"## 新手上路啦\n\n　　忙活了三天搭起了个人的博客，虽然只是开了一个框架，但看到属于自己的页面那一刻，心情是很激动的.作为一只准备投身前端领域的小菜鸟，这一个月越发的感受到了前端的魅力，也见识了前端的深邃，自己目前的水平也就是刚对JS和CSS入了门，上论坛看大家讨论的一堆名词连听都没听说过，所以革命还需努力啦！  \n　　鉴于目前已大三下学期，马上就要找实习了，故在文章最后分享一下最近看到一句话：“你第一个月的工资=你之前看过的所有技术性书籍价值的总和”，我感觉这是非常有道理的，小时候读书少，现在有动力读相关技术的书了，也算是一个好兆头。\n　　最后分享一下搭建博客的过程中用到的教程：\n　　1.  GitHub搭建博客 [具体教程](https://blog.csdn.net/u012075670/article/details/54581015 \"如何用github搭建自己的个人网站\")\n　　2.  Hexo完善博客       [具体教程](https://www.cnblogs.com/visugar/p/6821777.html \"hexo从零开始到搭建完整\")\n　　3.  使用markdown来写博客(ps:要是想要段首缩进可以切换到输入法全角模式打两个空格) [语法参考](https://www.w3cschool.cn/markdownyfsm/cbx1e7.html \"Markdown 语法说明\")\n　　那今天就先到这里啦，我们下篇博客再会！\n"},{"title":"Hello World","url":"/2018/03/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n\n### Generate static files\n\n``` bash\n$ hexo generate or $ hexo g\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Debug\n\n``` bash\n$ hexo s --debug\n```\n\nMore info: [Server](https://hexo.io/zh-cn/docs/commands.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy or $ hexo d\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]
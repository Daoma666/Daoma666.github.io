<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>岛马的主页</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="岛马的主页">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="岛马的主页">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="岛马的主页">
  
    <link rel="alternative" href="/atom.xml" title="岛马的主页" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">岛马</a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">My Blog</a></li>
                        
                            <li><a  href="/categories/movies/">My movies</a></li>
                        
                            <li><a  href="/categories/digital">菜单2</a></li>
                        
                            <li><a  href="/categories/algorithm">菜单3</a></li>
                        
                            <li><a  href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/Daoma666" title="github">github</a>
                            
                                <a class="fl weibo"  target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.csdn.net/baidu_21483933">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://segmentfault.com/blog/maocg_web">segmentfault</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/eb37ef89c746/latest_articles">简书</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">电影狂魔，游戏宅男，代码小白</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">岛马</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">岛马</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">My Blog</a></li>
                
                    <li><a href="/categories/movies/">My movies</a></li>
                
                    <li><a href="/categories/digital">菜单2</a></li>
                
                    <li><a href="/categories/algorithm">菜单3</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/Daoma666" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-JS辨别数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/06/01/JS辨别数据类型/" class="article-date">
      <time datetime="2018-06-01T09:23:29.000Z" itemprop="datePublished">2018-06-01</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/06/01/JS辨别数据类型/">JS辨别数据类型</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="首先要了解JS判断语句中的假值"><a href="#首先要了解JS判断语句中的假值" class="headerlink" title="首先要了解JS判断语句中的假值"></a>首先要了解JS判断语句中的假值</h2><p>　　值　　　　　类型<br>　　0　　　　　　Number<br>　　NaN　　　　Number<br>　‘’(空字符串)　String<br>　　false　　　　Boolean<br>　　null　　　　　Object<br>　　undefined　　Undefined</p>
<h2 id="怎么辨别数组-null和对象"><a href="#怎么辨别数组-null和对象" class="headerlink" title="怎么辨别数组,null和对象"></a>怎么辨别数组,null和对象</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>　　typeof不能判断出数组和null，而且对于通过new操作符生成的对象，只会返回’object’</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof null); //<span class="string">'object'</span></span><br><span class="line">alert(typeof []);   //<span class="string">'object'</span></span><br><span class="line">alert(typeof &#123;&#125;);   //<span class="string">'object'</span></span><br></pre></td></tr></table></figure>
<p>　　但Object.prototype.toString对任何变量会永远返回这样一个字符串”[object class]”，而这个class就是JavaScript内嵌对象的构造函数的名字。至于用户自定义的变量，则class等于object。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.prototype.toString.call(null));    //<span class="string">'[object Null]'</span></span><br><span class="line">alert(Object.prototype.toString.call([]));      //<span class="string">'[object Array]'</span></span><br><span class="line">alert(Object.prototype.toString.call(&#123;&#125;));      //<span class="string">'[object Object]'</span></span><br></pre></td></tr></table></figure>
<h4 id="①因此通过Object-prototype-toString-call-obj-可以准确的获取变量数据类型。"><a href="#①因此通过Object-prototype-toString-call-obj-可以准确的获取变量数据类型。" class="headerlink" title="①因此通过Object.prototype.toString.call(obj)可以准确的获取变量数据类型。"></a>①因此通过<strong>Object.prototype.toString.call(obj)</strong>可以准确的获取变量数据类型。</h4><p>　　通过Object.prototype.toString可以获得的数据类型包括：Date, Object, String, Number, Boolean, Regexp, Function, undefined, null等。</p>
<h4 id="②因为null是假值，所以辨别null与object或数组的关系可以用如下"><a href="#②因为null是假值，所以辨别null与object或数组的关系可以用如下" class="headerlink" title="②因为null是假值，所以辨别null与object或数组的关系可以用如下"></a>②因为null是假值，所以辨别null与object或数组的关系可以用如下</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//var value=null;</span><br><span class="line"><span class="keyword">if</span>(value &amp;&amp; typeof value===<span class="string">'object'</span>)&#123;</span><br><span class="line">	alert(<span class="string">'这是个对象或数组'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断NaN值"><a href="#判断NaN值" class="headerlink" title="判断NaN值"></a>判断NaN值</h2><p>　　NaN值一般在<em>试图把非数字形式的字符串转换为数字时</em>产生。</p>
<p>　　上面的typeof和Object.prototype.toString.call(obj);都不能判断NaN值,而且NaN也不等同于它自己。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof NaN);	//<span class="string">'number'</span></span><br><span class="line">alert(Object.prototype.toString.call(NaN));  //<span class="string">'[object Number]'</span></span><br><span class="line">alert(NaN===NaN);   //<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="好在JS提供了isNaN函数，可以辨别数字与NaN"><a href="#好在JS提供了isNaN函数，可以辨别数字与NaN" class="headerlink" title="好在JS提供了isNaN函数，可以辨别数字与NaN"></a>好在JS提供了isNaN函数，可以辨别数字与NaN</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(isNaN(<span class="string">'0'</span>));	//<span class="literal">false</span></span><br><span class="line">alert(isNaN(<span class="string">'oops'</span>)); //<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="其它问题记录"><a href="#其它问题记录" class="headerlink" title="其它问题记录"></a>其它问题记录</h2><p>　　undefined和null与任何有意义的值比较返回的都是false，但是null与undefined之间互相比较返回的是true。</p>
<p>　　一般typeof正则表达式都会返回’object’，但在Safari3.x版本中，返回的是’function’</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(undefined==null);    //<span class="literal">true</span></span><br><span class="line">alert(typeof /a/);         //<span class="string">'object'</span></span><br></pre></td></tr></table></figure>
<p>　　严格相等运算符（===）有两个需要注意的例子：除了NaN===NaN返回false以外，+0===-0却返回true。所以ES6提出了Object.is()方法来比较两个值是否严格相等。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-JS中的数值运算" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/05/31/JS中的数值运算/" class="article-date">
      <time datetime="2018-05-30T23:39:02.000Z" itemprop="datePublished">2018-05-31</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/05/31/JS中的数值运算/">JS中的数值运算</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="虽然有不少坑但是比较可靠的parseInt"><a href="#虽然有不少坑但是比较可靠的parseInt" class="headerlink" title="虽然有不少坑但是比较可靠的parseInt"></a>虽然有不少坑但是比较可靠的parseInt</h2><h4 id="Number-parseInt-string-radix-默认接收两个参数"><a href="#Number-parseInt-string-radix-默认接收两个参数" class="headerlink" title="Number.parseInt(string,radix) 默认接收两个参数"></a>Number.parseInt(string,radix) 默认接收两个参数</h4><p>　　第一个参数是默认是<strong> string </strong>类型值，如果不是，会通过抽象的 ToString 强制转化成 string 类型的值。这其中就会有强制类型转换过程中的各种坑</p>
<p>　　第二个参数是 number 类型的进制，如果不是，会通过抽象的 ToNumber 强制转化成 number 类型的值，范围是 2-36，通过强制类型转换后如果是其他值会返回 NaN。在 ES5 之前如果没有传入这个参数，会根据第一个参数的开头来判断进制，0 开头的字符串会判断成八进制，也就是很多人提到的老黄历坑。ES5 之后已经解决，不传这个参数默认十进制。但是这个参数容易被忽略，尤其是在和 map 之类的也容易忽略后续可选参数的函数搭配使用的时候，比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(parseInt) // 结果是 [1, NaN, NaN]</span><br><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(x=&gt;parseInt(x,10)) //正确的做法</span><br></pre></td></tr></table></figure>
<h4 id="这里第一个结果是-1-NaN-NaN-的原因为："><a href="#这里第一个结果是-1-NaN-NaN-的原因为：" class="headerlink" title="这里第一个结果是[1, NaN, NaN]的原因为："></a>这里第一个结果是[1, NaN, NaN]的原因为：</h4><p>　　map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, 元素索引, 原数组本身.</p>
<p>　　第三个参数parseInt会忽视, 但第二个参数不会,也就是说,parseInt把传过来的索引值当成进制数来使用.从而返回了NaN。</p>
<p>　　即实际是下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(<span class="string">"1"</span>, 0); // 这是特例, 按照 0 进制转成数, 直接得本身</span><br><span class="line">parseInt(<span class="string">"2"</span>, 1); // 直接NaN, 因为计数的进制至少也是 2 进制</span><br><span class="line">parseInt(<span class="string">"3"</span>, 2); // 也是NaN, 因为二进制只有0,1</span><br></pre></td></tr></table></figure>
<p>　　所以如果只是用 parseInt 来 “取整”，一个良好的习惯是<strong>永远记得设置第二个参数为 10</strong></p>
<p>　　最后提一点，在ES6中将全局对象的parseInt()和parseFloat()<strong>移植</strong>到了Number对象上面，行为完全不变。但Number.isFinite()和Number.isNaN()则是在内层借用了全局的相应方法，所以只能说ES6在Number对象上提供了isFinite()和isNaN()方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(isFinite===Number.isFinite);  //<span class="literal">false</span></span><br><span class="line">alert(isNaN===Number.isNaN);        //<span class="literal">false</span></span><br><span class="line">alert(parseInt===Number.parseInt);  //<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="巧妙使用位操作符"><a href="#巧妙使用位操作符" class="headerlink" title="巧妙使用位操作符"></a>巧妙使用位操作符</h2><p>　　JavaScript 中的 number 类型的值都是使用 IEEE 754 标准的 <strong>64 位</strong>双精度浮点型存储，即<em> 1 位符号位 + 11 位指数部分 + 52 位尾数部分 </em>。用来表示整数时，安全的范围是 <strong>53 位</strong>，超出这个返回可能会造成精度丢失</p>
<ol>
<li>使用<strong>按位或</strong>向下取整(数值不够大才能用)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num=-9999999.1234;</span><br><span class="line">var int=num|0;</span><br><span class="line">console.log(int);   //-9999999</span><br><span class="line"></span><br><span class="line">var num=-9999999999.1234;</span><br><span class="line">var int=num|0;</span><br><span class="line">console.log(int);   //-1410065407</span><br></pre></td></tr></table></figure>
<p>关于其它的取整方法可以见博客中：“JS中的取整”</p>
<ol>
<li>按位非（按位取反）任意数值x相当于-(x+1)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(~1);    //-2</span><br><span class="line">console.log(~0);    //-1</span><br><span class="line">console.log(~-1);   //0</span><br><span class="line"></span><br><span class="line">console.log(~NaN);  //-1</span><br><span class="line">console.log(~[]);   //-1</span><br></pre></td></tr></table></figure>
<p>　　我们可以发现：<strong>-1 是唯一一个经过 ~ 运算返回假值0的值</strong>（包括其他那些特殊的值比如 NaN、{}、[] 等都不会返回假值）</p>
<p>　　所以字符串和数组的 indexOf 函数查找失败会返回 -1，这时候就可以用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(~str.indexOf(<span class="string">'str'</span>)) // 来表示查找失败</span><br></pre></td></tr></table></figure>
<p>比判断 &gt;= 0 或者 != -1 更优雅，跟用 !! 来判断非假值有异曲同工之妙</p>
<h2 id="其它的骚操作"><a href="#其它的骚操作" class="headerlink" title="其它的骚操作"></a>其它的骚操作</h2><p>　　JS取0~9的一个随机数可以用:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Math.random()+<span class="string">""</span>).slice(-1);   //eg从0.984652315464中复制最后一个数字4</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-JS中new运算符详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/05/27/JS中new运算符详解/" class="article-date">
      <time datetime="2018-05-27T10:16:52.000Z" itemprop="datePublished">2018-05-27</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/05/27/JS中new运算符详解/">JS中new运算符详解</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="JS中new运算符和原型链继承"><a href="#JS中new运算符和原型链继承" class="headerlink" title="JS中new运算符和原型链继承"></a>JS中new运算符和原型链继承</h2><p>　　看下面的这些东西之前，先好好看看高程的第六章面向对象部分！里面提到了很多基本概念，比如：</p>
<ol>
<li><p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。</p>
</li>
<li><p>对原型所做的修改,能够立即在所有实例中得到反映。</p>
</li>
</ol>
<p>　　因为new运算符会返回一个指向构造器函数原型的对象，所以<em>通常</em>情况下this就指向返回的这个对象。</p>
<p>　　其中<strong>new运算符</strong>创建对象的过程，实际上就是：</p>
<ol>
<li>先克隆Object.prototype对象，得到一个空对象，并把它的prototype属性指向构造器函数的原型对象</li>
<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<p>　　在Chrome和Firefox等向外暴露了对象<strong>proto</strong>属性的浏览器下，我们可以通过下面这段代码理解new运算的过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name)&#123;</span><br><span class="line">	this.name=name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">	<span class="built_in">return</span> this.name;</span><br><span class="line">&#125;;</span><br><span class="line">var objectFactory=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">	var obj=new Object(),					//1. 先克隆Object.prototype对象，得到一个空对象</span><br><span class="line">	Constructor=[].shift.call(arguments);		//把第一个参数赋给Constructor变量</span><br><span class="line">	obj.__proto__=Constructor.prototype;		//1.指向正确的原型</span><br><span class="line">	var ret=Constructor.apply(obj,arguments);	//2. 将构造函数的作用域赋给新对象+3. 执行构造函数中的代码</span><br><span class="line">	<span class="built_in">return</span> typeof ret === <span class="string">"object"</span> ? ret : obj;	//4. 返回新对象</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">var a=objectFactory(Person,<span class="string">"sven"</span>);</span><br><span class="line"></span><br><span class="line">console.log(a.name);//sven</span><br><span class="line">console.log(a.getName());//sven</span><br><span class="line">console.log(Object.getPrototypeOf(a) === Person.prototype);//<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>　　然后我们就能理解构造器模式是如何创建对象的了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Point(x=10,y=6)&#123;</span><br><span class="line">	this.x=x;</span><br><span class="line">	this.y=y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.z=20;</span><br><span class="line">Point.prototype.getX=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">	alert(this.x);//不要忘了这里的this也是动态绑定的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p=new Point();//此时Point函数里的this动态绑定到p对象上，都是给p加的x,y属性</span><br><span class="line"></span><br><span class="line">p.getX();               //10 this绑定到p上，相当于alert(p.x)</span><br><span class="line">alert(p.__proto__.x);   //undefined</span><br><span class="line">p.__proto__.getX()      //undefiend this绑定到p的原型对象上也就是构造器原型对象上，当然没有x啦</span><br><span class="line">alert(p.z);             //20 虽然p对象本身没有z属性，但如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</span><br></pre></td></tr></table></figure>
<p>相关理解图示：<a href="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%9B%BE.jpg?raw=true" title="原型继承示意图" target="_blank" rel="noopener">原型继承示意图</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-实现slideUp-Down效果" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/05/20/实现slideUp-Down效果/" class="article-date">
      <time datetime="2018-05-20T02:20:53.000Z" itemprop="datePublished">2018-05-20</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/05/20/实现slideUp-Down效果/">实现slideUp/Down效果</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="实现slideUp-Down效果"><a href="#实现slideUp-Down效果" class="headerlink" title="实现slideUp/Down效果"></a>实现slideUp/Down效果</h2><p>　　最近做网页时，想做一个点击标题滑动出内容的模块，然后看了下参考的源码，结果发现有好几种做法。</p>
<h4 id="第一种最简单，就是使用JQuery的slideUp-Down方法，一步搞定"><a href="#第一种最简单，就是使用JQuery的slideUp-Down方法，一步搞定" class="headerlink" title="第一种最简单，就是使用JQuery的slideUp/Down方法，一步搞定"></a>第一种最简单，就是使用JQuery的slideUp/Down方法，一步搞定</h4><h4 id="第二种使用JS配合CSS3的transition属性，但是在该例子中transition需要处理与display的关系，两者貌似搭配起来不会产生效果"><a href="#第二种使用JS配合CSS3的transition属性，但是在该例子中transition需要处理与display的关系，两者貌似搭配起来不会产生效果" class="headerlink" title="第二种使用JS配合CSS3的transition属性，但是在该例子中transition需要处理与display的关系，两者貌似搭配起来不会产生效果"></a>第二种使用JS配合CSS3的transition属性，但是在该例子中transition需要处理与display的关系，两者貌似搭配起来不会产生效果</h4><p>　　解决方法是使用setTimeout延时display: none;的操作，因为我最终没有采用这种方法，留待以后检测。</p>
<h4 id="第三种使用纯JS实现，即设置setTimeout来控制层的高度实现滑入滑出效果"><a href="#第三种使用纯JS实现，即设置setTimeout来控制层的高度实现滑入滑出效果" class="headerlink" title="第三种使用纯JS实现，即设置setTimeout来控制层的高度实现滑入滑出效果"></a>第三种使用纯JS实现，即设置setTimeout来控制层的高度实现滑入滑出效果</h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-Git多人协作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/05/19/Git多人协作/" class="article-date">
      <time datetime="2018-05-19T00:06:16.000Z" itemprop="datePublished">2018-05-19</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/05/19/Git多人协作/">Git多人协作</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Git多人协作"><a href="#Git多人协作" class="headerlink" title="Git多人协作"></a>Git多人协作</h2><p>　　首先肯定需要对Git的基本操作有一定的认识，这里肯定要放上浅显易懂的：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" title="廖雪峰老师的Git教程" target="_blank" rel="noopener">廖雪峰老师的Git教程</a></p>
<p>　　看完后我们就应该对Git有个大体的认识了，然后一般用Git的人中我们分两类：一类就是自己在用着玩，那看完上面的教程差不多就可以自己去摸索了；第二类就是想要多人协作，进行一个项目开发或协同作业，所以我在这里就记一下这几天搞多人协作这块儿踩过的坑。</p>
<p>　　首先干一件事肯定是有个目标，我最近正在和同班同学搞一个网站的小项目，我们前端部分用的VSCode码代码，然后发现里面内置了Git，于是我们就兴冲冲的准备使用，经过一段时间摸索，自己add、commit、push到自己的GitHub时一点问题都没有，于是我们就准备多人协作了，在疯狂网上查找后，我们试出了三种方法。</p>
<h4 id="第一种：fork别人的库成为自己的，然后clone到自己电脑上操作，操作完push到自己的GitHub上，再去自己的GitHub上发起pull-request发给项目原作者，经原作者审核后merge"><a href="#第一种：fork别人的库成为自己的，然后clone到自己电脑上操作，操作完push到自己的GitHub上，再去自己的GitHub上发起pull-request发给项目原作者，经原作者审核后merge" class="headerlink" title="第一种：fork别人的库成为自己的，然后clone到自己电脑上操作，操作完push到自己的GitHub上，再去自己的GitHub上发起pull request发给项目原作者，经原作者审核后merge"></a>第一种：fork别人的库成为自己的，然后clone到自己电脑上操作，操作完push到自己的GitHub上，再去自己的GitHub上发起pull request发给项目原作者，经原作者审核后merge</h4><p>　　具体操作可见：<a href="https://blog.csdn.net/qq_33429968/article/details/62219783" title="GitHub上如何进行PR(Pull Request)操作" target="_blank" rel="noopener">GitHub上如何进行PR(Pull Request)操作</a></p>
<p>　　这样可行，但各位仁兄不觉得太过麻烦了吗……而且还需要审核，对于那种开源项目来说肯定是有必要的，但如果就是想四五个人协同作业的话，可以选用下面两种方法。</p>
<h4 id="第二种：进入需要多人协作的项目中配置其它成员的公钥SSH-key，然后其他成员即可拥有同等的权限，无需审核"><a href="#第二种：进入需要多人协作的项目中配置其它成员的公钥SSH-key，然后其他成员即可拥有同等的权限，无需审核" class="headerlink" title="第二种：进入需要多人协作的项目中配置其它成员的公钥SSH key，然后其他成员即可拥有同等的权限，无需审核"></a>第二种：进入需要多人协作的项目中配置其它成员的公钥SSH key，然后其他成员即可拥有同等的权限，无需审核</h4><p>　　如下图：<img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/Git1.png?raw=true" alt="多人协作方法2" title="配置其它成员的公钥"></p>
<p>　　这个方法有一个缺点，那就是需要其他成员把自己的SSH与自己的Github远程库解绑，才能被项目拥有者绑定到这个项目上，所以这就不方便其他成员操作自己的GitHub了。</p>
<h4 id="第三种：添加其他成员为项目协作者collaborators，其他成员也可拥有同等的权限，无需审核"><a href="#第三种：添加其他成员为项目协作者collaborators，其他成员也可拥有同等的权限，无需审核" class="headerlink" title="第三种：添加其他成员为项目协作者collaborators，其他成员也可拥有同等的权限，无需审核"></a>第三种：添加其他成员为项目协作者collaborators，其他成员也可拥有同等的权限，无需审核</h4><p>　　如下图：<img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/Git2.png?raw=true" alt="多人协作方法3" title="添加其他成员为项目协作者"></p>
<p>　　综上看如果你是个小项目想多人协作的话，这是最简便的方法，不过这里需要注意一点：项目拥有者发送邀请后，被邀请协作的成员需要去自己的<strong>GitHub注册邮箱</strong>里面找一封确认信！！！可能被标记为<strong>垃圾邮件</strong>了！一定要确认，否则无法完成！</p>
<p>　　最后多人协作肯定会有冲突发生，以后再更新一下解决冲突的方法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-JS中this的指向" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/05/15/JS中this的指向/" class="article-date">
      <time datetime="2018-05-15T14:37:32.000Z" itemprop="datePublished">2018-05-15</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/05/15/JS中this的指向/">JS中this的指向</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="JS中this的指向"><a href="#JS中this的指向" class="headerlink" title="JS中this的指向"></a>JS中this的指向</h2><pre><code>JavaScript中的this总是指向一个对象，而具体指向哪个对象是在**运行时**基于函数的执行环境动态绑定的。

有位人说A.apply(x,array);等价于(A.bind(x))(array),现在看着挺对的，留待以后验证。
</code></pre><h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p>　　当函数作为对象的方法被调用时，this指向该对象。</p>
<h4 id="普通函数调用模式"><a href="#普通函数调用模式" class="headerlink" title="普通函数调用模式"></a>普通函数调用模式</h4><p>　　this总是指向全局对象，在浏览器中，这个全局对象就是window对象。</p>
<pre><code>但在使用**严格模式**&quot;use strict&quot;;时，this在函数调用模式不会指向全局对象window,而是undefined。
</code></pre><h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>　　因为new运算符会返回一个指向构造器函数原型的对象，所以<em>通常</em>情况下this就指向返回的这个对象。</p>
<p>　　<strong>关于new运算符的内部具体操作请见我博客中的“JS中new运算符详解”！</strong></p>
<p>　　但还有特殊的情况，比如构造器<strong>显式的返回了一个object类型的对象</strong>时，new调用构造器则会最终返回这个对象，而不是我们期待的this。</p>
<h4 id="Function-prototype-apply调用模式"><a href="#Function-prototype-apply调用模式" class="headerlink" title="Function.prototype.apply调用模式"></a>Function.prototype.apply调用模式</h4><p>　　详情见我博客中的“JS中的apply()使用详解”一文，它的第一个参数可以改变函数体内this对象的指向。</p>
<p>　　如果我们传入的第一个参数是<strong>null或undefined</strong>，函数体内的this会指向全局对象，在浏览器中则是window。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func=<span class="keyword">function</span>(a,b,c)&#123;</span><br><span class="line">    alert(this===window);//<span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">func.apply(null,[1,2,3]);</span><br><span class="line">func.apply(undefined,[1,2,3]);</span><br></pre></td></tr></table></figure>
<p>　　但如果是在<strong>严格模式</strong>下，则会严格执行第一个参数指定了函数体内this对象的指向，即传进来null，this就指向null;传进来undefined,this就指向undefined</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func=<span class="keyword">function</span>(a,b,c)&#123;</span><br><span class="line">    <span class="string">"use strict"</span>;</span><br><span class="line">    alert(this===null);//<span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">func.apply(null,[1,2,3]);</span><br></pre></td></tr></table></figure>
<h4 id="闭包中的this指向"><a href="#闭包中的this指向" class="headerlink" title="闭包中的this指向"></a>闭包中的this指向</h4><p>　　每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此闭包中永远不可能直接访问外部函数中的这两个变量，this一定是在这个闭包被调用时动态绑定的。如果想使用外层函数的this，最常用的方法就是找一个变量把它保存下来(eg:that)。</p>
<h3 id="利用apply实现的bind函数"><a href="#利用apply实现的bind函数" class="headerlink" title="利用apply实现的bind函数"></a>利用apply实现的bind函数</h3><p>　　Function.prototype.bind，用来<strong>指定函数内部的this指向</strong>，其<em>简化版</em>实现可以这样模拟：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind=<span class="keyword">function</span>(context)&#123;</span><br><span class="line">	var that=this;//保存方法调用模式下被调用的原函数</span><br><span class="line">	<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;//闭包返回一个新函数（可访问外层函数的变量和参数）</span><br><span class="line">		<span class="built_in">return</span> that.apply(context,arguments);//改变that原函数的内部this指向为我们指定的context</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1=&#123;</span><br><span class="line">	name: <span class="string">"Daoma"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func();//未定义</span><br><span class="line"></span><br><span class="line">var func=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">&#125;.<span class="built_in">bind</span>(obj1);</span><br><span class="line">	</span><br><span class="line">func();//Daoma</span><br></pre></td></tr></table></figure>
<p>　　通常我们还会实现的稍微复杂一点，可以往func函数中预先填入一些参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">	var that=this,</span><br><span class="line">		context=[].shift.call(arguments),//将第一个元素删掉并返回</span><br><span class="line">		args=[].slice.call(arguments);//用slice的另一个功能将剩余的参数类数组转换成数组</span><br><span class="line">	<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">		//这里运用了函数柯里化的思想，组合两次分别传入的参数，作为新函数的参数</span><br><span class="line">		<span class="built_in">return</span> that.apply(context,[].concat.call(args,[].slice.call(arguments)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line">var obj1=&#123;</span><br><span class="line">	name: <span class="string">"daoma"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func=<span class="keyword">function</span>(a,b,c,d)&#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">	alert([a,b,c,d]);</span><br><span class="line">&#125;.<span class="built_in">bind</span>(obj1,1,2);</span><br><span class="line"></span><br><span class="line">func(3,4);//即可以传参两次拼到一起</span><br></pre></td></tr></table></figure>
<p>补充bind和call的返回值</p>
<ol>
<li>fun.bind(thisArg[, arg1[, arg2[, …]]])</li>
</ol>
<p>　　返回由指定的this值和初始化参数改造的<strong>原函数拷贝</strong></p>
<ol>
<li>fun.call(thisArg, arg1, arg2, …)</li>
</ol>
<p>　　返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。</p>
<p>最后我还有一个需要填的问题坑，留待以后实力提高后解决：<a href="https://segmentfault.com/q/1010000014969567?_ea=3765087" title="JavaScript中Apply调用模式的this指向问题JavaScript中Apply调用模式的this指向问题" target="_blank" rel="noopener">JavaScript中Apply调用模式的this指向问题</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-arguments类数组对象详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/05/15/arguments类数组对象详解/" class="article-date">
      <time datetime="2018-05-15T14:36:53.000Z" itemprop="datePublished">2018-05-15</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/05/15/arguments类数组对象详解/">arguments类数组对象详解</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="arguments类数组对象详解"><a href="#arguments类数组对象详解" class="headerlink" title="arguments类数组对象详解"></a>arguments类数组对象详解</h2><h4 id="arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。"><a href="#arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。" class="headerlink" title="arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。"></a>arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。</h4><p>　　它不能像数组一样，进行排序操作或者往集合里添加一个新的元素。</p>
<h4 id="所以我们经常非常频繁的找Array-prototype对象借用方法。"><a href="#所以我们经常非常频繁的找Array-prototype对象借用方法。" class="headerlink" title="所以我们经常非常频繁的找Array.prototype对象借用方法。"></a>所以我们经常非常频繁的找Array.prototype对象借用方法。</h4><p>　　像Array.prototype.slice可以把arguments转成真正的数组；想截去arguments列表中头一个元素时，又可以借用Array.prototype.shift方法。</p>
<p>　　要了解这种机制的实现原理，需要查看一下V8引擎的源码，比如Array.prototype.push：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ArrayPush</span></span>()&#123;</span><br><span class="line">	var n=TO_UINT32(this.length); //被push的对象的length</span><br><span class="line">	var m=%_ArgumentsLength(); //push的参数个数</span><br><span class="line">	<span class="keyword">for</span>(var i=0;i&lt;m;i++)&#123;</span><br><span class="line">		this[i+n]=%_Arguments(i);  //复制元素</span><br><span class="line">	&#125;</span><br><span class="line">	this.length=n+m; //修正length属性的值</span><br><span class="line">	<span class="built_in">return</span> this.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　可见Array.prototype.push实际上是一个<strong>属性复制</strong>的过程，把参数按照下标依次添加到被push的<strong>对象</strong>上面，顺便修改了这个对象的属性。所以只要是个对象，不管是数组对象还是类数组对象，都可以操作。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-CSS使用border构建图标" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/05/14/CSS使用border构建图标/" class="article-date">
      <time datetime="2018-05-14T14:58:33.000Z" itemprop="datePublished">2018-05-14</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/05/14/CSS使用border构建图标/">CSS使用border构建图标</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="CSS使用border构建图标"><a href="#CSS使用border构建图标" class="headerlink" title="CSS使用border构建图标"></a>CSS使用border构建图标</h2><h3 id="使用border画三角形"><a href="#使用border画三角形" class="headerlink" title="使用border画三角形"></a>使用border画三角形</h3><p>　　盒模型中上下左右边框交界处呈现平滑的斜线. 利用这个特点, 通过设置不同的上下左右边框宽度或者颜色可以得到小三角, 小梯形等。<a href="http://caibaojian.com/css-border-triangle.html" title="CSS三角形的实现原理及运用" target="_blank" rel="noopener">具体链接</a></p>
<h3 id="画朝上朝下的√小图标"><a href="#画朝上朝下的√小图标" class="headerlink" title="画朝上朝下的√小图标"></a>画朝上朝下的√小图标</h3><p>　　使用border可以画很多与三角形有关的东东，比如我们经常见到的向上向下的“对号图标”就是使用两层border叠加生成的。<br>  <img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/border%E5%AF%B9%E5%8F%B7%E5%B0%8F%E5%9B%BE%E6%A0%87.png?raw=true" alt="border对号小图标"></p>
<p>　　首先我们需要一个div和两个i，两个i就是用来叠加生成对号图标用的。</p>
<p>HTML:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"bottom"</span>&gt;&lt;!-- 这里换成top就是向上的对号--&gt;</span><br><span class="line">	&lt;i class=<span class="string">"arrow1"</span>&gt;&lt;/i&gt;</span><br><span class="line">	&lt;i class=<span class="string">"arrow2"</span>&gt;&lt;/i&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>CSS:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.bottom&#123;</span><br><span class="line">	width: 20px;</span><br><span class="line">	height: 20px;</span><br><span class="line">	position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow1,.bottom .arrow2&#123;</span><br><span class="line">	display: block;</span><br><span class="line">	position: absolute;</span><br><span class="line">	width: 0px;/*宽高设为0才能上下左右的border显示为三角形*/</span><br><span class="line">	height: 0px;</span><br><span class="line">	border-left: 8px dashed transparent;/*transparent主要为了应用在网页中不盖住底色*/</span><br><span class="line">	border-right: 8px dashed transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　然后下面关键的就来了，我们给第一个<em><i></i></em>只设置上边框的话在这种情况下是个三角形：<img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/border1.png?raw=true" alt="border1.png"></p>
<p>　　然后我们可以给第二个<em><i></i></em>再设置一个白色的三角形然后用绝对定位的偏移使它下移盖住灰色三角形的一部分：<img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/border2.png?raw=true" alt="border2.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.bottom .arrow1&#123;</span><br><span class="line">	border-top: 8px solid <span class="comment">#999;</span></span><br><span class="line">	border-bottom: 8px dashed transparent;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow2&#123;</span><br><span class="line">    top: -2px;</span><br><span class="line">    border-top: 8px solid <span class="comment">#fff;</span></span><br><span class="line">    border-bottom: 8px dashed transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　然后我们一开始的那个向下的对号图标就出现啦，向上同理啦，下面就是向上向下放在一起的完整版CSS。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.bottom,.top&#123;</span><br><span class="line">	width: 20px;</span><br><span class="line">	height: 20px;</span><br><span class="line">	position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow1,.bottom .arrow2,.top .arrow1,.top .arrow2&#123;</span><br><span class="line">	display: block;</span><br><span class="line">	position: absolute;</span><br><span class="line">	width: 0px;</span><br><span class="line">	height: 0px;</span><br><span class="line">	border-left: 8px dashed transparent;</span><br><span class="line">	border-right: 8px dashed transparent;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow1&#123;</span><br><span class="line">	border-top: 8px solid <span class="comment">#999;</span></span><br><span class="line">	border-bottom: 8px dashed transparent;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow2&#123;</span><br><span class="line">	top: -2px;</span><br><span class="line">	border-top: 8px solid <span class="comment">#fff;</span></span><br><span class="line">	border-bottom: 8px dashed transparent;</span><br><span class="line">&#125; </span><br><span class="line">.top .arrow1&#123;</span><br><span class="line">	border-top: 8px dashed transparent;</span><br><span class="line">	border-bottom: 8px solid <span class="comment">#999;			</span></span><br><span class="line">&#125;</span><br><span class="line">.top .arrow2&#123;</span><br><span class="line">	top: 2px;</span><br><span class="line">	border-top: 8px dashed transparent;</span><br><span class="line">	border-bottom: 8px solid <span class="comment">#fff;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-我的前端学习路线" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/05/13/我的前端学习路线/" class="article-date">
      <time datetime="2018-05-13T01:57:21.000Z" itemprop="datePublished">2018-05-13</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/05/13/我的前端学习路线/">我的前端学习路线</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="我的前端学习路线"><a href="#我的前端学习路线" class="headerlink" title="我的前端学习路线"></a>我的前端学习路线</h2><p>　　我确认往前端发展是从2018年大三的寒假开始的，因为本科由于兴趣选择了<em>数字媒体专业</em>，自然而然就往前端这边靠了。要具体说一说的话原因也非常简单：JS非常简约易上手，浏览器就是调试器，还可以用代码构建形形色色的可视化页面，完美贴合我这种半计算机半艺术的专业。</p>
<p>　　干任何事都有个起点，因为我的专业是半计算机专业，这就意味着操作系统原理、汇编、计算机网络这些CS的课程基本都没有，有了也是非常水的讲着玩玩，所以我的<strong>起点水平</strong>也就是对计算机语言的基础知识基本掌握，面向对象的原理（继承、封装、多态）了解过没怎么用过；数据结构会基本的栈、队列、排序、二叉树这些，而且还是只知道原理不会用（不过前端走到现在从没用过，基本pop(),push(),sort()什么的JS都给你封装好了）；前端相关知识HTML、CSS基本标签、属性会用，JS基本语法会用，基本DOM操作会用，jQuery了解过一点。</p>
<p>　　其它的废话我就不多说了，这里着重记录一下我的学习历程，具体分为：我的书单、网上资源。</p>
<h2 id="我的前端书单（分先后顺序，书名后跟着难度和推荐度）"><a href="#我的前端书单（分先后顺序，书名后跟着难度和推荐度）" class="headerlink" title="我的前端书单（分先后顺序，书名后跟着难度和推荐度）"></a>我的前端书单（分先后顺序，书名后跟着难度和推荐度）</h2><p>　　我从小就不爱读书，爱看电影，因为感觉书非常无聊，不如电影动态的好看，但是到了现在要学技术了，就必须看书了，不知道大家有没有过这种体验：看动画片一集的时间看漫画能看十集，所以读书而且是读技术书对于<strong>快速</strong>增长学识非常关键。</p>
<h4 id="1-《Head-First-HTML-与-CSS》-难度：0星-推荐度：3星"><a href="#1-《Head-First-HTML-与-CSS》-难度：0星-推荐度：3星" class="headerlink" title="1.《Head First HTML 与 CSS》  难度：0星  推荐度：3星"></a>1.《Head First HTML 与 CSS》  难度：0星  推荐度：3星</h4><p>　　都称作是最最基本的无脑入门书，也有一些HTML5的新内容，对于我这种零零碎碎学了些前端的人正适合当作第一本书看。</p>
<h4 id="2-《JavaScript高级程序设计》-难度：2星-推荐度：5星"><a href="#2-《JavaScript高级程序设计》-难度：2星-推荐度：5星" class="headerlink" title="2.《JavaScript高级程序设计》  难度：2星  推荐度：5星"></a>2.《JavaScript高级程序设计》  难度：2星  推荐度：5星</h4><p>　　结合了网上各类大神的推荐和自己的水平，没有去看犀牛书而是看了这本，总体感觉非常系统的带你巩固了一下JS，如果是小白建议就看完第13章事件，基本上就可以完成一些简单页面了，后面的内容什么时候用到了或对JS彻底入门了再去看即可（因为看到第13章JS才算摸到门把）。</p>
<h4 id="3-《JavaScript语言精粹》-难度：3星-推荐度：5星"><a href="#3-《JavaScript语言精粹》-难度：3星-推荐度：5星" class="headerlink" title="3.《JavaScript语言精粹》  难度：3星  推荐度：5星"></a>3.《JavaScript语言精粹》  难度：3星  推荐度：5星</h4><p>　　当时看北妈的推荐读的这本，真的是如北妈所说：“读一页相当于《JavaScript高级程序设计》的十页”，看了这本书你基本就可以对原型、继承、闭包等有深刻的了解了，吃透这本小薄书我感觉<strong>JS才算真正入门了</strong>。</p>
<h4 id="4-《图解CSS3：核心技术与开发实践》-难度：1星-推荐度：3星"><a href="#4-《图解CSS3：核心技术与开发实践》-难度：1星-推荐度：3星" class="headerlink" title="4.《图解CSS3：核心技术与开发实践》 难度：1星 推荐度：3星"></a>4.《图解CSS3：核心技术与开发实践》 难度：1星 推荐度：3星</h4><p>　　因为只是基本的CSS了解过，对CSS3并不是很了解，所以看了这本书，但因为是14年的有时候还需要看最新的CSS参考手册自己去挨个试试，总体还不错。</p>
<h4 id="5-《CSS世界》-难度：3星-推荐度：-5星"><a href="#5-《CSS世界》-难度：3星-推荐度：-5星" class="headerlink" title="5.《CSS世界》  难度：3星  推荐度： 5星"></a>5.《CSS世界》  难度：3星  推荐度： 5星</h4><p>　　很多的CSS属性你知道是什么，但你搭配起来会出现一堆奇奇GAYGAY的问题，所以这本书就帮你了解CSS各属性间的关系和深层用法，我第一遍看因为没什么项目经验所以很多也只是看了，但是没用过所以没有概念，以后做的东西多了再回来看收获更多。</p>
<h4 id="6-《JavaScript设计模式与开发实践》"><a href="#6-《JavaScript设计模式与开发实践》" class="headerlink" title="6.《JavaScript设计模式与开发实践》"></a>6.《JavaScript设计模式与开发实践》</h4><p>　　最近正在看，看完再评价。</p>
<h4 id="7-《算法》"><a href="#7-《算法》" class="headerlink" title="7.《算法》"></a>7.《算法》</h4><p>　　最近正在看，感觉还是要了解一下算法，为了找工作也好，以后实际需要也好。</p>
<h2 id="我的其它书单"><a href="#我的其它书单" class="headerlink" title="我的其它书单"></a>我的其它书单</h2><p>　　学校的那些专业课的书就不说了，只提一下看过的觉得对前端这方面有点用的书单：</p>
<h4 id="1-《3D数学基础：图形与游戏开发》-难度：2星-推荐度：-4星"><a href="#1-《3D数学基础：图形与游戏开发》-难度：2星-推荐度：-4星" class="headerlink" title="1.《3D数学基础：图形与游戏开发》  难度：2星  推荐度： 4星"></a>1.《3D数学基础：图形与游戏开发》  难度：2星  推荐度： 4星</h4><p>　　看这书会基本的C++和高中数学即可，起码能对计算机图形学的最基础有点认识了，能知道物体在3D空间是如何通过代码进行运动的了，CSS3的transform变形函数里的translate()、rotate()、scale()等与之相关很大。</p>
<h4 id="2-《图解TCP-IP》-难度：2星-推荐度：-3星"><a href="#2-《图解TCP-IP》-难度：2星-推荐度：-3星" class="headerlink" title="2.《图解TCP/IP》  难度：2星  推荐度： 3星"></a>2.《图解TCP/IP》  难度：2星  推荐度： 3星</h4><p>　　暂时为了以后与计算机网络打交道，先了解一下，但是因为很多名词从来没见过，看过了也就看过了，没有任何概念，所以现在还看不出来有什么用，只是对TCP/IP模型那些宏观上的东西有点感觉。
　　</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-JS的面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/05/13/JS的面向对象/" class="article-date">
      <time datetime="2018-05-13T01:41:52.000Z" itemprop="datePublished">2018-05-13</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/05/13/JS的面向对象/">JS的面向对象</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>　　最近刚开始看《JavaScrit设计模式与开发实践一书》，感觉着实不错，让我对JS的面向对象有了更多的认识，下面就来总结一下：</p>
<p>　　首先要了解的一点是：JavaScript是<strong>动态类型语言</strong>，与Java，C++这些<em>静态类型语言</em>不同，它无需类型检测。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>　　多态就是将“做什么”和“谁去做以及怎样去做”分离开，也就是将“不变的事物”与“可能改变的事物”分离开来，然后把不变的部分隔离出来，把可变的部分<em>封装</em>起来，这样即可实现：同一操作作用于不同的对象，可以产生不同的解释和不同的执行结果。</p>
<p>　　多态最根本的作用就是通过<strong>把过程化的条件分支语句转化为对象的多态性</strong>，从而消除这些条件分支语句。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>　　因为JavaScript没有一些语言中的public,private,protected等关键字，所以只能依赖<strong>变量的作用域</strong>来实现封装特性，而且只能模拟出public和private这两种封装性。</p>
<p>　　一般通过函数来创建作用域（如闭包就是实现了公开方法访问私有变量），但最新的ES6提供了let关键字，和Symbol创建私有属性，现在我还没看，等着一定会去了解。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>　　关于原型链继承请参考博客“JS中new运算符详解”和高程6.3节（一定要先搞懂跟new有关的构造器模式，再去看原型链）</p>
<p>　　JavaScript是一门基于原型的面向对象语言，它的对象系统就是使用<strong>原型模式</strong>来搭建的，所以它<strong>绝大部分的</strong>遵守原型编程范型的基本规则，即：</p>
<ol>
<li>绝大部分的数据都是对象</li>
<li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并<em>克隆</em>它</li>
<li>对象会记住它的原型</li>
<li>如果对象无法响应某个请求，它会把这个请求委托给它的<em>构造器的原型</em></li>
</ol>
<h4 id="1-绝大部分的数据都是对象"><a href="#1-绝大部分的数据都是对象" class="headerlink" title="1. 绝大部分的数据都是对象"></a>1. 绝大部分的数据都是对象</h4><p>　　JavaScript中的根对象是Object.prototype对象，它是一个空对象，所有的对象都是从Object.prototype对象克隆而来的，Object.prototype对象就是它们的原型。</p>
<h4 id="2-要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"><a href="#2-要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它" class="headerlink" title="2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"></a>2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</h4><p>　　JavaScript的函数既可以作为普通函数被调用，也可以被new运算符作为构造器被调用，其中的new运算符实际上就是克隆了一个原型的过程。</p>
<p>　　<strong>关于new运算符的内部具体操作请见我博客中的“JS中new运算符详解”！</strong></p>
<h4 id="3-对象会记住它的原型"><a href="#3-对象会记住它的原型" class="headerlink" title="3. 对象会记住它的原型"></a>3. 对象会记住它的原型</h4><p>　　JavaScript给对象提供了一个名为<strong>proto</strong>的隐藏属性（这是浏览器的实现，规范里应该是不可访问的[[prototype]]），该属性默认指向它的构造器的原型对象。</p>
<p>　　所以<em><strong>proto</strong></em>就是对象跟“对象构造器的原型”联系起来的纽带。</p>
<h4 id="4-如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型"><a href="#4-如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型" class="headerlink" title="4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型"></a>4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</h4><p>　　JavaScript的对象最初都是由Object.prototype对象克隆而来的，乍一看我们只能得到单一的继承自Object.prototype的对象，但<strong>对象构造器的原型</strong>并不仅限于Object.prototype上，而是可以动态指向其他对象。</p>
<p>　　所以我们一般通过设置构造器的prototype来实现原型继承：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var A=<span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">A.prototype=&#123;name:<span class="string">"Daoma666"</span>&#125;;</span><br><span class="line">var B=<span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">B.prototype=new A();</span><br><span class="line">var b=new B();</span><br><span class="line">console.log(b.name);//Daoma666</span><br></pre></td></tr></table></figure>
<p>　　在执行时，引擎做了什么事：</p>
<ol>
<li>首先尝试遍历对象b中所有属性，但没有找到name这个属性</li>
<li>查找name属性的请求被委托给对象b的构造器原型，它被b.<strong>proto</strong>记录着并且指向B.prototype，即new A()创建出来的对象，即一个指向构造器A的prototype的对象。</li>
<li>然而在该对象中依然没有找到name属性，于是请求继续委托给这个对象构造器的原型A.prototype。</li>
<li>然后在这里找到了name属性，并返回它的值</li>
</ol>
<p>　　最后我们还要注意一点，如果在A.prototype也没找到name属性时，请求会被传递给A.prototype的构造器原型Object.prototype，因为根对象是个空对象，且原型是null，所以这次请求就到此为止，b.name返回undefined。</p>
<hr>
<p>　　现在我们就能理解ECMAScript5提供的克隆对象的Object.create方法了，它天然的实现了原型继承。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.create=<span class="keyword">function</span>(obj)&#123;</span><br><span class="line">    var F=<span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">    F.prototype=obj;</span><br><span class="line">    <span class="built_in">return</span> new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　即上面的代码可以这样实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var A=<span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">A.prototype=&#123;name:<span class="string">"Daoma666"</span>&#125;;</span><br><span class="line">var b=Object.create(new A());</span><br><span class="line">console.log(b.name);//Daoma666</span><br></pre></td></tr></table></figure>
<p>　　此外还有需要注意的几点：</p>
<ol>
<li>Object.create()来创建对象比通过构造器创建对象要慢</li>
<li>设置构造器的prototype实现原型继承时，除了根对象，任何对象都会有一个原型；但通过Object.create(null)可以创建出没有原型的对象。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 岛马
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >大神到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>
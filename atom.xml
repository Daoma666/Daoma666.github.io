<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>岛马的主页</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-30T05:21:24.353Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>岛马</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS属性值的百分比</title>
    <link href="http://yoursite.com/2018/04/30/CSS%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94/"/>
    <id>http://yoursite.com/2018/04/30/CSS属性值的百分比/</id>
    <published>2018-04-30T01:32:10.000Z</published>
    <updated>2018-04-30T05:21:24.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS属性值的百分比"><a href="#CSS属性值的百分比" class="headerlink" title="CSS属性值的百分比"></a>CSS属性值的百分比</h2><p>　　经常能见到CSS属性值出现百分比，之前一直也没有整理过，现在为了以后不迷糊，遂整理一下。</p><h3 id="百分比单位"><a href="#百分比单位" class="headerlink" title="百分比单位"></a>百分比单位</h3><h4 id="乘以包含块的宽度：margin-padding-left-right-text-indent-width-max-width-min-width"><a href="#乘以包含块的宽度：margin-padding-left-right-text-indent-width-max-width-min-width" class="headerlink" title="乘以包含块的宽度：margin, padding, left, right, text-indent, width, max-width, min-width"></a>乘以包含块的宽度：margin, padding, left, right, text-indent, width, max-width, min-width</h4><p>　　其中padding的百分比值无论是水平方向还是垂直方向均是相对于<strong>包含块宽度</strong>计算的！</p><h4 id="乘以包含块的高度：top-bottom-height-max-height-min-height"><a href="#乘以包含块的高度：top-bottom-height-max-height-min-height" class="headerlink" title="乘以包含块的高度：top, bottom, height, max-height, min-height"></a>乘以包含块的高度：top, bottom, height, max-height, min-height</h4><p>　　关于<strong>包含块（containing block）</strong>的概念，不能简单地理解成是父元素。如果是静态定位和相对定位，包含块一般就是其父元素。但是对于绝对定位的元素，包含块应该是离它最近的 position 为 absolute、relative、或者 fixed 的祖先元素。对固定定位的元素，它的包含块是视口（viewport）。</p><h4 id="乘以元素-border-box-的宽度：border-radius"><a href="#乘以元素-border-box-的宽度：border-radius" class="headerlink" title="乘以元素(border-box)的宽度：border-radius"></a>乘以元素(border-box)的宽度：border-radius</h4><h4 id="乘以元素的字体大小：line-height"><a href="#乘以元素的字体大小：line-height" class="headerlink" title="乘以元素的字体大小：line-height"></a>乘以元素的字体大小：line-height</h4><h4 id="乘以元素的行高-：vertical-align"><a href="#乘以元素的行高-：vertical-align" class="headerlink" title="乘以元素的行高 ：vertical-align"></a>乘以元素的行高 ：vertical-align</h4><h4 id="background-position中的百分比单位与CSS中其它百分比单位都不一样！具体见“前端配合设计师之background-position定位图片”这篇Blog"><a href="#background-position中的百分比单位与CSS中其它百分比单位都不一样！具体见“前端配合设计师之background-position定位图片”这篇Blog" class="headerlink" title="background-position中的百分比单位与CSS中其它百分比单位都不一样！具体见“前端配合设计师之background-position定位图片”这篇Blog"></a>background-position中的百分比单位与CSS中其它百分比单位都不一样！具体见“前端配合设计师之background-position定位图片”这篇Blog</h4><h4 id="字体大小中的百分比-font-size-中的百分比值应该乘以元素所继承到的字体大小，也就是父元素的字体大小"><a href="#字体大小中的百分比-font-size-中的百分比值应该乘以元素所继承到的字体大小，也就是父元素的字体大小" class="headerlink" title="字体大小中的百分比 font-size 中的百分比值应该乘以元素所继承到的字体大小，也就是父元素的字体大小"></a>字体大小中的百分比 font-size 中的百分比值应该乘以元素所继承到的字体大小，也就是父元素的字体大小</h4><p>　　这里再提一下一个常用的字体单位em。<br>　<br>　　em——相当于当前的字体高度，称作“全身方框”（em square）。如果在 font-size 上使用这个单位，应该乘以父元素的字体大小。用在 font-size 之外的属性上，则应该乘以元素自身的字体大小。 ex——相当于字体中的”x”的高度。</p><h3 id="百分比的继承"><a href="#百分比的继承" class="headerlink" title="百分比的继承"></a>百分比的继承</h3><p>　　如果某个元素设置了百分比的属性，则后代元素继承的是计算后的值。例如： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p&#123; </span><br><span class="line">font-size: 10px;</span><br><span class="line">line-height: 120%;/*120% of <span class="string">'font-size'</span>*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　像这样那么p的子元素line-height继承到的值是 12px，而不是 line-height: 120%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS属性值的百分比&quot;&gt;&lt;a href=&quot;#CSS属性值的百分比&quot; class=&quot;headerlink&quot; title=&quot;CSS属性值的百分比&quot;&gt;&lt;/a&gt;CSS属性值的百分比&lt;/h2&gt;&lt;p&gt;　　经常能见到CSS属性值出现百分比，之前一直也没有整理过，现在为了以后不迷
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端配合设计师之background-position定位图片</title>
    <link href="http://yoursite.com/2018/04/29/%E5%89%8D%E7%AB%AF%E9%85%8D%E5%90%88%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B9%8Bbackground-position%E5%AE%9A%E4%BD%8D%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/04/29/前端配合设计师之background-position定位图片/</id>
    <published>2018-04-29T02:54:58.000Z</published>
    <updated>2018-04-30T03:32:56.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端配合设计师之background-position定位图片"><a href="#前端配合设计师之background-position定位图片" class="headerlink" title="前端配合设计师之background-position定位图片"></a>前端配合设计师之background-position定位图片</h2><p>　　我们经常遇到UI设计师把同一类部件的小图片都放在一张图片里的情况，小图片就是整图分割后的各个部分，把各个部分放在一张图片上，而不是是分别存储成单独的图片，其目的就是要<strong>减少http请求次数，节省时间和带宽</strong>。对于我们前端来说，就是要把对应的小图片应用到适当的位置，这里就需要background-position属性。</p><p>　　这里需要搞清楚关于定位的一些东西：</p><p>1.两个值前面一个是横向的定位，我们称为x轴方向定位。后面一个值是纵向的定位，我们称为y轴方向定位。<strong>如果只有一个值，那默认的就是x轴方向，这时y轴方向就默认的是上下居中对齐，也就是center</strong>。</p><h4 id="2-背景图片定位的坐标原点就是对应容器元素的“左上角”，即元素padding的外边缘。（这个值可以通过background-origin进行定义）"><a href="#2-背景图片定位的坐标原点就是对应容器元素的“左上角”，即元素padding的外边缘。（这个值可以通过background-origin进行定义）" class="headerlink" title="2.背景图片定位的坐标原点就是对应容器元素的“左上角”，即元素padding的外边缘。（这个值可以通过background-origin进行定义）"></a>2.背景图片定位的坐标原点就是对应容器元素的“左上角”，即元素padding的外边缘。（这个值可以通过background-origin进行定义）</h4><h4 id="3-x-y值分别表示背景图片的左上角顶点相对于坐标原点（也就是容器的左顶点）的值。"><a href="#3-x-y值分别表示背景图片的左上角顶点相对于坐标原点（也就是容器的左顶点）的值。" class="headerlink" title="3.x y值分别表示背景图片的左上角顶点相对于坐标原点（也就是容器的左顶点）的值。"></a>3.x y值分别表示背景图片的左上角顶点相对于坐标原点（也就是容器的左顶点）的值。</h4><p>4.x y的值可以用px或百分比来表示。</p><h4 id="5-当x-y用百分比单位时，其表现与CSS中其他的百分比单位表现都不一样。"><a href="#5-当x-y用百分比单位时，其表现与CSS中其他的百分比单位表现都不一样。" class="headerlink" title="5.当x y用百分比单位时，其表现与CSS中其他的百分比单位表现都不一样。"></a>5.当x y用百分比单位时，其表现与CSS中其他的百分比单位表现都不一样。</h4><p>　　比如一个图片：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img &#123; position: absolute; left: 100%; &#125;</span><br></pre></td></tr></table></figure></p><p>　　一定是在容器外部，但像background-position:100% 100%就是定位在容器内的右下角。</p><p>　　那background-position百分比表示的背景图片的左上角顶点对应的容器坐标位置该如何计算呢？</p><p>　　具体公式为：</p><h5 id="positionX-容器的宽度-图片的宽度-percentX"><a href="#positionX-容器的宽度-图片的宽度-percentX" class="headerlink" title="positionX = (容器的宽度-图片的宽度) * percentX;"></a>positionX = (容器的宽度-图片的宽度) * percentX;</h5><h5 id="positionY-容器的高度-图片的高度-percentY"><a href="#positionY-容器的高度-图片的高度-percentY" class="headerlink" title="positionY = (容器的高度-图片的高度) * percentY;"></a>positionY = (容器的高度-图片的高度) * percentY;</h5><p>　　然后这样算出来的positionX和positionY就是相对于上面第三条结论的x和y，这就不难懂为什么background-position:100% 100%就是定位在容器内的右下角了吧。</p><p>6、x y也可以用“left、right、top、bottom、center”这五个关键字来表示，但注意：用“left、right、top、bottom、center”来表示的时候，“应用的是对齐规则，而不是坐标规则”。x为left是表示图片的左边和容器的左边对齐，为right的时候表示图片的右边和容器的右边对齐，y为top的时候表示图片的顶部和容器的顶部对齐，为bottom时表示图片的底部和容器的底部对齐，x y等于center的时候表示居中对齐。</p><p>7、x y用百分比或者px表示的时候，其值可以为负数。我们应用坐标规则就很容易理解负数表示的意义，x为负数时候表示图片左顶点在容器左顶点的左侧，y为负数时表示图片的左顶点在容器的左定点的上方。也就是向左和向上超出容器的范围。</p><h5 id="但是这里要注意，有的情况下用百分比的负数时并不会像你想的那样向左和向上超出容器的范围，因为第5条中介绍的百分比定位规则，就算你"><a href="#但是这里要注意，有的情况下用百分比的负数时并不会像你想的那样向左和向上超出容器的范围，因为第5条中介绍的百分比定位规则，就算你" class="headerlink" title="但是这里要注意，有的情况下用百分比的负数时并不会像你想的那样向左和向上超出容器的范围，因为第5条中介绍的百分比定位规则，就算你"></a>但是这里要注意，有的情况下用百分比的负数时并不会像你想的那样向左和向上超出容器的范围，因为第5条中介绍的百分比定位规则，就算你</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-position: -50% -50%;</span><br></pre></td></tr></table></figure><p>　　图片会像background-position: 40px 10px;一样定位在容器内部，此时就可能是你<strong>图片的长度大于容器的长度</strong>导致的，因为此时：</p><h5 id="positionX-容器的宽度-图片的宽度-50-的结果是个正值"><a href="#positionX-容器的宽度-图片的宽度-50-的结果是个正值" class="headerlink" title="positionX = (容器的宽度-图片的宽度) * -50% 的结果是个正值"></a>positionX = (容器的宽度-图片的宽度) * -50% 的结果是个正值</h5><h5 id="positionY-容器的高度-图片的高度-50-的结果也是个正值"><a href="#positionY-容器的高度-图片的高度-50-的结果也是个正值" class="headerlink" title="positionY = (容器的高度-图片的高度) * -50% 的结果也是个正值"></a>positionY = (容器的高度-图片的高度) * -50% 的结果也是个正值</h5><p>　　所以就不难理解为什么会出现像background-position: 40px 10px;这样的效果了。</p><p>　　详细请参考：<a href="http://www.zhangxinxu.com/wordpress/2015/03/background-object-position-value-percent/" title="CSS &lt;position&gt;值简介理解background百分比定位" target="_blank" rel="noopener">background百分比定位<position>值简介</position></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端配合设计师之background-position定位图片&quot;&gt;&lt;a href=&quot;#前端配合设计师之background-position定位图片&quot; class=&quot;headerlink&quot; title=&quot;前端配合设计师之background-position定位图
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中sort方法详解</title>
    <link href="http://yoursite.com/2018/04/25/JS%E4%B8%ADsort%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/25/JS中sort方法详解/</id>
    <published>2018-04-25T02:42:04.000Z</published>
    <updated>2018-04-25T02:42:41.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中sort方法详解"><a href="#JS中sort方法详解" class="headerlink" title="JS中sort方法详解"></a>JS中sort方法详解</h2><p>　　sort() 方法用于对数组的元素进行排序,并返回排序后的数组。默认排序顺序是根据字符串Unicode码点(<strong>注意这里不是按ASCII编码排序</strong>，这里按Unicode编码排序要和平常两个字符串的&lt;,&gt;,&lt;=,&gt;=,一位位字符按ASCII编码排序区分开。)</p><h4 id="语法：arrayObject-sort-func-；参数func可选，规定排序顺序，必须是函数。"><a href="#语法：arrayObject-sort-func-；参数func可选，规定排序顺序，必须是函数。" class="headerlink" title="语法：arrayObject.sort(func)；参数func可选，规定排序顺序，必须是函数。"></a>语法：arrayObject.sort(func)；参数func可选，规定排序顺序，必须是函数。</h4><p>　　注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照Unicode字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。<br>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var scores = [1, 10, 21, 2]; </span><br><span class="line">scores.sort(); </span><br><span class="line">// [1, 10, 2, 21]</span><br><span class="line">// 注意10在2之前,</span><br><span class="line">// 因为在 Unicode码点 指针顺序中<span class="string">"10"</span>在<span class="string">"2"</span>之前</span><br></pre></td></tr></table></figure><p>　　如果想按照其他标准进行排序，就需要提供<strong>比较函数</strong>，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有<strong>两个参数 a 和 b</strong>，其返回值如下：</p><h4 id="如果返回一个负数，则第一个参数应该排列在前面，即在排序后的数组中-a-应该出现在-b-之前。"><a href="#如果返回一个负数，则第一个参数应该排列在前面，即在排序后的数组中-a-应该出现在-b-之前。" class="headerlink" title="如果返回一个负数，则第一个参数应该排列在前面，即在排序后的数组中 a 应该出现在 b 之前。"></a>如果返回一个负数，则第一个参数应该排列在前面，即在排序后的数组中 a 应该出现在 b 之前。</h4><h4 id="如果-返回-0，表示a-等于-b，则a-和-b-的相对位置不变。（注意这里和排序算法的稳定性有关）"><a href="#如果-返回-0，表示a-等于-b，则a-和-b-的相对位置不变。（注意这里和排序算法的稳定性有关）" class="headerlink" title="如果 返回 0，表示a 等于 b，则a 和 b 的相对位置不变。（注意这里和排序算法的稳定性有关）"></a>如果 返回 0，表示a 等于 b，则a 和 b 的相对位置不变。（注意这里和排序算法的稳定性有关）</h4><h4 id="如果返回一个正数，则第二个参数应该排列在前面。"><a href="#如果返回一个正数，则第二个参数应该排列在前面。" class="headerlink" title="如果返回一个正数，则第二个参数应该排列在前面。"></a>如果返回一个正数，则第二个参数应该排列在前面。</h4><p>　　所以，比较函数格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(a, b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b ) &#123;        // 按某种排序标准进行比较, a 小于 b</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b ) &#123;</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">// a must be equal to b</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compareNumbers(a, b) &#123;</span><br><span class="line"><span class="built_in">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　你可能还有疑问，就是为什么比较函数要放两个参数？我们可以拿V8引擎(Chrome浏览器的JS引擎)来理解。</p><p>　　V8引擎使用C++开发，如果学过一点点数据结构课的话，肯定接触过排序这一块儿，什么快速排序、插入排序、冒泡排序的，然后<strong>大部分排序算法，步骤分解之后，最细节的操作都是两个数的相互比较</strong>，Chrome浏览器用的V8引擎就使用了快速排序。下面就贴一段当年学数据结构的时候快排的代码，V8的源码肯定不是这么简单，肯定是一种复杂的经过了各种优化（比如改善了稳定性，内存等）但基本的快排就是这样：左边右边一块儿往中间排，排出一个个有序的子段，然后再一个个子段中递归的排。</p><h4 id="排序稳定性是指排序后数组中的相等值的相对位置没有改变，而不稳定性排序则会改变相等值的相对位置。"><a href="#排序稳定性是指排序后数组中的相等值的相对位置没有改变，而不稳定性排序则会改变相等值的相对位置。" class="headerlink" title="排序稳定性是指排序后数组中的相等值的相对位置没有改变，而不稳定性排序则会改变相等值的相对位置。"></a>排序稳定性是指排序后数组中的相等值的相对位置没有改变，而不稳定性排序则会改变相等值的相对位置。</h4><p>C++快速排序算法(这里是从小到大的正序算法):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int left,int right)&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">           <span class="built_in">return</span>; </span><br><span class="line">       &#125; </span><br><span class="line">       int pivot=data[left],low=left,high=right;</span><br><span class="line">       <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">           <span class="keyword">while</span>(low&lt;high &amp;&amp; data[high]&gt;=pivot)&#123;</span><br><span class="line">               high--;</span><br><span class="line">           &#125;</span><br><span class="line">           data[low]=data[high];</span><br><span class="line">           <span class="keyword">while</span>(low&lt;high &amp;&amp; data[low]&lt;=pivot)&#123;</span><br><span class="line">               low++;</span><br><span class="line">           &#125;</span><br><span class="line">           data[high]=data[low];</span><br><span class="line">       &#125;</span><br><span class="line">       data[low]=pivot;</span><br><span class="line">       quick_sort(left,low-1);</span><br><span class="line">       quick_sort(low+1,right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>　　所以这样就清楚了，我们只要设置好了比较函数func(a,b)规定了每两个数排序的正逆序，就可以对整个数组进行快速排序，但要注意的是，<strong>因为快速排序是不稳定排序，所以sort方法也是不稳定的</strong>。</p><p>　　我们还可以令<strong>对象数组</strong>排序，这里是加强版排序，首先按last排序，然后按照first排序。</p><p>JS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var s=[</span><br><span class="line">&#123;first:<span class="string">"Tom"</span>,last:<span class="string">"cruse"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Jack"</span>,last:<span class="string">"awddwa"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Aommy"</span>,last:<span class="string">"rththr"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Fuck"</span>,last:<span class="string">"ererg"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Shit"</span>,last:<span class="string">"nbnb"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Jessy"</span>,last:<span class="string">"awddwa"</span>&#125;</span><br><span class="line">];</span><br><span class="line">var by=<span class="keyword">function</span>(name,minor)&#123;</span><br><span class="line"><span class="built_in">return</span> <span class="keyword">function</span>(o,p)&#123;</span><br><span class="line">var a,b;</span><br><span class="line"><span class="keyword">if</span>(typeof o===<span class="string">'object'</span> &amp;&amp; typeof p===<span class="string">'object'</span> &amp;&amp; o &amp;&amp; p)&#123;</span><br><span class="line">a=o[name];</span><br><span class="line">b=p[name];</span><br><span class="line"><span class="keyword">if</span>(a===b)&#123;</span><br><span class="line">//这里的minor(o,p)实际上是by(<span class="string">'first'</span>)(o,p)</span><br><span class="line"><span class="built_in">return</span> typeof minor ===  <span class="string">'function'</span> ? minor(o,p) : 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(typeof a=== typeof b)&#123;</span><br><span class="line"><span class="built_in">return</span> a&lt;b?-1:1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> typeof a &lt; typeof b ? -1 : 1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">throw&#123;</span><br><span class="line">name: <span class="string">'Error'</span>,</span><br><span class="line">message: <span class="string">'Expected an object when sorting by '</span>+name</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">//因为by函数使用了闭包，这里的带两个参数的比较函数实际上是by(name)函数,即func(o,p)=by(name)(o,p)</span><br><span class="line">//一个函数当参数的时候只写函数名即可,所以写成sort(by(<span class="string">'last'</span>))就行</span><br><span class="line">s.sort(by(<span class="string">"last"</span>,by(<span class="string">"first"</span>)));</span><br><span class="line"><span class="keyword">for</span>(var i <span class="keyword">in</span> s)&#123;</span><br><span class="line">console.log(s[i].first+<span class="string">" "</span>+s[i].last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　更多关于sort()的内容，请见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" title="Array.prototype.sort()" target="_blank" rel="noopener">MDN文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中sort方法详解&quot;&gt;&lt;a href=&quot;#JS中sort方法详解&quot; class=&quot;headerlink&quot; title=&quot;JS中sort方法详解&quot;&gt;&lt;/a&gt;JS中sort方法详解&lt;/h2&gt;&lt;p&gt;　　sort() 方法用于对数组的元素进行排序,并返回排序后的数组。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>label标签和任意高度元素展开收起的骚操作</title>
    <link href="http://yoursite.com/2018/04/24/label%E6%A0%87%E7%AD%BE%E5%92%8C%E4%BB%BB%E6%84%8F%E9%AB%98%E5%BA%A6%E5%85%83%E7%B4%A0%E5%B1%95%E5%BC%80%E6%94%B6%E8%B5%B7%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/04/24/label标签和任意高度元素展开收起的骚操作/</id>
    <published>2018-04-23T23:33:57.000Z</published>
    <updated>2018-04-23T23:35:35.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="label标签和任意高度元素展开收起的骚操作"><a href="#label标签和任意高度元素展开收起的骚操作" class="headerlink" title="label标签和任意高度元素展开收起的骚操作"></a>label标签和任意高度元素展开收起的骚操作</h2><p>　　知识点和细节都写在代码里了，亲自运行一下即可。</p><p>HTML:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"check"</span> <span class="built_in">type</span>=<span class="string">"checkbox"</span>&gt;</span><br><span class="line">&lt;p&gt;:checked 选择器匹配每个已被选中的 input 元素（只用于单选按钮和复选框）。&lt;/p&gt;</span><br><span class="line">&lt;div class=<span class="string">"element"</span>&gt;</span><br><span class="line">  &lt;p&gt;若指定了label标签的<span class="keyword">for</span>属性和input标签的id属性相同的话，则可以实现两者的关联，在该例子里就是label也可以点击触发:checked&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"check"</span> class=<span class="string">"check-in"</span>&gt;更多↓&lt;/label&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"check"</span> class=<span class="string">"check-out"</span>&gt;收起↑&lt;/label&gt;</span><br></pre></td></tr></table></figure></p><p>CSS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*把复选框隐藏掉*/</span><br><span class="line">input[<span class="built_in">type</span>=<span class="string">"checkbox"</span>]&#123;</span><br><span class="line">position: absolute;</span><br><span class="line">clip: rect(0,0,0,0);/*clip属性裁剪出一个绝对定位元素的可见尺寸*/</span><br><span class="line">&#125;</span><br><span class="line">/*实现任意高度元素展开收起 的骚操作*/</span><br><span class="line">.element &#123;</span><br><span class="line">  max-height: 0;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  transition: max-height 1.25s;</span><br><span class="line">&#125;</span><br><span class="line">:checked ~ .element &#123;</span><br><span class="line">  max-height: 666px; /*一个足够大的最大高度值*/</span><br><span class="line">&#125;</span><br><span class="line">/*为了更美观，实现两个label的显示交替*/</span><br><span class="line">:checked ~ .check-in&#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">.check-out&#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">:checked ~ .check-out&#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;label标签和任意高度元素展开收起的骚操作&quot;&gt;&lt;a href=&quot;#label标签和任意高度元素展开收起的骚操作&quot; class=&quot;headerlink&quot; title=&quot;label标签和任意高度元素展开收起的骚操作&quot;&gt;&lt;/a&gt;label标签和任意高度元素展开收起的骚
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS特殊的按钮闪烁效果</title>
    <link href="http://yoursite.com/2018/04/21/CSS%E7%89%B9%E6%AE%8A%E7%9A%84%E6%8C%89%E9%92%AE%E9%97%AA%E7%83%81%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2018/04/21/CSS特殊的按钮闪烁效果/</id>
    <published>2018-04-21T02:57:49.000Z</published>
    <updated>2018-04-21T02:58:11.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS特殊的按钮闪烁效果"><a href="#CSS特殊的按钮闪烁效果" class="headerlink" title="CSS特殊的按钮闪烁效果"></a>CSS特殊的按钮闪烁效果</h2><p>　　本来想练习线性渐变做按钮的，但无意中发现了一个闪烁的效果，具体见代码</p><p>HTML:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;a href=<span class="string">"javascript:void(0)"</span> class=<span class="string">"button cyan"</span>&gt;Daoma666&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>CSS：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">body&gt;div&#123;</span><br><span class="line">text-align: center;</span><br><span class="line">display: block;</span><br><span class="line">width: 800px;</span><br><span class="line">margin: 50px auto;</span><br><span class="line">&#125;</span><br><span class="line">.button</span><br><span class="line">&#123;</span><br><span class="line">font-family: Arial,helvetica,sans-serif;</span><br><span class="line">font-size: 13px;</span><br><span class="line">color: <span class="comment">#000;</span></span><br><span class="line">text-decoration: none;</span><br><span class="line">display: inline-block;</span><br><span class="line">text-align: center;</span><br><span class="line">padding: 7px 20px 9px;</span><br><span class="line">margin: .5em .5em .5em 0;/*根据相应字体大小font-size来定，在这个类里1em=13px*/</span><br><span class="line">cursor: pointer;</span><br><span class="line">text-shadow: 0 1px 1px rgba(0,0,0,0.4);</span><br><span class="line">text-transform: capitalize;</span><br><span class="line">transition: 0.1s linear;</span><br><span class="line">&#125;</span><br><span class="line">.cyan &#123;</span><br><span class="line">background: rgb(130,207,241);</span><br><span class="line">background: -webkit-linear-gradient(to bottom,  rgba(130,207,241,1) 0%,rgba(56,174,234,1) 100%);</span><br><span class="line">background: linear-gradient(to bottom,  rgba(130,207,241,1) 0%,rgba(56,174,234,1) 100%);</span><br><span class="line">border: 1px solid <span class="comment">#3cafcf;</span></span><br><span class="line">&#125;  </span><br><span class="line">.cyan:hover &#123;</span><br><span class="line">background: rgb(153,216,244);</span><br><span class="line">/*background: -webkit-linear-gradient(to bottom,  rgba(153,216,244,1) 0%,rgba(79,183,236,1) 100%);</span><br><span class="line">background: linear-gradient(to bottom,  rgba(153,216,244,1) 0%,rgba(79,183,236,1) 100%);*/</span><br><span class="line">//原先这里的background打错了，导致渐变无效，然后就出现了闪烁效果，感觉比较抓人眼球。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS特殊的按钮闪烁效果&quot;&gt;&lt;a href=&quot;#CSS特殊的按钮闪烁效果&quot; class=&quot;headerlink&quot; title=&quot;CSS特殊的按钮闪烁效果&quot;&gt;&lt;/a&gt;CSS特殊的按钮闪烁效果&lt;/h2&gt;&lt;p&gt;　　本来想练习线性渐变做按钮的，但无意中发现了一个闪烁的效果
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中的apply()使用详解</title>
    <link href="http://yoursite.com/2018/04/18/JS%E4%B8%AD%E7%9A%84apply-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/18/JS中的apply-使用详解/</id>
    <published>2018-04-17T23:20:35.000Z</published>
    <updated>2018-04-22T02:54:10.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中的apply-使用详解"><a href="#JS中的apply-使用详解" class="headerlink" title="JS中的apply()使用详解"></a>JS中的apply()使用详解</h2><h3 id="apply-要绑定给this的值-参数数组-方法用来调用函数及扩展作用域"><a href="#apply-要绑定给this的值-参数数组-方法用来调用函数及扩展作用域" class="headerlink" title="apply(要绑定给this的值,参数数组)方法用来调用函数及扩展作用域"></a>apply(要绑定给this的值,参数数组)方法用来调用函数及扩展作用域</h3><h4 id="eg-Function-apply-obj-args-方法能接收两个参数，其中"><a href="#eg-Function-apply-obj-args-方法能接收两个参数，其中" class="headerlink" title="eg:Function.apply(obj,args)方法能接收两个参数，其中"></a>eg:Function.apply(obj,args)方法能接收两个参数，其中</h4><h4 id="obj-这个对象将代替Function函数里的this对象"><a href="#obj-这个对象将代替Function函数里的this对象" class="headerlink" title="obj:这个对象将代替Function函数里的this对象"></a>obj:这个对象将代替Function函数里的this对象</h4><h4 id="args-这个是数组，它将作为参数传给Function-args"><a href="#args-这个是数组，它将作为参数传给Function-args" class="headerlink" title="args:这个是数组，它将作为参数传给Function(args);　　"></a>args:这个是数组，它将作为参数传给Function(args);　　</h4><p>　　之前我一直从语义上蒙圈，还以为是Function调用啥啥啥，结果不是。。。而是<strong>obj.Function(args)</strong>，即obj调用Function函数并传入参数数组args。</p><h3 id="call和apply的意思一样-只不过是参数要一个一个列出来"><a href="#call和apply的意思一样-只不过是参数要一个一个列出来" class="headerlink" title="call和apply的意思一样,只不过是参数要一个一个列出来."></a>call和apply的意思一样,只不过是参数要一个一个列出来.</h3><h4 id="eg-Function-call-obj-param1-param2-…-paramN"><a href="#eg-Function-call-obj-param1-param2-…-paramN" class="headerlink" title="eg:Function.call(obj,[param1[,param2[,…[,paramN]]]])"></a>eg:Function.call(obj,[param1[,param2[,…[,paramN]]]])</h4><h4 id="obj：这个对象将代替Function函数里的this对象"><a href="#obj：这个对象将代替Function函数里的this对象" class="headerlink" title="obj：这个对象将代替Function函数里的this对象"></a>obj：这个对象将代替Function函数里的this对象</h4><h4 id="params：这个是一个参数列表"><a href="#params：这个是一个参数列表" class="headerlink" title="params：这个是一个参数列表"></a>params：这个是一个参数列表</h4><p>具体见一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Student(name,age,grade)&#123;</span><br><span class="line">Person.apply(this,arguments);</span><br><span class="line">this.grade=grade;</span><br><span class="line">&#125;</span><br><span class="line">var student=new Student(<span class="string">"MaYun"</span>,21,<span class="string">"大三"</span>);</span><br><span class="line">alert(student.name+<span class="string">" "</span>+student.age+<span class="string">" "</span>+student.grade);</span><br></pre></td></tr></table></figure></p><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>　　这里Student里虽然没有给name和age属性赋值的语句，但调用了Person构造函数。所以var student=new Student(“MaYun”,21,”大三”);new出来的Student构造函数里：</p><p>　　因为遵循<strong>构造器调用模式</strong>(new)中this被绑定到<strong>新对象</strong>(即student)，所以</p><p>　　Person.apply(this,arguments);就相当于Person.apply(student,arguments);就相当于student.Person(name,age,grade);</p><p>　　此时Person中的this.name=name;this.age=age;中的this因为属于<strong>方法调用模式</strong>被绑定到<strong>调用该方法的对象</strong>上，所以就相当于student.name=name;student.age=age;</p><h4 id="巧妙使用apply-this-args-的args参数"><a href="#巧妙使用apply-this-args-的args参数" class="headerlink" title="巧妙使用apply(this,args)的args参数"></a>巧妙使用apply(this,args)的args参数</h4><p>　　如果见到apply(null,args);这种写法，这样其实不算调用什么东东了，只是可以将一个args数组默认的转换为一个参数列表(即[param1,param2,param3] 转换为 param1,param2,param3)来传惨。</p><h3 id="比如下面的例子想得到数组中最大的一项-。"><a href="#比如下面的例子想得到数组中最大的一项-。" class="headerlink" title="比如下面的例子想得到数组中最大的一项 。"></a>比如下面的例子想得到数组中最大的一项 。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array=[50,60,70,90,100];</span><br><span class="line">var max=Math.max(array);</span><br><span class="line">alert(max); //NaN</span><br><span class="line">max=Math.max.apply(null,array);</span><br><span class="line">alert(max); //100</span><br></pre></td></tr></table></figure><p>　　因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组  </p><p>　　但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的这个特点可以得到一个数组中最大的一项  。</p><h3 id="同样的push方法没有提供push一个数组中的每一项"><a href="#同样的push方法没有提供push一个数组中的每一项" class="headerlink" title="同样的push方法没有提供push一个数组中的每一项"></a>同样的push方法没有提供push一个数组中的每一项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a1=[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</span><br><span class="line">var a2=[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</span><br><span class="line">var b=[<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>];</span><br><span class="line">a1.push(b);</span><br><span class="line">alert(a1.length);//4,即把b数组作为单个元素push了,a1=[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,[<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>]]</span><br><span class="line">Array.prototype.push.apply(a2,b);</span><br><span class="line">alert(a2.length);//6,即把b数组中的每一项都push了,a2=[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>]</span><br></pre></td></tr></table></figure><p>　　因为push方法会修改原数组，所以这里用了a1和a2两个数组来作例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中的apply-使用详解&quot;&gt;&lt;a href=&quot;#JS中的apply-使用详解&quot; class=&quot;headerlink&quot; title=&quot;JS中的apply()使用详解&quot;&gt;&lt;/a&gt;JS中的apply()使用详解&lt;/h2&gt;&lt;h3 id=&quot;apply-要绑定给this的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>闭包与模仿块作用域</title>
    <link href="http://yoursite.com/2018/04/18/%E9%97%AD%E5%8C%85%E4%B8%8E%E6%A8%A1%E4%BB%BF%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/04/18/闭包与模仿块作用域/</id>
    <published>2018-04-17T23:20:18.000Z</published>
    <updated>2018-04-22T02:59:08.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包与模仿块作用域"><a href="#闭包与模仿块作用域" class="headerlink" title="闭包与模仿块作用域"></a>闭包与模仿块作用域</h2><p>　　最近看《JavaScript语言精粹》真是一页的含量顶其它书的十页啊，受益匪浅，在这里整理一下闭包的一些东东吧。</p><p>　　首先我也忘了之前有没有整理过关于原型的一些用法，先给出一段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method=<span class="keyword">function</span>(name,func)&#123;</span><br><span class="line">this.prototype[name]=func;</span><br><span class="line"><span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　具体要是忘了的话，去看原型那节，作用是给Function对象的原型添加了一个method方法，用于往该原型里新增方法，这样继承自Function对象的子对象们都会动态更新它们的方法。</p><p>　　然后就是我们主要整理的东西了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String.method(<span class="string">"deentityify"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">var entity=&#123;</span><br><span class="line">quot: <span class="string">'"'</span>,</span><br><span class="line">lt: <span class="string">'&lt;'</span>,</span><br><span class="line">gt: <span class="string">'&gt;'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> this.replace(/&amp;([^&amp;;]+);$/g,<span class="keyword">function</span>(a,b)&#123;</span><br><span class="line">var r=entity[b];</span><br><span class="line"><span class="built_in">return</span> typeof r === <span class="string">"string"</span> ? r : a;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;());</span><br><span class="line">document.writeln(<span class="string">"&amp;lt;body&amp;gt;&amp;quot;HAHAHA&amp;quot;&amp;lt;body&amp;gt;"</span>.deentityify());//&lt;body&gt;<span class="string">"HAHAHA"</span>&lt;body&gt;</span><br></pre></td></tr></table></figure></p><p>　　这段代码的主要功能是：给String对象添加一个deentityify方法。它的任务是寻找字符串中的HTML字符实体并把它们替换为对应的字符。<br>　　这里有四个需要注意的点：</p><h4 id="1-模仿块作用域"><a href="#1-模仿块作用域" class="headerlink" title="1.模仿块作用域"></a>1.模仿块作用域</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">var s=<span class="string">"test"</span>;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>　<br>　　因为JS有函数作用域，所以函数中的参数和变量在函数外部是不可见的，在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见。</p><p>　　因为JS将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。所以最外层的把整个函数包起来的圆括号表示：将函数声明转换成函数表达式。</p><p>　　这段代码实际上定义并立即<strong>调用</strong>了一个匿名函数，其中最后的<em>()</em>圆括号是<strong>调用运算符</strong>。</p><p>　　要注意()调用运算符立刻调用了我们刚刚构造出来的函数，这个调用创建并返回的函数才是deentityify()方法，<br>　　即:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deentityify=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> this.replace(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在匿名函数中定义的任何变量，都会在执行结束时被销毁，这样就可以减少闭包占用的内存问题。</p><h4 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h4><p>　　一个<strong>函数</strong>可以访问它被创建时所处的上下文环境，这称为<strong>闭包</strong>。例子中第一个return的函数就是一个闭包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> this.replace(/&amp;([^&amp;;]+);$/g,<span class="keyword">function</span>(a,b)&#123;</span><br><span class="line">var r=entity[b];</span><br><span class="line"><span class="built_in">return</span> typeof r === <span class="string">"string"</span> ? r : a;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　上面的函数可以访问到deentityify方法上下文环境定义的entity对象，所以这个函数就可以被称作<strong>闭包</strong>。</p><h4 id="3-模块模式"><a href="#3-模块模式" class="headerlink" title="3.模块模式"></a>3.模块模式</h4><p>　　模块是一个提供接口却隐藏状态与实现的函数或对象。它利用函数作用域与闭包来创建被绑定对象与私有成员的关联，模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可访问到的地方。</p><h4 id="4-String-prototype-replace-进阶用法"><a href="#4-String-prototype-replace-进阶用法" class="headerlink" title="4.String.prototype.replace()进阶用法"></a>4.String.prototype.replace()进阶用法</h4><p>　　我这也是第一次知道它的第二个参数可以是一个函数，且非常有用，具体见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" title="replace详细用法" target="_blank" rel="noopener">MDN文档</a></p><h5 id="指定一个函数作为参数"><a href="#指定一个函数作为参数" class="headerlink" title="指定一个函数作为参数"></a>指定一个函数作为参数</h5><p>　　你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后， 该函数就会执行。 函数的<strong>返回值</strong>作为替换字符串。 (注意:上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被<strong>多次调用</strong>， 每次匹配都会被调用。</p><p>　　下面是该函数的参数：</p><p>　　变量名    　　代表的值<br>　　match    　　匹配的子串。（对应于上述的$&amp;。）<br>　　p1,p2, …　假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）<br>　　offset　　匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）<br>　　string　　被匹配的原字符串。</p><p>　　代码中的正则表达式/&amp;([^&amp;;]+);$/g代表：从整个字符串中，从全局匹配出所有的以&amp;开头，中间有1个或多个非&amp;;的任意字符，然后以;结尾的字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闭包与模仿块作用域&quot;&gt;&lt;a href=&quot;#闭包与模仿块作用域&quot; class=&quot;headerlink&quot; title=&quot;闭包与模仿块作用域&quot;&gt;&lt;/a&gt;闭包与模仿块作用域&lt;/h2&gt;&lt;p&gt;　　最近看《JavaScript语言精粹》真是一页的含量顶其它书的十页啊，受益匪浅，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="http://yoursite.com/2018/04/18/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://yoursite.com/2018/04/18/函数柯里化/</id>
    <published>2018-04-17T23:19:07.000Z</published>
    <updated>2018-04-22T02:57:44.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>　　函数柯里化Currying指的是<strong>把函数与传递给它的参数相结合，产生出一个新的函数</strong>。</p><p>　　原理：Currying通过创建一个保存着原始函数(对象)和要被套用的参数的闭包来工作。它返回另一个函数，当函数被调用时，会返回调用原始函数(对象)的结果，并传递调用curry时的参数“加上”当前调用的参数。”加上”是通过Array.concat()方法连接两个参数数组。</p><p>　　上面的原理balabala一大顿，我都没看懂，所以为了更容易懂，还是得看代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method=<span class="keyword">function</span>(name,func)&#123;</span><br><span class="line">this.prototype[name]=func;</span><br><span class="line"><span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">Function.method(<span class="string">"curry"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">var slice=Array.prototype.slice,</span><br><span class="line">args=slice.apply(arguments),</span><br><span class="line">that=this;</span><br><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> that.apply(null,args.concat(slice.apply(arguments)));</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　然后接下来我们就可以看到它运用的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(num1,num2)&#123;</span><br><span class="line"><span class="built_in">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">var add1=add.curry(1);</span><br><span class="line">alert(add1(6)); //7</span><br></pre></td></tr></table></figure><p>　　这里的method方法中，要注意四点：</p><h4 id="1-arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。"><a href="#1-arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。" class="headerlink" title="1.arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。"></a>1.arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。</h4><p>　　第一个arguments是curry()函数的参数,return里的arguments是return function()的参数，这样可能听不懂，其实在例子中就是add1()函数里的参数。</p><h4 id="2-正因为第一点，所以要想在最后使用args-concat，必须将arguments对象转换为一个真的数组，这里用Array-prototype-slice-方法，它可以将一个类数组（Array-like）对象-集合转换成一个新数组。"><a href="#2-正因为第一点，所以要想在最后使用args-concat，必须将arguments对象转换为一个真的数组，这里用Array-prototype-slice-方法，它可以将一个类数组（Array-like）对象-集合转换成一个新数组。" class="headerlink" title="2.正因为第一点，所以要想在最后使用args.concat，必须将arguments对象转换为一个真的数组，这里用Array.prototype.slice()方法，它可以将一个类数组（Array-like）对象/集合转换成一个新数组。"></a>2.正因为第一点，所以要想在最后使用args.concat，必须将arguments对象转换为一个真的数组，这里用Array.prototype.slice()方法，它可以将一个类数组（Array-like）对象/集合转换成一个新数组。</h4><p>　　具体见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" title="Array.prototype.slice()" target="_blank" rel="noopener">MDN文档</a></p><h4 id="3-第一个that-this-中的this在这里属于方法调用模式，绑定到调用该方法的对象上，即一个Function对象。"><a href="#3-第一个that-this-中的this在这里属于方法调用模式，绑定到调用该方法的对象上，即一个Function对象。" class="headerlink" title="3.第一个that=this;中的this在这里属于方法调用模式，绑定到调用该方法的对象上，即一个Function对象。"></a>3.第一个that=this;中的this在这里属于方法调用模式，绑定到调用该方法的对象上，即一个Function对象。</h4><p>　　所以add.curry(1)，this被绑定到add函数对象上</p><h4 id="4-调用函数的方法apply-要绑定给this的值-参数数组"><a href="#4-调用函数的方法apply-要绑定给this的值-参数数组" class="headerlink" title="4.调用函数的方法apply(要绑定给this的值,参数数组)"></a>4.调用函数的方法apply(要绑定给this的值,参数数组)</h4><p>　　具体可见博客中“JS中的apply()使用详解一节”。</p><p>　　最后我们再结合代码来看curry方法的具体作用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.method(<span class="string">"curry"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">//curry方法通过创建一个保存着原始函数和要被套用的参数的闭包来工作。</span><br><span class="line">var slice=Array.prototype.slice,</span><br><span class="line">args=slice.apply(arguments),  //要被套用的参数</span><br><span class="line">that=this;  //that=this保存着原始函数对象</span><br><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123; //闭包  &amp;&amp; 它返回另一个函数</span><br><span class="line"><span class="built_in">return</span> that.apply(null,args.concat(slice.apply(arguments)));</span><br><span class="line">//当函数被调用时，会返回调用原始函数的结果，并传递调用curry时的参数“加上”当前调用的参数</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　所以当执行add1(6)时，相当于执行了add.apply(null,args.concat(slice.apply(arguments))),即执行了add(curry中的参数1,自己的参数6),所以放回1+6=7.</p><p>#####　　这样就好理解柯里化的概念了：把函数与传递给它的参数相结合，产生出一个新的函数。</p><p>　　add函数使用curry(参数)方法=&gt;add.curry(参数);把函数与传递给它的参数 相结合，<br>　　产生一个新的函数add1=&gt;var add1=add.curry(1);<br>　　用处就是可以用add1函数给原函数add传参，现阶段光是理论懂了，但是不懂具体用在哪，后期一定会再补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数柯里化&quot;&gt;&lt;a href=&quot;#函数柯里化&quot; class=&quot;headerlink&quot; title=&quot;函数柯里化&quot;&gt;&lt;/a&gt;函数柯里化&lt;/h2&gt;&lt;p&gt;　　函数柯里化Currying指的是&lt;strong&gt;把函数与传递给它的参数相结合，产生出一个新的函数&lt;/strong
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>秒懂汉诺塔原理函数递归</title>
    <link href="http://yoursite.com/2018/04/15/%E7%A7%92%E6%87%82%E6%B1%89%E8%AF%BA%E5%A1%94%E5%8E%9F%E7%90%86%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2018/04/15/秒懂汉诺塔原理函数递归/</id>
    <published>2018-04-15T02:40:43.000Z</published>
    <updated>2018-04-15T10:33:45.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="秒懂汉诺塔原理函数递归"><a href="#秒懂汉诺塔原理函数递归" class="headerlink" title="秒懂汉诺塔原理函数递归"></a>秒懂汉诺塔原理函数递归</h2><p>　　想当年大一刚学C语言递归那一块儿的时候，遇到了“汉诺塔”问题，我的老天，那段时期想哭好吗，深刻的打击了我的编程热情，本身我就自觉智商不高，于是一直就没搞懂过这个问题，指导最近看了《JavaScript语言精粹》，才发现递归并没有那么难。。。我之前对于递归的了解只限于一个函数调用它自身，所以一直懵懵懂懂，现在需要重新认识一下它：</p><h3 id="递归函数是干啥用的"><a href="#递归函数是干啥用的" class="headerlink" title="递归函数是干啥用的"></a>递归函数是干啥用的</h3><p>　　递归函数就是会直接或间接调用自身的一种函数。它把一个问题分解为一组相似的子问题，每一个都用一个<em>寻常解</em>去解决。也就是说，递归用一般的方式去解决<strong>每个</strong>子问题。</p><h3 id="汉诺塔是什么"><a href="#汉诺塔是什么" class="headerlink" title="汉诺塔是什么"></a>汉诺塔是什么</h3><p>　　因为这是篇笔记，相信每个想了解汉诺塔原理的人都懂它是什么，怎么玩，但是就算你会玩，你不会写代码(大佬除外)。。。我就是从这个时候觉得自己智商比别人低的，不过这是我刚接触编程的时候。到现在接触了两三年的编程，我深感周围大佬没多少(可能因为我双非一本非计算机专业的缘故)，当初那些一看就会的人大部分接触的早O__O，人家初中高中奥数什么的早就接触啦，对于我们这种普通学生来说(我相信你要是985,211不会来看我的博客的)，大部分像我这样的人(为了不让大佬们黑我)都是学以致用的，参考别人的摸出门路了才会用，所以接下来我写的，应该都能懂。</p><h3 id="汉诺塔递归代码"><a href="#汉诺塔递归代码" class="headerlink" title="汉诺塔递归代码"></a>汉诺塔递归代码</h3><p>　　有时搜一篇资料，先看到源码，哇看不懂，再看原理，哇更不懂；也可能先看到原理，没代码我怎么会看懂，再看源码，哇原理我都看不懂看代码怎么会懂。。。所以这就陷入了死循环，至于能不能看懂，就看个人的喜好和悟性了，我的习惯是先看源码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">var hanoi=<span class="keyword">function</span>(n,src,aux,dst)&#123;</span><br><span class="line"><span class="keyword">if</span>(disc&gt;0)&#123;</span><br><span class="line">//第一步</span><br><span class="line">hanoi(n-1,src,dst,aux);</span><br><span class="line">//第二步</span><br><span class="line">document.writeln(<span class="string">"Move disc "</span>+n+<span class="string">" from "</span>+src+<span class="string">" to "</span>+dst);</span><br><span class="line">//第三步</span><br><span class="line">hanoi(n-1,aux,src,dst);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">hanoi(3,<span class="string">"Src"</span>,<span class="string">"Aux"</span>,<span class="string">"Dst"</span>);</span><br><span class="line">hanoi(4,<span class="string">"Src"</span>,<span class="string">"Aux"</span>,<span class="string">"Dst"</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure></p><h3 id="汉诺塔递归原理"><a href="#汉诺塔递归原理" class="headerlink" title="汉诺塔递归原理"></a>汉诺塔递归原理</h3><p>　　你可以发现它看上去非常的简单，一共就三步，毕竟hanoi函数就是把一堆圆盘从一根柱子移到另一根柱子，必要时使用辅助的柱子。函数的参数解释如下：<br>1.n是一开始由小到大排在src柱子上的圆盘数量<br>2.src代表起始柱子<br>3.aux(auxiliary)代表辅助柱子<br>4.dst(destination)代表目标柱子</p><p>　　hanoi函数把问题分解为了三个子问题，</p><h4 id="第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。"><a href="#第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。" class="headerlink" title="第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。"></a>第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。</h4><h4 id="第二步：移动下面最大的圆盘到目标柱子上。"><a href="#第二步：移动下面最大的圆盘到目标柱子上。" class="headerlink" title="第二步：移动下面最大的圆盘到目标柱子上。"></a>第二步：移动下面最大的圆盘到目标柱子上。</h4><h4 id="第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。"><a href="#第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。" class="headerlink" title="第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。"></a>第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。</h4><p>　　然后通过递归地调用自身(只是参数不同)去处理一对圆盘的移动，从而解决那些子问题。</p><h3 id="对递归原理的理解"><a href="#对递归原理的理解" class="headerlink" title="对递归原理的理解"></a>对递归原理的理解</h3><p>　　hanoi(3,”Src”,”Aux”,”Dst”);代表把3个圆盘<strong>从</strong>Src柱子<strong>借助</strong>Aux柱子移动<strong>到</strong>Dst柱子。每一个大问题里包含三个子问题:如果起始柱子上有盘子，先把disc-1个较小的圆盘都放到辅助柱子上，然后把较大的放到目标柱子上，最后在把那disc-1个较小的圆盘放到目标柱子上。</p><p>　　相信读到这里的人都搞懂了<strong>怎么把这个大问题分解为3个子问题</strong>，并且发现如果按着原理思路来写，即可写出代码。但是过了不一会儿你就会产生疑问，因为你大问题上懂了，但不明白为啥每个子问题都可以这么用呢？每个子问题内为什么也起作用呢？</p><p>　　所以说之前的我和现在的我差在了哪里，不是智商，而是思考的方式不对！！你是不是正在苦苦思考这段代码的每一步，然后把一步步的执行过程都写出来了，想搞懂递归呢？结果就是蛋疼！你不但啥也没搞懂，还白白浪费了这段推代码的时间！正确的打开方式是这样的——<strong>递归当然只能以递归的思路理解，把它展开纯属自讨苦吃</strong>。</p><p>　　递归思路，说白了是如下三步：</p><h4 id="1-对于问题N，如果N-1已经解决了，那么N是否很容易解决。"><a href="#1-对于问题N，如果N-1已经解决了，那么N是否很容易解决。" class="headerlink" title="1.对于问题N，如果N-1已经解决了，那么N是否很容易解决。"></a>1.对于问题N，如果N-1已经解决了，那么N是否很容易解决。</h4><p>　　举例来说，如果要把一个N层汉诺塔从src搬到dst，那么：</p><p>　　如果前N-1层可以找别人搞定，咱只管搬第N层，会不会变得非常容易？</p><p>　　你看，这一下就简单了：这时当它只有两层就好了，先把前N-1层看作一个整体，把它搬到aux；然后把最下面的第N层搬到dst；然后再把前N-1层从aux搬到dst。</p><p>　　类似的，假如接到“搬前N-1层”这个任务的是我们，怎么搬呢？</p><p>　　简单，像前东家一样，把前N-2层外包出去，我们只搬第N-1层——其实和前面讨论过的“外包N-1层，只搬第N层”完全一样嘛。</p><p>　　依此类推，一层层“外包”下去——我不管你们有多伤脑筋，反正只要你们把我外包给你的活干了，我就能干了我的活！</p><p>　　这一步就是*<em>递推</em>。</p><h6 id="注意这里的搬法：搬第N层，就需要把前N-1层搬两次-起始到辅助，辅助再到目标-，另外再把第N层搬一次-起始到目标-；"><a href="#注意这里的搬法：搬第N层，就需要把前N-1层搬两次-起始到辅助，辅助再到目标-，另外再把第N层搬一次-起始到目标-；" class="headerlink" title="注意这里的搬法：搬第N层，就需要把前N-1层搬两次(起始到辅助，辅助再到目标)，另外再把第N层搬一次(起始到目标)；"></a>注意这里的搬法：搬第N层，就需要把前N-1层搬两次(起始到辅助，辅助再到目标)，另外再把第N层搬一次(起始到目标)；</h6><h6 id="搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。"><a href="#搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。" class="headerlink" title="搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。"></a>搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。</h6><h6 id="an-2-a-n-1-1"><a href="#an-2-a-n-1-1" class="headerlink" title="an=2*a(n-1)+1"></a>an=2*a(n-1)+1</h6><h6 id="a-n-1-2-a-n-2-1"><a href="#a-n-1-2-a-n-2-1" class="headerlink" title="a(n-1)=2*a(n-2)+1"></a>a(n-1)=2*a(n-2)+1</h6><h6 id="……"><a href="#……" class="headerlink" title="……"></a>……</h6><h6 id="a2-2-a1-1"><a href="#a2-2-a1-1" class="headerlink" title="a2=2*a1+1"></a>a2=2*a1+1</h6><h6 id="a1-1"><a href="#a1-1" class="headerlink" title="a1=1"></a>a1=1</h6><h6 id="很容易知道，an需要搬2-n-1次。"><a href="#很容易知道，an需要搬2-n-1次。" class="headerlink" title="很容易知道，an需要搬2^n-1次。"></a>很容易知道，an需要搬2^n-1次。</h6><h4 id="2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。"><a href="#2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。" class="headerlink" title="2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。"></a>2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。</h4><p>　　第一层怎么搬？</p><p>　　太简单了，让搬哪搬哪。</p><p>　　换句话说，到此，<strong>递推</strong>就到了极限，简单粗暴直接做就可以了。</p><h4 id="3-既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。"><a href="#3-既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。" class="headerlink" title="3.既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。"></a>3.既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。</h4><p>　　这一步就是<strong>回归</strong>。</p><p>　　如上三步加起来，就是<strong>递归</strong>。</p><p>　　推而广之，任何问题，不管规模为N时有多复杂，只要把N-1那块“外包”给别人做之后，我们在这个基础上可以轻易完成N，那么它很可能就适合用“递归”解决。</p><p>　　那么，怎么最终确定它能不能用“递归”做呢？</p><h5 id="看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。"><a href="#看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。" class="headerlink" title="看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。"></a>看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。</h5><p>　　容易看出，<strong>“递归”其实和“数学归纳法”的思路非常像</strong>：证明N=1时成立；证明若N=n-1成立，则N=n时也成立；如上两步得证，则命题在n&gt;1时一定成立（n为自然数）。你看，我们没必要从1开始逐一验证每个自然数，只要证明了“基础条件”、再证明了“递推条件”，大自然的规律会帮我们搞定一切。</p><p>　　换句话说，只要我们：</p><h5 id="1、写程序告诉电脑“如何分解一个问题”-即把汉诺塔问题分解为如上三步"><a href="#1、写程序告诉电脑“如何分解一个问题”-即把汉诺塔问题分解为如上三步" class="headerlink" title="1、写程序告诉电脑“如何分解一个问题”(即把汉诺塔问题分解为如上三步)"></a>1、写程序告诉电脑“如何分解一个问题”(即把汉诺塔问题分解为如上三步)</h5><h5 id="2、写程序告诉电脑“当该问题分解到最简时如何处理”-即第二步中的直接把它从src移到dst"><a href="#2、写程序告诉电脑“当该问题分解到最简时如何处理”-即第二步中的直接把它从src移到dst" class="headerlink" title="2、写程序告诉电脑“当该问题分解到最简时如何处理”(即第二步中的直接把它从src移到dst)"></a>2、写程序告诉电脑“当该问题分解到最简时如何处理”(即第二步中的直接把它从src移到dst)</h5><p>　　那么，“具体如何递推、如何回归”这个简单问题就不要再操心了，电脑自己能搞定。</p><p>　　——写出问题分解方法、写出分解到最简后如何解决，这是我们的任务；把问题搞定，是电脑的任务。这就是递归的魅力。</p><p>　　正是由于这种“我提供思路你搞定细节”的特点，“一切皆递归”的函数系语言才被称为“声明式编程”（而不是必须一步一步指导电脑如何做的“命令式编程”）。</p><p><a href="https://www.zhihu.com/question/24385418,&quot;如何理解汉诺塔的递归？&quot;" target="_blank" rel="noopener">更多的关于汉诺塔递归问题可以参考</a></p><p>　　</p><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;秒懂汉诺塔原理函数递归&quot;&gt;&lt;a href=&quot;#秒懂汉诺塔原理函数递归&quot; class=&quot;headerlink&quot; title=&quot;秒懂汉诺塔原理函数递归&quot;&gt;&lt;/a&gt;秒懂汉诺塔原理函数递归&lt;/h2&gt;&lt;p&gt;　　想当年大一刚学C语言递归那一块儿的时候，遇到了“汉诺塔”问题，我
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中的取整</title>
    <link href="http://yoursite.com/2018/04/15/JS%E4%B8%AD%E7%9A%84%E5%8F%96%E6%95%B4/"/>
    <id>http://yoursite.com/2018/04/15/JS中的取整/</id>
    <published>2018-04-15T01:11:03.000Z</published>
    <updated>2018-04-15T09:11:21.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中的取整"><a href="#JS中的取整" class="headerlink" title="JS中的取整"></a>JS中的取整</h2><h3 id="Math-ceil-——-gt-天花板，向上取整"><a href="#Math-ceil-——-gt-天花板，向上取整" class="headerlink" title="Math.ceil()——&gt;天花板，向上取整"></a>Math.ceil()——&gt;天花板，向上取整</h3><p>　　-9 ——&gt; 0 ——&gt; 9，沿着这个方向无论正负都向上取整。</p><h3 id="Math-floor-——-gt-地板，向下取整"><a href="#Math-floor-——-gt-地板，向下取整" class="headerlink" title="Math.floor()——&gt;地板，向下取整"></a>Math.floor()——&gt;地板，向下取整</h3><p>　　-9 &lt;—— 0 &lt;—— 9，沿着这个方向无论正负都向下取整。</p><h3 id="如何像其它语言那样向零取整"><a href="#如何像其它语言那样向零取整" class="headerlink" title="如何像其它语言那样向零取整"></a>如何像其它语言那样向零取整</h3><p>　　先给Function.prototype添加method()方法使得该方法对所有函数可用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method=<span class="keyword">function</span>(name,func)&#123;</span><br><span class="line">this.prototype[name]=func;//方法调用模式，this绑定到该对象，即Function，再更新Function对象新增新的name属性</span><br><span class="line"><span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　然后给Number.prototype添加向零取整方法interger()，具体如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number.method(<span class="string">"integer"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> Math[this&lt;0 ? <span class="string">"ceil"</span> : <span class="string">"floor"</span>](this);</span><br><span class="line">&#125;);</span><br><span class="line">alert((-5.9).<span class="built_in">integer</span>());</span><br></pre></td></tr></table></figure></p><h3 id="Math-round-——-gt-把一个数字四舍五入为最接近的整数"><a href="#Math-round-——-gt-把一个数字四舍五入为最接近的整数" class="headerlink" title="Math.round()——&gt;把一个数字四舍五入为最接近的整数"></a>Math.round()——&gt;把一个数字四舍五入为最接近的整数</h3><p>　　正数很正常:5.4——&gt;5 , 5.5——&gt;6<br>　　负数有点小注意:-5.4——&gt;-5, -5.5——&gt;-5 , -5.51——&gt;-6</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中的取整&quot;&gt;&lt;a href=&quot;#JS中的取整&quot; class=&quot;headerlink&quot; title=&quot;JS中的取整&quot;&gt;&lt;/a&gt;JS中的取整&lt;/h2&gt;&lt;h3 id=&quot;Math-ceil-——-gt-天花板，向上取整&quot;&gt;&lt;a href=&quot;#Math-ceil-——-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阻止事件的一些操作</title>
    <link href="http://yoursite.com/2018/04/14/%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/04/14/阻止事件的一些操作/</id>
    <published>2018-04-14T03:45:12.000Z</published>
    <updated>2018-04-14T03:45:32.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阻止事件冒泡或捕获"><a href="#阻止事件冒泡或捕获" class="headerlink" title="阻止事件冒泡或捕获"></a>阻止事件冒泡或捕获</h2><p>　　有时会遇到如下情况，本元素和父层元素都有事件，但我们只想要本元素事件激活，即要阻止事件冒泡<br>HTML:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"clickBtn(event)"</span>&gt;Push Me&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">document.onclick=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">alert(<span class="string">"body"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> clickBtn(event)&#123;</span><br><span class="line">event= event ? event : window.event;</span><br><span class="line">alert(<span class="string">"button"</span>);</span><br><span class="line">event.stopPropagation();</span><br><span class="line">//event.cancelBubble=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="cancelBubble"><a href="#cancelBubble" class="headerlink" title="cancelBubble"></a>cancelBubble</h3><p>　　cancelBubble原本是IE独有，经测试发现它也可以在Chrome和Firefox中阻止冒泡，那是因为人家Chrome，Firefox 考虑周到，提供了这么一种可选的方式。 但是，cancelBubble已经不在标准中了，相信迟早它们会移除这一特性的。</p><h3 id="DOM的stopPropagation-方法"><a href="#DOM的stopPropagation-方法" class="headerlink" title="DOM的stopPropagation()方法"></a>DOM的stopPropagation()方法</h3><p>　　这是DOM层次的方法，用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。两者的区别为：<br>　　IE不支持事件捕获，因而只能取消事件冒泡，但stopPropagation()可以同时取消事件捕获和冒泡。</p><h2 id="阻止事件默认行为"><a href="#阻止事件默认行为" class="headerlink" title="阻止事件默认行为"></a>阻止事件默认行为</h2><p>　　下面是一个阻止右键菜单栏事件的小程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">document.oncontextmenu=<span class="keyword">function</span>(event)&#123;</span><br><span class="line">event= event ? event : window.event;</span><br><span class="line">/*下面这三种方法都可以*/</span><br><span class="line">//event.preventDefault();</span><br><span class="line">//event.returnValue=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="returnValue-false"><a href="#returnValue-false" class="headerlink" title="returnValue=false"></a>returnValue=false</h3><p>　　也是原本IE的方法，它也可以在它也可以在Chrome和Firefox中阻止事件默认行为。</p><h3 id="DOM的preventDefault-方法"><a href="#DOM的preventDefault-方法" class="headerlink" title="DOM的preventDefault()方法"></a>DOM的preventDefault()方法</h3><p>　　简单直观，直接阻止默认的行为，可以用在多个情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阻止事件冒泡或捕获&quot;&gt;&lt;a href=&quot;#阻止事件冒泡或捕获&quot; class=&quot;headerlink&quot; title=&quot;阻止事件冒泡或捕获&quot;&gt;&lt;/a&gt;阻止事件冒泡或捕获&lt;/h2&gt;&lt;p&gt;　　有时会遇到如下情况，本元素和父层元素都有事件，但我们只想要本元素事件激活，即要阻
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>变量提升</title>
    <link href="http://yoursite.com/2018/04/14/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>http://yoursite.com/2018/04/14/变量提升/</id>
    <published>2018-04-14T03:43:59.000Z</published>
    <updated>2018-04-30T08:28:51.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>　　最近发现了一个小问题：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x=<span class="string">"global value"</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getValue</span></span>()&#123;</span><br><span class="line">alert(x);//undefined</span><br><span class="line">var x=<span class="string">"local value"</span>;</span><br><span class="line">alert(x);//<span class="built_in">local</span> value</span><br><span class="line">&#125;</span><br><span class="line">getValue();</span><br></pre></td></tr></table></figure></p><p>　　我们可以发现第一个alert(x)结果为undefined，这就跟JS的<strong>变量提升</strong>有关系了。<br>　　var关键字声明变量，无论声明在何处，都会被视为声明在函数的<em>最顶部</em>(不在函数内即在全局作用域的最顶部)，这就是函数的<strong>变量提升</strong>。所以上面的代码实际上是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x=<span class="string">"global value"</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getValue</span></span>()&#123;</span><br><span class="line">var x; //普通的变量初始化就是undefined，所以就好理解了</span><br><span class="line">alert(x);</span><br><span class="line">var x=<span class="string">"local value"</span>;</span><br><span class="line">alert(x);</span><br><span class="line">&#125;</span><br><span class="line">getValue();</span><br></pre></td></tr></table></figure><p>　　<br>　　下面我们就来整理一下变量提升：</p><h4 id="1-我是变量声明，我会被提升在作用域顶端！"><a href="#1-我是变量声明，我会被提升在作用域顶端！" class="headerlink" title="1.我是变量声明，我会被提升在作用域顶端！"></a>1.我是变量声明，我会被提升在作用域顶端！</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br></pre></td></tr></table></figure><h4 id="2-我是变量定义，我的声明部分会被提升，赋值部分不会被提升！"><a href="#2-我是变量定义，我的声明部分会被提升，赋值部分不会被提升！" class="headerlink" title="2.我是变量定义，我的声明部分会被提升，赋值部分不会被提升！"></a>2.我是变量定义，我的声明部分会被提升，赋值部分不会被提升！</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var b=<span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><h4 id="3-我是函数定义，或者叫我函数表达式。其实我就是变量定义，只不过恰好被赋值的类型是函数，所以也只提升变量名-即提升声明部分-，不提升函数值！"><a href="#3-我是函数定义，或者叫我函数表达式。其实我就是变量定义，只不过恰好被赋值的类型是函数，所以也只提升变量名-即提升声明部分-，不提升函数值！" class="headerlink" title="3.我是函数定义，或者叫我函数表达式。其实我就是变量定义，只不过恰好被赋值的类型是函数，所以也只提升变量名(即提升声明部分)，不提升函数值！"></a>3.我是函数定义，或者叫我函数表达式。其实我就是变量定义，只不过恰好被赋值的类型是函数，所以也只提升变量名(即提升声明部分)，不提升函数值！</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var c=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">console.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-我是函数声明，所以我全部被提升了，包括函数名和函数体。另外，我的优先级比变量声明要高，名字和我相同的变量声明会被忽略！"><a href="#4-我是函数声明，所以我全部被提升了，包括函数名和函数体。另外，我的优先级比变量声明要高，名字和我相同的变量声明会被忽略！" class="headerlink" title="4.我是函数声明，所以我全部被提升了，包括函数名和函数体。另外，我的优先级比变量声明要高，名字和我相同的变量声明会被忽略！"></a>4.我是函数声明，所以我全部被提升了，包括函数名和函数体。另外，我的优先级比变量声明要高，名字和我相同的变量声明会被忽略！</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">d</span></span>()&#123;</span><br><span class="line">console.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后再补充一点，因为JS虽然有函数作用域，但没有块作用域，即函数中的参数和变量在函数外部是不可见的，而在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量提升&quot;&gt;&lt;a href=&quot;#变量提升&quot; class=&quot;headerlink&quot; title=&quot;变量提升&quot;&gt;&lt;/a&gt;变量提升&lt;/h2&gt;&lt;p&gt;　　最近发现了一个小问题：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>text-indent: -9999px;作用</title>
    <link href="http://yoursite.com/2018/04/11/text-indent-9999px-%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2018/04/11/text-indent-9999px-作用/</id>
    <published>2018-04-11T11:37:57.000Z</published>
    <updated>2018-04-11T11:38:52.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="text-indent-9999px-作用"><a href="#text-indent-9999px-作用" class="headerlink" title="text-indent: -9999px;作用"></a>text-indent: -9999px;作用</h2><p>　　最近在做星级评分系统作业时遇到了这个写法。<br>HTML:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;点击星星就能打分&lt;/span&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li class=<span class="string">""</span>&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;1&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li class=<span class="string">""</span>&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;2&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li class=<span class="string">""</span>&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;3&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li class=<span class="string">""</span>&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;4&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li class=<span class="string">""</span>&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;5&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>CSS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#star li&#123;</span></span><br><span class="line">width: 24px;</span><br><span class="line"><span class="built_in">float</span>: left;</span><br><span class="line">cursor: pointer;</span><br><span class="line">text-indent: -9999px;/*&lt;a&gt;之间有文字，有时为了搜索引擎需要,但我们实际的星星上不想要文字，则添加了这个属性隐藏它*/</span><br><span class="line">background: url(img/star.png) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　text-indent:-9999px 一般用于隐藏文字。比如LOGO 部分，因为SEO(Search Engine Optimization)搜索引擎优化 的需要，所以要有文字在，但事实上显示的时候用了图片代替，所以就要使用text-indent:-9999px; 把它从界面上隐藏掉。<br>　　text-indent 是缩进，使用9999 是为了让他的缩进足够大，大分辨率下也能缩到不见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;text-indent-9999px-作用&quot;&gt;&lt;a href=&quot;#text-indent-9999px-作用&quot; class=&quot;headerlink&quot; title=&quot;text-indent: -9999px;作用&quot;&gt;&lt;/a&gt;text-indent: -9999px;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>offsetLeft和style.left</title>
    <link href="http://yoursite.com/2018/04/11/offsetLeft%E5%92%8Cstyle-left/"/>
    <id>http://yoursite.com/2018/04/11/offsetLeft和style-left/</id>
    <published>2018-04-11T11:34:36.000Z</published>
    <updated>2018-04-11T11:41:47.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="offsetLeft和style-left"><a href="#offsetLeft和style-left" class="headerlink" title="offsetLeft和style.left"></a>offsetLeft和style.left</h2><h3 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h3><p>　　1.如果父辈元素中有定位的元素，那么就返回距离当前元素最近的定位元素边缘的距离。<br>　　2.如果父辈元素中没有定位元素，那么就返回相对于body左边缘距离。</p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>　　1. style.left 返回的是字符串，如28px，offsetLeft返回的是数值28，如果需要对取得的值进行计算，还用offsetLeft比较方便。<br>　　2. style.left是读写的，offsetLeft是只读的，所以要改变元素的位置，只能修改style.left。<br>　　3. style.left的值需要事先定义，否则取到的值为空。而且必须要定义在html里，offsetLeft的值随时可以取到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;offsetLeft和style-left&quot;&gt;&lt;a href=&quot;#offsetLeft和style-left&quot; class=&quot;headerlink&quot; title=&quot;offsetLeft和style.left&quot;&gt;&lt;/a&gt;offsetLeft和style.left&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS清空数组的方法</title>
    <link href="http://yoursite.com/2018/04/10/JS%E6%B8%85%E7%A9%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/10/JS清空数组的方法/</id>
    <published>2018-04-10T11:55:32.000Z</published>
    <updated>2018-04-10T12:09:40.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="①splice"><a href="#①splice" class="headerlink" title="①splice"></a>①splice</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4]; </span><br><span class="line">ary.splice(0); //不用写要删的长度，直接从0全删掉</span><br></pre></td></tr></table></figure><h3 id="②length-0"><a href="#②length-0" class="headerlink" title="②length=0"></a>②length=0</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4]; </span><br><span class="line">ary.length=0;</span><br></pre></td></tr></table></figure><p>　　这种方式很有意思，其它语言如Java，其数组的length是只读的，不能被赋值。而JS中则可以。</p><h3 id="③赋值为"><a href="#③赋值为" class="headerlink" title="③赋值为[]"></a>③赋值为[]</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4]; </span><br><span class="line">ary = []; // 赋值为一个空数组以达到清空原数组</span><br></pre></td></tr></table></figure><p>　　方式2 保留了数组其它属性，方式3 则未保留。很多人认为方式2的效率很高些，因为仅仅是给length重新赋值了，而方式3则重新建立个对象。经 测试 恰恰是方式3的效率高。测试代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=[];</span><br><span class="line"><span class="keyword">for</span>(var i=0;i&lt;1000000;i++)&#123;</span><br><span class="line">a.push(i);</span><br><span class="line">&#125;</span><br><span class="line">var start=new Date();</span><br><span class="line">a=[];</span><br><span class="line">var end=new Date();</span><br><span class="line">alert(end-start);</span><br></pre></td></tr></table></figure></p><p>　　可以多试几个浏览器，结果是方式3更快一点点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;①splice&quot;&gt;&lt;a href=&quot;#①splice&quot; class=&quot;headerlink&quot; title=&quot;①splice&quot;&gt;&lt;/a&gt;①splice&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内联元素和块元素</title>
    <link href="http://yoursite.com/2018/04/07/%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2018/04/07/内联元素和块元素/</id>
    <published>2018-04-07T11:12:03.000Z</published>
    <updated>2018-04-07T11:12:11.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内联元素和块元素"><a href="#内联元素和块元素" class="headerlink" title="内联元素和块元素"></a>内联元素和块元素</h2><h3 id="①块级元素-默认100-撑满外层盒子的宽度（浏览器显示区域），独占一行，垂直排列，里能用行内元素，可以设置宽高"><a href="#①块级元素-默认100-撑满外层盒子的宽度（浏览器显示区域），独占一行，垂直排列，里能用行内元素，可以设置宽高" class="headerlink" title="①块级元素:默认100%撑满外层盒子的宽度（浏览器显示区域），独占一行，垂直排列，里能用行内元素，可以设置宽高"></a>①块级元素:默认100%撑满外层盒子的宽度（浏览器显示区域），独占一行，垂直排列，里能用行内元素，可以设置宽高</h3><p>　　|–&gt;div 没有任何CSS属性（主要用在大框架）<br>　　|–&gt;p     自带上下外边据  （用在段落）<br>　　|–&gt;h1-h6   自带上下外边据，自带字体大小（用在栏目大标题）<br>　　|–&gt;ul li       自带上下外边据，li自带圆点 （用在列表，多个元素大小一致）<br>　　|–&gt;dl dt dd   用在带标题的列表上 </p><h3 id="②行内元素（内联元素）-默认宽度只有本身所占的宽度，默认水平排列，不支持宽高-，margin-padding左右有效果-上下没有效果"><a href="#②行内元素（内联元素）-默认宽度只有本身所占的宽度，默认水平排列，不支持宽高-，margin-padding左右有效果-上下没有效果" class="headerlink" title="②行内元素（内联元素）:默认宽度只有本身所占的宽度，默认水平排列，不支持宽高 ，margin padding左右有效果 上下没有效果"></a>②行内元素（内联元素）:默认宽度只有本身所占的宽度，默认水平排列，不支持宽高 ，margin padding左右有效果 上下没有效果</h3><p>　　|–&gt;a  超链接  自带标签颜色、鼠标放上颜色，点击时的颜色，点击过颜色，下划线<br>　　|–&gt; span<br>　　|–&gt;em、i（默认斜体）<br>　　|–&gt;strong,b（默认加粗）<br>　　|–&gt;u（默认下划线）</p><h3 id="③行内块级元素-默认宽度只有本身所占的宽度，默认水平排列，支持宽高，受到父级text-align影响，可以居中"><a href="#③行内块级元素-默认宽度只有本身所占的宽度，默认水平排列，支持宽高，受到父级text-align影响，可以居中" class="headerlink" title="③行内块级元素:默认宽度只有本身所占的宽度，默认水平排列，支持宽高，受到父级text-align影响，可以居中"></a>③行内块级元素:默认宽度只有本身所占的宽度，默认水平排列，支持宽高，受到父级text-align影响，可以居中</h3><p>　　|–&gt;img 图片<br>　　|–&gt;input 输入框<br>　　|–&gt;select  下拉菜单<br>　　|–&gt;textarea 输入区域</p><p>IE6—————-BUG———————-<br>块级元素转化成行内块级元素   IE6不支持<br>行内元素转化成行内块级元素 IE6支持</p><p>块级元素加上position:absolute fixed（定位）或者浮动 宽度不是100% 是本身内容的宽度<br>行内元素加上position:absolute fixed（定位）或者浮动  就会变成块级元素</p><h2 id="display-block-display-inline-和display-inline-block"><a href="#display-block-display-inline-和display-inline-block" class="headerlink" title="display:block; display:inline;和display:inline-block;"></a>display:block; display:inline;和display:inline-block;</h2><h3 id="block：使用此属性后，元素会被显示为块级元素，元素会进行换行，默认宽度为撑满外层盒子的宽度-因为块元素霸道-。"><a href="#block：使用此属性后，元素会被显示为块级元素，元素会进行换行，默认宽度为撑满外层盒子的宽度-因为块元素霸道-。" class="headerlink" title="block：使用此属性后，元素会被显示为块级元素，元素会进行换行，默认宽度为撑满外层盒子的宽度(因为块元素霸道)。"></a>block：使用此属性后，元素会被显示为块级元素，元素会进行换行，默认宽度为撑满外层盒子的宽度(因为块元素霸道)。</h3><h3 id="inline：使用此属性后，元素会被显示为内联元素，元素则不会换行，默认宽度为内容的宽度。"><a href="#inline：使用此属性后，元素会被显示为内联元素，元素则不会换行，默认宽度为内容的宽度。" class="headerlink" title="inline：使用此属性后，元素会被显示为内联元素，元素则不会换行，默认宽度为内容的宽度。"></a>inline：使用此属性后，元素会被显示为内联元素，元素则不会换行，默认宽度为内容的宽度。</h3><h3 id="inline-block：是使元素以块级元素的形式呈现在行内。意思就是说，让这个元素显示在同一行不换行，但是又可以控制高度和宽度，这相当于行内元素的增强。"><a href="#inline-block：是使元素以块级元素的形式呈现在行内。意思就是说，让这个元素显示在同一行不换行，但是又可以控制高度和宽度，这相当于行内元素的增强。" class="headerlink" title="inline-block：是使元素以块级元素的形式呈现在行内。意思就是说，让这个元素显示在同一行不换行，但是又可以控制高度和宽度，这相当于行内元素的增强。"></a>inline-block：是使元素以块级元素的形式呈现在行内。意思就是说，让这个元素显示在同一行不换行，但是又可以控制高度和宽度，这相当于行内元素的增强。</h3><p>　　应用：<br>　　1.display:inline-block把一个元素变成块级元素，但他的大小只是他本身内容的大小并不撑满外围盒子，如下图所示：<br>　　<img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/img/display.jpg" alt="图片放在GitHub仓库里了也显示不出来...">所以在一道练习中出现下面的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;手写&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure></p><p>　　若不把a变成块元素，则a上的背景不会撑满整个li。</p><p>　　2.li是块元素，原本会换行，是竖着一列的布局，但改为inline-block并在父元素指定了width后，则会以块级元素的形式呈现在行内，不换行，但能控制高度宽度，这样就可以变成一行行排列的布局了。</p><h2 id="css属性"><a href="#css属性" class="headerlink" title="css属性"></a>css属性</h2><p>　　| ———-①盒子模型：width、height，padding、border、margin<br> 　　　注意事项：padding 上下左右 全部相加       margin 上下取最大  左右相加     margin-top如想父级元素不受影响，父级元素要加overflow:hidden<br>　　| ———-②-1 背景相关：background背景缩写:background-color,background-image,background-repeat,background-attachment,background-position<br>　　| ———-②-2 文本样式：font-size文字大小/line-height行高、color文本颜色、text-align水平位置、font-family文字字体、letter-spcing文字间隔、text-decoration文本样式<br>　　| ———-②-3 UL li：list-style列表样式<br>　　| ———-②-4 A链接：a{}<br>　　　　a:link - 普通的、未被访问的链接<br>　　　　a:visited - 用户已访问的链接<br>　　　　a:hover - 鼠标指针位于链接的上方<br>　　　　a:active - 链接被点击的时刻<br>　　| ———-③选择器    style 优先级最高  |   ID选择器   #xxx  id=”xxx”  |  类选择器 .xxx  class=”xxx”  |   元素选择器   p  | 后代选择器   .xxx .yyy<br>　　| ———-④定位        float（浮动）  position（定位）：relative（相对）absolute（绝对）fixed（相对浏览器固定）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内联元素和块元素&quot;&gt;&lt;a href=&quot;#内联元素和块元素&quot; class=&quot;headerlink&quot; title=&quot;内联元素和块元素&quot;&gt;&lt;/a&gt;内联元素和块元素&lt;/h2&gt;&lt;h3 id=&quot;①块级元素-默认100-撑满外层盒子的宽度（浏览器显示区域），独占一行，垂直排列，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>定位与浮动</title>
    <link href="http://yoursite.com/2018/04/07/%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/04/07/定位与浮动/</id>
    <published>2018-04-07T09:30:27.000Z</published>
    <updated>2018-04-29T02:23:13.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元素加上浮动float后的影响"><a href="#元素加上浮动float后的影响" class="headerlink" title="元素加上浮动float后的影响"></a>元素加上浮动float后的影响</h2><p>　　0.float设计初衷就是为了实现文字环绕效果，<a href="http://www.cnblogs.com/liyunhua/p/4670908.html" title="你所不了解的float(滥用float的怪异现象)" target="_blank" rel="noopener">详情请见</a><br>　　1.浮动的参考对象：浮动的框可以向左或向右移动，直到它的外边缘碰到<strong>包含框</strong>或<strong>另一个浮动框的边框</strong>为止。<br>　　2.父级元素受影响：该元素脱离文档流，使父级元素高度消失，在父级元素上加overflow:hidden 或 加height 或在父级元素上加一个clearfix类来修复父级元素的高度 (content 属性与 :before 及 :after 伪元素配合使用，定义元素之前或之后放置的生成内容。其中\0020是空格的转义字符，一般直接写空格就行)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before, .clearfix:after &#123; content: <span class="string">"\0020"</span>; display: block; height: 0; overflow: hidden; &#125;  </span><br><span class="line">.clearfix:after &#123; clear: both; &#125;  </span><br><span class="line">.clearfix &#123; zoom: 1; &#125;</span><br></pre></td></tr></table></figure></p><p>　　3.设置了float的元素,<strong>脱离了文档流，但没有脱离文本流</strong>。也就是说当它后面还有元素时，其他元素会无视它所占据了的区域，直接在它身下布局。但是文字却会认同浮动元素所占据的区域，围绕它布局。<br>　　4.同级不加浮动的元素受影响：正常没加浮动的文档流元素，会无视该浮动元素   在没加浮动的元素上加 clear:both 来修复该元素上面浮动元素所占的高度</p><h2 id="定位详解"><a href="#定位详解" class="headerlink" title="定位详解"></a>定位详解</h2><p>　　值    　　　　　　描述<br>　　static    　　　　默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。<br>　　relative　　　位置被设置为 relative 的元素，可将其移至<strong>相对于其本身</strong>正常位置的地方，因此 “left:20” 会将元素移至元素正常位置左边 20 个像素的位置。<br>　　absolute　　位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 <strong>“left”、”top”、”right” 以及 “bottom” 属性</strong>来规定。<br>　　fixed　　　　位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及”bottom” 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。</p><h3 id="扩充详解-position-absolute"><a href="#扩充详解-position-absolute" class="headerlink" title="扩充详解　position:absolute"></a>扩充详解　position:absolute</h3><p>　　这个顾名思义是绝对布局，在元素中设置之后，该元素会完全脱离文档流，它并不是相对于浏览器进行定位，<strong>而是一层一层向上寻找父元素，直到寻找到第一个position不为static的祖先元素，它相对于这个祖先元素进行定位。</strong><br>　　所以当你的父元素position:relative时，该子元素才会相对于你的父元素进行定位。如果任何一个祖先元素都没有设置position:relative，寻找到最外层的顶级元素html后自然不会继续寻找，所以这时才是相对于浏览器进行定位。<br>　　我们可以看一个小例子：<br>HTML:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">&lt;div id=<span class="string">"inner"</span>&gt;</span><br><span class="line">&lt;div id=<span class="string">"deepinner"</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>CSS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#outer&#123;</span></span><br><span class="line">width: 500px;</span><br><span class="line">height: 500px;</span><br><span class="line">border: 1px solid <span class="comment">#000;</span></span><br><span class="line">margin-left:100px;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#inner&#123;</span></span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">position: absolute;</span><br><span class="line">border: 1px solid red;</span><br><span class="line">left: 100px;</span><br><span class="line">top: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#deepinner&#123;</span></span><br><span class="line">width:100px;</span><br><span class="line">height: 100px;</span><br><span class="line">position: absolute;</span><br><span class="line">border: 1px solid red;</span><br><span class="line">left: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　可以发现deepinner层相对与inner层偏移了50px，所以可以证明absolute是<strong>一层一层向上寻找父元素，直到寻找到第一个position不为static的祖先元素，它相对于这个祖先元素进行定位。</strong>，这里deepinner层相对的就是inner层。</p><h3 id="元素加上absolute和fixed后的影响"><a href="#元素加上absolute和fixed后的影响" class="headerlink" title="元素加上absolute和fixed后的影响"></a>元素加上absolute和fixed后的影响</h3><p>　　1.宽度改变：该元素宽度变成设置的宽度，如果无则是内部元素所占的宽度   可以加宽度修复，也可以不加，就使用自身内容大小<br>　　2.元素类型改变：内联元素可以变成块级元素。<br>　　3.文档流影响：元素完全脱离文档流，<strong>同级的定位，后写的在上层</strong>，可以通过<strong>z-index属性</strong>来解决层级问题</p><h4 id="z-index可能出现的问题"><a href="#z-index可能出现的问题" class="headerlink" title="z-index可能出现的问题"></a>z-index可能出现的问题</h4><p>　　有时候可能会出现明明设置了absolute，z-index也设置的很大，但显示还是在另一个层的下面的情况，这时候就要注意这个节点所在树的第一个relative属性的父标签的z-index是不是太小,比如虽然图片所在div当前的层级很高，但是由于老爸的老爸不顶用，可怜了z-index=9999;如此强势的孩子也没有出头之日啊！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;元素加上浮动float后的影响&quot;&gt;&lt;a href=&quot;#元素加上浮动float后的影响&quot; class=&quot;headerlink&quot; title=&quot;元素加上浮动float后的影响&quot;&gt;&lt;/a&gt;元素加上浮动float后的影响&lt;/h2&gt;&lt;p&gt;　　0.float设计初衷就是为了实
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中style,currentStyle和getComputedStyle的区别以及获取css操作方法</title>
    <link href="http://yoursite.com/2018/04/06/JS%E4%B8%ADstyle-currentStyle%E5%92%8CgetComputedStyle%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E8%8E%B7%E5%8F%96css%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/06/JS中style-currentStyle和getComputedStyle的区别以及获取css操作方法/</id>
    <published>2018-04-06T08:55:16.000Z</published>
    <updated>2018-04-06T09:43:12.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中style-currentStyle和getComputedStyle的区别以及获取css操作方法"><a href="#JS中style-currentStyle和getComputedStyle的区别以及获取css操作方法" class="headerlink" title="JS中style,currentStyle和getComputedStyle的区别以及获取css操作方法"></a>JS中style,currentStyle和getComputedStyle的区别以及获取css操作方法</h2><p>　　首先需要了解CSS的三种使用方法：<br>　　1.行内样式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;css行内样式&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div style=<span class="string">"width:100px;height:100px;background:red;"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>　　2.内嵌样式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;css内嵌样式&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line"><span class="comment">#div&#123;width:100px;height:100px;background:red;&#125;</span></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div id=<span class="string">"div"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>　　3.外部样式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;css内嵌样式&lt;/title&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"XX.css"</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">"div"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>　　最近做了个小练习，点击h2想让ul元素在隐藏和显示中切换，但发现第一次点击总是无效，必须点到第二下以后才有想要的效果<br>HTML:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;播放列表...&lt;/h2&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;玩家之徒 - 蔡依林&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;原谅我就是这样的女生 - 戴佩妮&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;猜不透 - 丁当&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;自导自演 - 周杰伦&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;浪漫窝 - 弦子&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;流年 - 王菲&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>JS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var oUl=document.getElementsByTagName(<span class="string">"UL"</span>)[0];</span><br><span class="line">var oH2=document.getElementsByTagName(<span class="string">"H2"</span>)[0];</span><br><span class="line">oH2.onclick=<span class="keyword">function</span>(event)&#123;</span><br><span class="line">oUl.style.display=oUl.style.display==<span class="string">"block"</span>?<span class="string">"none"</span>:<span class="string">"block"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　原因为我以为ul默认为display:block; JS中的oUl.style.display能获取到block这个样式，但其实不然，<strong>js的style属性只能获取行内样式</strong>,所以一开始oUl.style.display=undefined，自然就不会第一下点击就隐藏了。<br>　　解决方法是:在行内直接写入样式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul style=<span class="string">"display: block;"</span>&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>　　这样就能获取到了，所以在这里做一个总结：</p><h3 id="①style-各大浏览器都兼容-能设置样式和获取样式-但是获取不了外部样式-如果写了行内没有的样式-返回的是空值"><a href="#①style-各大浏览器都兼容-能设置样式和获取样式-但是获取不了外部样式-如果写了行内没有的样式-返回的是空值" class="headerlink" title="①style:各大浏览器都兼容,能设置样式和获取样式,但是获取不了外部样式,如果写了行内没有的样式,返回的是空值"></a>①style:各大浏览器都兼容,能设置样式和获取样式,但是获取不了外部样式,如果写了行内没有的样式,返回的是空值</h3><p>　　写法:ele.style.attr(获取),ele.style.attr=”值”(设置);<br>　　注意只是获取不了外部样式，但可以设置外部样式。</p><h3 id="currentStyle属性和getComputedStyle属性不能设置属性-只能获取"><a href="#currentStyle属性和getComputedStyle属性不能设置属性-只能获取" class="headerlink" title="currentStyle属性和getComputedStyle属性不能设置属性,只能获取"></a>currentStyle属性和getComputedStyle属性不能设置属性,只能获取</h3><h3 id="②currentStyle-该属性只兼容IE-不兼容火狐和谷歌"><a href="#②currentStyle-该属性只兼容IE-不兼容火狐和谷歌" class="headerlink" title="②currentStyle:该属性只兼容IE,不兼容火狐和谷歌"></a>②currentStyle:该属性只兼容IE,不兼容火狐和谷歌</h3><p>　　写法:ele.currentStyle[“attr”]或者ele.currentStyle.attr;</p><h3 id="③getComputedStyle-该属性是兼容火狐谷歌-不兼容IE9-0一下版本"><a href="#③getComputedStyle-该属性是兼容火狐谷歌-不兼容IE9-0一下版本" class="headerlink" title="③getComputedStyle:该属性是兼容火狐谷歌,不兼容IE9.0一下版本"></a>③getComputedStyle:该属性是兼容火狐谷歌,不兼容IE9.0一下版本</h3><p>　　写法:window.getComputedStyle(ele,null)[attr]获取是window.getComputedStyle(ele,null).attr</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中style-currentStyle和getComputedStyle的区别以及获取css操作方法&quot;&gt;&lt;a href=&quot;#JS中style-currentStyle和getComputedStyle的区别以及获取css操作方法&quot; class=&quot;headerl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网页导航栏小技巧</title>
    <link href="http://yoursite.com/2018/04/03/%E7%BD%91%E9%A1%B5%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/04/03/网页导航栏小技巧/</id>
    <published>2018-04-03T14:24:25.000Z</published>
    <updated>2018-04-05T09:08:09.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用li-a构建网页导航栏"><a href="#使用li-a构建网页导航栏" class="headerlink" title="使用li+a构建网页导航栏"></a>使用li+a构建网页导航栏</h2><p>　　首先说一下建导航栏时使用li+a而不是直接使用li的原因：一般导航都是具有超链接功能，a标签具有这个功能，而lis标签只是罗列信息列表，不具备链接功能。<br>　　方法：一般我们在li中指定width，float;然后在a中使用display:block;再指定width和height，让它自动填充li即可。<br>　　具体小例子见代码：<br>HTML：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"nav"</span>&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;站长之家&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;行业资讯&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;站长在线&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;网站运营&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;设计在线&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;网络编程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;联盟资讯&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=<span class="string">"javascript:;"</span>&gt;服务器&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>CSS：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nav&#123;</span></span><br><span class="line">width: 730px;</span><br><span class="line">margin: 20px auto;</span><br><span class="line">border:1px solid blue;</span><br><span class="line">background: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#nav ul&#123;</span></span><br><span class="line">list-style-type: none;</span><br><span class="line">overflow: hidden;</span><br><span class="line">margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#nav ul li&#123;</span></span><br><span class="line">width: 80px;</span><br><span class="line"><span class="built_in">float</span>: left;</span><br><span class="line">margin-right: 10px;</span><br><span class="line">background: cornflowerblue;</span><br><span class="line">cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#nav ul li a&#123;</span></span><br><span class="line">display: block;</span><br><span class="line">width: 80px;</span><br><span class="line">height: 30px;</span><br><span class="line">line-height: 30px;</span><br><span class="line">padding: 5px 0;</span><br><span class="line">text-align: center;</span><br><span class="line">text-decoration: none;</span><br><span class="line">color: <span class="comment">#fff;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#nav ul li a:hover&#123;</span></span><br><span class="line">font-weight: 700;</span><br><span class="line">background: <span class="comment">#aaa;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　麻雀虽小五脏俱全啊，涵盖了很多最近学到的知识点，算是在此纪念一下吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用li-a构建网页导航栏&quot;&gt;&lt;a href=&quot;#使用li-a构建网页导航栏&quot; class=&quot;headerlink&quot; title=&quot;使用li+a构建网页导航栏&quot;&gt;&lt;/a&gt;使用li+a构建网页导航栏&lt;/h2&gt;&lt;p&gt;　　首先说一下建导航栏时使用li+a而不是直接使用l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式摸门把级整理</title>
    <link href="http://yoursite.com/2018/04/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%91%B8%E9%97%A8%E6%8A%8A%E7%BA%A7%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/02/正则表达式摸门把级整理/</id>
    <published>2018-04-02T12:45:27.000Z</published>
    <updated>2018-04-30T08:04:04.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="①常用的元字符-一些有特异功能的用来方便匹配的字符"><a href="#①常用的元字符-一些有特异功能的用来方便匹配的字符" class="headerlink" title="①常用的元字符 (一些有特异功能的用来方便匹配的字符)"></a>①常用的元字符 (一些有特异功能的用来方便匹配的字符)</h3><p>　　代码　　说明<br>　　.    　　匹配除换行符以外的任意字符<br>　　\w　　匹配字母或数字或下划线或汉字<br>　　\s　　匹配任意的空白符<br>　　\d　　匹配数字<br>　　\b　　匹配单词的开始或结束<br>　　^    　　匹配字符串的开始<br>　　$    　　匹配字符串的结束</p><p>　　^\d{5,12}$　　因为使用了^和$，所以检测的整个字符串都要用来和\d{5,12}来匹配，也就是说整个字符串必须是5到12个数字。</p><h3 id="②常用的限定符-表示它前面的字符重复的次数"><a href="#②常用的限定符-表示它前面的字符重复的次数" class="headerlink" title="②常用的限定符 (表示它前面的字符重复的次数)"></a>②常用的限定符 (表示它前面的字符重复的次数)</h3><p>　　代码　　说明<br>　　*    　　重复零次或更多次<br>　　+    　　重复一次或更多次<br>　　?    　　重复零次或一次<br>　　{n}　　重复n次<br>　　{n,}　　重复n次或更多次<br>　　{n,m}    　重复n到m次</p><p>　　(?0\d{2}[) -]?\d{8}　　首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现0次或1次(?)，最后是8个数字(\d{8})。</p><h3 id="③字符范围"><a href="#③字符范围" class="headerlink" title="③字符范围"></a>③字符范围</h3><p>　　代码　　说明<br>　　[]　　　　匹配方括号中任意字符<br>　　[0-9]　　代表的含意与\d就是完全一致的：匹配任意一位数字</p><p>　　注意在字符范围中有很多元字符不需要转义，可以代表自身，如.?+等。常见在[]内需要转义的有<strong>\和]和-</strong></p><h3 id="④分枝条件"><a href="#④分枝条件" class="headerlink" title="④分枝条件"></a>④分枝条件</h3><p>　　代码　　说明<br>　　|　　　　匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。<br>　　<br>　　\d{5}-\d{4}|\d{5}　　这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。</p><h3 id="⑤分组"><a href="#⑤分组" class="headerlink" title="⑤分组"></a>⑤分组</h3><p>　　代码　　说明<br>　　()　　重复单个字符,直接在字符后面加上限定符就行了；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了</p><p>　　(\d{1,3}.){3}\d{1,3}　　是一个简单的IP地址匹配表达式。  \d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</p><p>　　但使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：　　</p><h4 id="常用分组语法"><a href="#常用分组语法" class="headerlink" title="常用分组语法"></a>常用分组语法</h4><p>　　分类    　　代码/语法    　　说明<br>　　捕获    　　(exp)    　　　　匹配exp,并捕获文本到自动命名的组里<br>　　　　　　(?<name>exp)    　　　　匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)<br>　　　　　　(?:exp)    　　　匹配exp,<strong>不捕获</strong>匹配的文本，也不给此分组分配组号<br>　　零宽断言　(?=exp)    　　匹配exp前面的位置<strong>(断言：是真的才执行。所以在这里是exp才会匹配它前面的字符)</strong><br>　　　　　　　(?&lt;=exp)    　匹配exp后面的位置<br>　　　　　　　(?!exp)    　　匹配后面跟的不是exp的位置<br>　　　　　　　(?&lt;!exp)    　　匹配前面不是exp的位置<br>　　注释    　　(?#comment)　　这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</name></p><h3 id="⑥反义"><a href="#⑥反义" class="headerlink" title="⑥反义"></a>⑥反义</h3><p>　　代码/语法    说明<br>　　\W　　　　匹配任意不是字母，数字，下划线，汉字的字符<br>　　\S　　　　匹配任意不是空白符的字符<br>　　\D　　　　匹配任意非数字的字符<br>　　\B　　　　匹配不是单词开头或结束的位置<br>　　[^x]　　　　匹配除了x以外的任意字符<br>　　[^aeiou]　　　　匹配除了aeiou这几个字母以外的任意字符</p><p>　　&lt;a[^&gt;]+&gt;　　匹配用尖括号括起来的以a开头的字符串。</p><h3 id="⑦零宽断言"><a href="#⑦零宽断言" class="headerlink" title="⑦零宽断言"></a>⑦零宽断言</h3><h2 id="JS中有两种方式创建正则表达式对象-eg-下面创建一个匹配字符串的正则表达式对象"><a href="#JS中有两种方式创建正则表达式对象-eg-下面创建一个匹配字符串的正则表达式对象" class="headerlink" title="JS中有两种方式创建正则表达式对象,eg:下面创建一个匹配字符串的正则表达式对象"></a>JS中有两种方式创建正则表达式对象,eg:下面创建一个匹配字符串的正则表达式对象</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//一、正则表达式字面量方法</span><br><span class="line">var my_regexp1=/<span class="string">"(?:\\.|[^\\\"])*"</span>/g;</span><br><span class="line">//二、RegExp构造器方法(此时有两个阶段，先经过字符串的转义，然后再经过正则表达式的转义，所以经常需要双反斜杠进行转义)</span><br><span class="line">var my_regexp2=new RegExp(<span class="string">"\"(?:\\\\.|[^\\\\\\\"])*"</span>,<span class="string">"g"</span>);</span><br><span class="line">document.writeln(my_regexp1.exec(<span class="string">'"Daoma is 666"'</span>)[0]);</span><br><span class="line">document.writeln(my_regexp2.exec(<span class="string">'"Daoma "is 666"'</span>)[0]);</span><br></pre></td></tr></table></figure><p>　　其它具体请参考：<a href="http://www.jb51.net/tools/zhengze.html" title="快速入门正则表达式" target="_blank" rel="noopener">快速入门正则表达式</a><br>　　有人推荐看看《精通正则表达式》一书，我等着看看再说</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;①常用的元字符-一些有特异功能的用来方便匹配的字符&quot;&gt;&lt;a href=&quot;#①常用的元字符-一些有特异功能的用来方便匹配的字符&quot; class=&quot;headerlink&quot; title=&quot;①常用的元字符 (一些有特异功能的用来方便匹配的字符)&quot;&gt;&lt;/a&gt;①常用的元字符 (
      
    
    </summary>
    
    
  </entry>
  
</feed>

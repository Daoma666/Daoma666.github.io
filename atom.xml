<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>岛马的主页</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-31T12:57:03.584Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>岛马</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS中的数值运算</title>
    <link href="http://yoursite.com/2018/05/31/JS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2018/05/31/JS中的数值运算/</id>
    <published>2018-05-30T23:39:02.000Z</published>
    <updated>2018-05-31T12:57:03.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虽然有不少坑但是比较可靠的parseInt"><a href="#虽然有不少坑但是比较可靠的parseInt" class="headerlink" title="虽然有不少坑但是比较可靠的parseInt"></a>虽然有不少坑但是比较可靠的parseInt</h2><h4 id="Number-parseInt-string-radix-默认接收两个参数"><a href="#Number-parseInt-string-radix-默认接收两个参数" class="headerlink" title="Number.parseInt(string,radix) 默认接收两个参数"></a>Number.parseInt(string,radix) 默认接收两个参数</h4><p>　　第一个参数是默认是<strong> string </strong>类型值，如果不是，会通过抽象的 ToString 强制转化成 string 类型的值。这其中就会有强制类型转换过程中的各种坑</p><p>　　第二个参数是 number 类型的进制，如果不是，会通过抽象的 ToNumber 强制转化成 number 类型的值，范围是 2-36，通过强制类型转换后如果是其他值会返回 NaN。在 ES5 之前如果没有传入这个参数，会根据第一个参数的开头来判断进制，0 开头的字符串会判断成八进制，也就是很多人提到的老黄历坑。ES5 之后已经解决，不传这个参数默认十进制。但是这个参数容易被忽略，尤其是在和 map 之类的也容易忽略后续可选参数的函数搭配使用的时候，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>, <span class="string">'10'</span>, <span class="string">'10'</span>, <span class="string">'10'</span>].map(parseInt) // 结果是 [10, NaN, 2, 3]</span><br><span class="line">[<span class="string">'10'</span>, <span class="string">'10'</span>, <span class="string">'10'</span>, <span class="string">'10'</span>].map(x=&gt;parseInt(x,10)) //正确的做法</span><br></pre></td></tr></table></figure><p>　　所以如果只是用 parseInt 来 “取整”，一个良好的习惯是<strong>永远记得设置第二个参数为 10</strong></p><h2 id="巧妙使用位操作符"><a href="#巧妙使用位操作符" class="headerlink" title="巧妙使用位操作符"></a>巧妙使用位操作符</h2><p>　　JavaScript 中的 number 类型的值都是使用 IEEE 754 标准的 <strong>64 位</strong>双精度浮点型存储，即<em> 1 位符号位 + 11 位指数部分 + 52 位尾数部分 </em>。用来表示整数时，安全的范围是 <strong>53 位</strong>，超出这个返回可能会造成精度丢失</p><ol><li>使用<strong>按位或</strong>向下取整(数值不够大才能用)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num=-9999999.1234;</span><br><span class="line">var int=num|0;</span><br><span class="line">console.log(int);   //-9999999</span><br><span class="line"></span><br><span class="line">var num=-9999999999.1234;</span><br><span class="line">var int=num|0;</span><br><span class="line">console.log(int);   //-1410065407</span><br></pre></td></tr></table></figure><ol><li>按位非（按位取反）任意数值x相当于-(x+1)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(~1);    //-2</span><br><span class="line">console.log(~0);    //-1</span><br><span class="line">console.log(~-1);   //0</span><br><span class="line"></span><br><span class="line">console.log(~NaN);  //-1</span><br><span class="line">console.log(~[]);   //-1</span><br></pre></td></tr></table></figure><p>　　我们可以发现：<strong>-1 是唯一一个经过 ~ 运算返回假值0的值</strong>（包括其他那些特殊的值比如 NaN、{}、[] 等都不会返回假值）</p><p>　　所以字符串和数组的 indexOf 函数查找失败会返回 -1，这时候就可以用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(~str.indexOf(<span class="string">'str'</span>)) // 来表示查找失败</span><br></pre></td></tr></table></figure><p>比判断 &gt;= 0 或者 != -1 更优雅，跟用 !! 来判断非假值有异曲同工之妙</p><h2 id="其它的骚操作"><a href="#其它的骚操作" class="headerlink" title="其它的骚操作"></a>其它的骚操作</h2><p>　　JS取0~9的一个随机数可以用:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Math.random()+<span class="string">""</span>).slice(-1);   //eg从0.984652315464中复制最后一个数字4</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;虽然有不少坑但是比较可靠的parseInt&quot;&gt;&lt;a href=&quot;#虽然有不少坑但是比较可靠的parseInt&quot; class=&quot;headerlink&quot; title=&quot;虽然有不少坑但是比较可靠的parseInt&quot;&gt;&lt;/a&gt;虽然有不少坑但是比较可靠的parseInt&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中new运算符详解</title>
    <link href="http://yoursite.com/2018/05/27/JS%E4%B8%ADnew%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/27/JS中new运算符详解/</id>
    <published>2018-05-27T10:16:52.000Z</published>
    <updated>2018-05-29T13:43:01.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中new运算符和原型链继承"><a href="#JS中new运算符和原型链继承" class="headerlink" title="JS中new运算符和原型链继承"></a>JS中new运算符和原型链继承</h2><p>　　看下面的这些东西之前，先好好看看高程的第六章面向对象部分！里面提到了很多基本概念，比如：</p><ol><li><p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。</p></li><li><p>对原型所做的修改,能够立即在所有实例中得到反映。</p></li></ol><p>　　因为new运算符会返回一个指向构造器函数原型的对象，所以<em>通常</em>情况下this就指向返回的这个对象。</p><p>　　其中<strong>new运算符</strong>创建对象的过程，实际上就是：</p><ol><li>先克隆Object.prototype对象，得到一个空对象，并把它的prototype属性指向构造器函数的原型对象</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li><li>执行构造函数中的代码</li><li>返回新对象</li></ol><p>　　在Chrome和Firefox等向外暴露了对象<strong>proto</strong>属性的浏览器下，我们可以通过下面这段代码理解new运算的过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> this.name;</span><br><span class="line">&#125;;</span><br><span class="line">var objectFactory=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">var obj=new Object(),//1. 先克隆Object.prototype对象，得到一个空对象</span><br><span class="line">Constructor=[].shift.call(arguments);//把第一个参数赋给Constructor变量</span><br><span class="line">obj.__proto__=Constructor.prototype;//1.指向正确的原型</span><br><span class="line">var ret=Constructor.apply(obj,arguments);//2. 将构造函数的作用域赋给新对象+3. 执行构造函数中的代码</span><br><span class="line"><span class="built_in">return</span> typeof ret === <span class="string">"object"</span> ? ret : obj;//4. 返回新对象</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">var a=objectFactory(Person,<span class="string">"sven"</span>);</span><br><span class="line"></span><br><span class="line">console.log(a.name);//sven</span><br><span class="line">console.log(a.getName());//sven</span><br><span class="line">console.log(Object.getPrototypeOf(a) === Person.prototype);//<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>　　然后我们就能理解构造器模式是如何创建对象的了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Point(x=10,y=6)&#123;</span><br><span class="line">this.x=x;</span><br><span class="line">this.y=y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.z=20;</span><br><span class="line">Point.prototype.getX=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">alert(this.x);//不要忘了这里的this也是动态绑定的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p=new Point();//此时Point函数里的this动态绑定到p对象上，都是给p加的x,y属性</span><br><span class="line"></span><br><span class="line">p.getX();               //10 this绑定到p上，相当于alert(p.x)</span><br><span class="line">alert(p.__proto__.x);   //undefined</span><br><span class="line">p.__proto__.getX()      //undefiend this绑定到p的原型对象上也就是构造器原型对象上，当然没有x啦</span><br><span class="line">alert(p.z);             //20 虽然p对象本身没有z属性，但如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</span><br></pre></td></tr></table></figure><p>相关理解图示：<a href="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%9B%BE.jpg?raw=true" title="原型继承示意图" target="_blank" rel="noopener">原型继承示意图</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中new运算符和原型链继承&quot;&gt;&lt;a href=&quot;#JS中new运算符和原型链继承&quot; class=&quot;headerlink&quot; title=&quot;JS中new运算符和原型链继承&quot;&gt;&lt;/a&gt;JS中new运算符和原型链继承&lt;/h2&gt;&lt;p&gt;　　看下面的这些东西之前，先好好看看
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>实现slideUp/Down效果</title>
    <link href="http://yoursite.com/2018/05/20/%E5%AE%9E%E7%8E%B0slideUp-Down%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2018/05/20/实现slideUp-Down效果/</id>
    <published>2018-05-20T02:20:53.000Z</published>
    <updated>2018-05-20T04:02:39.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现slideUp-Down效果"><a href="#实现slideUp-Down效果" class="headerlink" title="实现slideUp/Down效果"></a>实现slideUp/Down效果</h2><p>　　最近做网页时，想做一个点击标题滑动出内容的模块，然后看了下参考的源码，结果发现有好几种做法。</p><h4 id="第一种最简单，就是使用JQuery的slideUp-Down方法，一步搞定"><a href="#第一种最简单，就是使用JQuery的slideUp-Down方法，一步搞定" class="headerlink" title="第一种最简单，就是使用JQuery的slideUp/Down方法，一步搞定"></a>第一种最简单，就是使用JQuery的slideUp/Down方法，一步搞定</h4><h4 id="第二种使用JS配合CSS3的transition属性，但是在该例子中transition需要处理与display的关系，两者貌似搭配起来不会产生效果"><a href="#第二种使用JS配合CSS3的transition属性，但是在该例子中transition需要处理与display的关系，两者貌似搭配起来不会产生效果" class="headerlink" title="第二种使用JS配合CSS3的transition属性，但是在该例子中transition需要处理与display的关系，两者貌似搭配起来不会产生效果"></a>第二种使用JS配合CSS3的transition属性，但是在该例子中transition需要处理与display的关系，两者貌似搭配起来不会产生效果</h4><p>　　解决方法是使用setTimeout延时display: none;的操作，因为我最终没有采用这种方法，留待以后检测。</p><h4 id="第三种使用纯JS实现，即设置setTimeout来控制层的高度实现滑入滑出效果"><a href="#第三种使用纯JS实现，即设置setTimeout来控制层的高度实现滑入滑出效果" class="headerlink" title="第三种使用纯JS实现，即设置setTimeout来控制层的高度实现滑入滑出效果"></a>第三种使用纯JS实现，即设置setTimeout来控制层的高度实现滑入滑出效果</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现slideUp-Down效果&quot;&gt;&lt;a href=&quot;#实现slideUp-Down效果&quot; class=&quot;headerlink&quot; title=&quot;实现slideUp/Down效果&quot;&gt;&lt;/a&gt;实现slideUp/Down效果&lt;/h2&gt;&lt;p&gt;　　最近做网页时，想做一个点
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git多人协作</title>
    <link href="http://yoursite.com/2018/05/19/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/05/19/Git多人协作/</id>
    <published>2018-05-19T00:06:16.000Z</published>
    <updated>2018-05-19T12:18:02.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git多人协作"><a href="#Git多人协作" class="headerlink" title="Git多人协作"></a>Git多人协作</h2><p>　　首先肯定需要对Git的基本操作有一定的认识，这里肯定要放上浅显易懂的：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" title="廖雪峰老师的Git教程" target="_blank" rel="noopener">廖雪峰老师的Git教程</a></p><p>　　看完后我们就应该对Git有个大体的认识了，然后一般用Git的人中我们分两类：一类就是自己在用着玩，那看完上面的教程差不多就可以自己去摸索了；第二类就是想要多人协作，进行一个项目开发或协同作业，所以我在这里就记一下这几天搞多人协作这块儿踩过的坑。</p><p>　　首先干一件事肯定是有个目标，我最近正在和同班同学搞一个网站的小项目，我们前端部分用的VSCode码代码，然后发现里面内置了Git，于是我们就兴冲冲的准备使用，经过一段时间摸索，自己add、commit、push到自己的GitHub时一点问题都没有，于是我们就准备多人协作了，在疯狂网上查找后，我们试出了三种方法。</p><h4 id="第一种：fork别人的库成为自己的，然后clone到自己电脑上操作，操作完push到自己的GitHub上，再去自己的GitHub上发起pull-request发给项目原作者，经原作者审核后merge"><a href="#第一种：fork别人的库成为自己的，然后clone到自己电脑上操作，操作完push到自己的GitHub上，再去自己的GitHub上发起pull-request发给项目原作者，经原作者审核后merge" class="headerlink" title="第一种：fork别人的库成为自己的，然后clone到自己电脑上操作，操作完push到自己的GitHub上，再去自己的GitHub上发起pull request发给项目原作者，经原作者审核后merge"></a>第一种：fork别人的库成为自己的，然后clone到自己电脑上操作，操作完push到自己的GitHub上，再去自己的GitHub上发起pull request发给项目原作者，经原作者审核后merge</h4><p>　　具体操作可见：<a href="https://blog.csdn.net/qq_33429968/article/details/62219783" title="GitHub上如何进行PR(Pull Request)操作" target="_blank" rel="noopener">GitHub上如何进行PR(Pull Request)操作</a></p><p>　　这样可行，但各位仁兄不觉得太过麻烦了吗……而且还需要审核，对于那种开源项目来说肯定是有必要的，但如果就是想四五个人协同作业的话，可以选用下面两种方法。</p><h4 id="第二种：进入需要多人协作的项目中配置其它成员的公钥SSH-key，然后其他成员即可拥有同等的权限，无需审核"><a href="#第二种：进入需要多人协作的项目中配置其它成员的公钥SSH-key，然后其他成员即可拥有同等的权限，无需审核" class="headerlink" title="第二种：进入需要多人协作的项目中配置其它成员的公钥SSH key，然后其他成员即可拥有同等的权限，无需审核"></a>第二种：进入需要多人协作的项目中配置其它成员的公钥SSH key，然后其他成员即可拥有同等的权限，无需审核</h4><p>　　如下图：<img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/Git1.png?raw=true" alt="多人协作方法2" title="配置其它成员的公钥"></p><p>　　这个方法有一个缺点，那就是需要其他成员把自己的SSH与自己的Github远程库解绑，才能被项目拥有者绑定到这个项目上，所以这就不方便其他成员操作自己的GitHub了。</p><h4 id="第三种：添加其他成员为项目协作者collaborators，其他成员也可拥有同等的权限，无需审核"><a href="#第三种：添加其他成员为项目协作者collaborators，其他成员也可拥有同等的权限，无需审核" class="headerlink" title="第三种：添加其他成员为项目协作者collaborators，其他成员也可拥有同等的权限，无需审核"></a>第三种：添加其他成员为项目协作者collaborators，其他成员也可拥有同等的权限，无需审核</h4><p>　　如下图：<img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/Git2.png?raw=true" alt="多人协作方法3" title="添加其他成员为项目协作者"></p><p>　　综上看如果你是个小项目想多人协作的话，这是最简便的方法，不过这里需要注意一点：项目拥有者发送邀请后，被邀请协作的成员需要去自己的<strong>GitHub注册邮箱</strong>里面找一封确认信！！！可能被标记为<strong>垃圾邮件</strong>了！一定要确认，否则无法完成！</p><p>　　最后多人协作肯定会有冲突发生，以后再更新一下解决冲突的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git多人协作&quot;&gt;&lt;a href=&quot;#Git多人协作&quot; class=&quot;headerlink&quot; title=&quot;Git多人协作&quot;&gt;&lt;/a&gt;Git多人协作&lt;/h2&gt;&lt;p&gt;　　首先肯定需要对Git的基本操作有一定的认识，这里肯定要放上浅显易懂的：&lt;a href=&quot;http
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中this的指向</title>
    <link href="http://yoursite.com/2018/05/15/JS%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/"/>
    <id>http://yoursite.com/2018/05/15/JS中this的指向/</id>
    <published>2018-05-15T14:37:32.000Z</published>
    <updated>2018-05-29T13:44:08.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中this的指向"><a href="#JS中this的指向" class="headerlink" title="JS中this的指向"></a>JS中this的指向</h2><pre><code>JavaScript中的this总是指向一个对象，而具体指向哪个对象是在**运行时**基于函数的执行环境动态绑定的。有位人说A.apply(x,array);等价于(A.bind(x))(array),现在看着挺对的，留待以后验证。</code></pre><h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p>　　当函数作为对象的方法被调用时，this指向该对象。</p><h4 id="普通函数调用模式"><a href="#普通函数调用模式" class="headerlink" title="普通函数调用模式"></a>普通函数调用模式</h4><p>　　this总是指向全局对象，在浏览器中，这个全局对象就是window对象。</p><pre><code>但在使用**严格模式**&quot;use strict&quot;;时，this在函数调用模式不会指向全局对象window,而是undefined。</code></pre><h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>　　因为new运算符会返回一个指向构造器函数原型的对象，所以<em>通常</em>情况下this就指向返回的这个对象。</p><p>　　<strong>关于new运算符的内部具体操作请见我博客中的“JS中new运算符详解”！</strong></p><p>　　但还有特殊的情况，比如构造器<strong>显式的返回了一个object类型的对象</strong>时，new调用构造器则会最终返回这个对象，而不是我们期待的this。</p><h4 id="Function-prototype-apply调用模式"><a href="#Function-prototype-apply调用模式" class="headerlink" title="Function.prototype.apply调用模式"></a>Function.prototype.apply调用模式</h4><p>　　详情见我博客中的“JS中的apply()使用详解”一文，它的第一个参数可以改变函数体内this对象的指向。</p><p>　　如果我们传入的第一个参数是<strong>null或undefined</strong>，函数体内的this会指向全局对象，在浏览器中则是window。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func=<span class="keyword">function</span>(a,b,c)&#123;</span><br><span class="line">    alert(this===window);//<span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">func.apply(null,[1,2,3]);</span><br><span class="line">func.apply(undefined,[1,2,3]);</span><br></pre></td></tr></table></figure><p>　　但如果是在<strong>严格模式</strong>下，则会严格执行第一个参数指定了函数体内this对象的指向，即传进来null，this就指向null;传进来undefined,this就指向undefined</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func=<span class="keyword">function</span>(a,b,c)&#123;</span><br><span class="line">    <span class="string">"use strict"</span>;</span><br><span class="line">    alert(this===null);//<span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">func.apply(null,[1,2,3]);</span><br></pre></td></tr></table></figure><h4 id="闭包中的this指向"><a href="#闭包中的this指向" class="headerlink" title="闭包中的this指向"></a>闭包中的this指向</h4><p>　　每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此闭包中永远不可能直接访问外部函数中的这两个变量，this一定是在这个闭包被调用时动态绑定的。如果想使用外层函数的this，最常用的方法就是找一个变量把它保存下来(eg:that)。</p><h3 id="利用apply实现的bind函数"><a href="#利用apply实现的bind函数" class="headerlink" title="利用apply实现的bind函数"></a>利用apply实现的bind函数</h3><p>　　Function.prototype.bind，用来<strong>指定函数内部的this指向</strong>，其<em>简化版</em>实现可以这样模拟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind=<span class="keyword">function</span>(context)&#123;</span><br><span class="line">var that=this;//保存方法调用模式下被调用的原函数</span><br><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;//闭包返回一个新函数（可访问外层函数的变量和参数）</span><br><span class="line"><span class="built_in">return</span> that.apply(context,arguments);//改变that原函数的内部this指向为我们指定的context</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1=&#123;</span><br><span class="line">name: <span class="string">"Daoma"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func();//未定义</span><br><span class="line"></span><br><span class="line">var func=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;.<span class="built_in">bind</span>(obj1);</span><br><span class="line"></span><br><span class="line">func();//Daoma</span><br></pre></td></tr></table></figure><p>　　通常我们还会实现的稍微复杂一点，可以往func函数中预先填入一些参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">var that=this,</span><br><span class="line">context=[].shift.call(arguments),//将第一个元素删掉并返回</span><br><span class="line">args=[].slice.call(arguments);//用slice的另一个功能将剩余的参数类数组转换成数组</span><br><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">//这里运用了函数柯里化的思想，组合两次分别传入的参数，作为新函数的参数</span><br><span class="line"><span class="built_in">return</span> that.apply(context,[].concat.call(args,[].slice.call(arguments)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1=&#123;</span><br><span class="line">name: <span class="string">"daoma"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func=<span class="keyword">function</span>(a,b,c,d)&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">alert([a,b,c,d]);</span><br><span class="line">&#125;.<span class="built_in">bind</span>(obj1,1,2);</span><br><span class="line"></span><br><span class="line">func(3,4);//即可以传参两次拼到一起</span><br></pre></td></tr></table></figure><p>补充bind和call的返回值</p><ol><li>fun.bind(thisArg[, arg1[, arg2[, …]]])</li></ol><p>　　返回由指定的this值和初始化参数改造的<strong>原函数拷贝</strong></p><ol><li>fun.call(thisArg, arg1, arg2, …)</li></ol><p>　　返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。</p><p>最后我还有一个需要填的问题坑，留待以后实力提高后解决：<a href="https://segmentfault.com/q/1010000014969567?_ea=3765087" title="JavaScript中Apply调用模式的this指向问题JavaScript中Apply调用模式的this指向问题" target="_blank" rel="noopener">JavaScript中Apply调用模式的this指向问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中this的指向&quot;&gt;&lt;a href=&quot;#JS中this的指向&quot; class=&quot;headerlink&quot; title=&quot;JS中this的指向&quot;&gt;&lt;/a&gt;JS中this的指向&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;JavaScript中的this总是指向一个对象，而具体指向
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>arguments类数组对象详解</title>
    <link href="http://yoursite.com/2018/05/15/arguments%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/15/arguments类数组对象详解/</id>
    <published>2018-05-15T14:36:53.000Z</published>
    <updated>2018-05-18T12:01:06.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="arguments类数组对象详解"><a href="#arguments类数组对象详解" class="headerlink" title="arguments类数组对象详解"></a>arguments类数组对象详解</h2><h4 id="arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。"><a href="#arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。" class="headerlink" title="arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。"></a>arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。</h4><p>　　它不能像数组一样，进行排序操作或者往集合里添加一个新的元素。</p><h4 id="所以我们经常非常频繁的找Array-prototype对象借用方法。"><a href="#所以我们经常非常频繁的找Array-prototype对象借用方法。" class="headerlink" title="所以我们经常非常频繁的找Array.prototype对象借用方法。"></a>所以我们经常非常频繁的找Array.prototype对象借用方法。</h4><p>　　像Array.prototype.slice可以把arguments转成真正的数组；想截去arguments列表中头一个元素时，又可以借用Array.prototype.shift方法。</p><p>　　要了解这种机制的实现原理，需要查看一下V8引擎的源码，比如Array.prototype.push：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ArrayPush</span></span>()&#123;</span><br><span class="line">var n=TO_UINT32(this.length); //被push的对象的length</span><br><span class="line">var m=%_ArgumentsLength(); //push的参数个数</span><br><span class="line"><span class="keyword">for</span>(var i=0;i&lt;m;i++)&#123;</span><br><span class="line">this[i+n]=%_Arguments(i);  //复制元素</span><br><span class="line">&#125;</span><br><span class="line">this.length=n+m; //修正length属性的值</span><br><span class="line"><span class="built_in">return</span> this.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　可见Array.prototype.push实际上是一个<strong>属性复制</strong>的过程，把参数按照下标依次添加到被push的<strong>对象</strong>上面，顺便修改了这个对象的属性。所以只要是个对象，不管是数组对象还是类数组对象，都可以操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;arguments类数组对象详解&quot;&gt;&lt;a href=&quot;#arguments类数组对象详解&quot; class=&quot;headerlink&quot; title=&quot;arguments类数组对象详解&quot;&gt;&lt;/a&gt;arguments类数组对象详解&lt;/h2&gt;&lt;h4 id=&quot;arguments
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS使用border构建图标</title>
    <link href="http://yoursite.com/2018/05/14/CSS%E4%BD%BF%E7%94%A8border%E6%9E%84%E5%BB%BA%E5%9B%BE%E6%A0%87/"/>
    <id>http://yoursite.com/2018/05/14/CSS使用border构建图标/</id>
    <published>2018-05-14T14:58:33.000Z</published>
    <updated>2018-05-16T03:01:03.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS使用border构建图标"><a href="#CSS使用border构建图标" class="headerlink" title="CSS使用border构建图标"></a>CSS使用border构建图标</h2><h3 id="使用border画三角形"><a href="#使用border画三角形" class="headerlink" title="使用border画三角形"></a>使用border画三角形</h3><p>　　盒模型中上下左右边框交界处呈现平滑的斜线. 利用这个特点, 通过设置不同的上下左右边框宽度或者颜色可以得到小三角, 小梯形等。<a href="http://caibaojian.com/css-border-triangle.html" title="CSS三角形的实现原理及运用" target="_blank" rel="noopener">具体链接</a></p><h3 id="画朝上朝下的√小图标"><a href="#画朝上朝下的√小图标" class="headerlink" title="画朝上朝下的√小图标"></a>画朝上朝下的√小图标</h3><p>　　使用border可以画很多与三角形有关的东东，比如我们经常见到的向上向下的“对号图标”就是使用两层border叠加生成的。<br>  <img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/border%E5%AF%B9%E5%8F%B7%E5%B0%8F%E5%9B%BE%E6%A0%87.png?raw=true" alt="border对号小图标"></p><p>　　首先我们需要一个div和两个i，两个i就是用来叠加生成对号图标用的。</p><p>HTML:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"bottom"</span>&gt;&lt;!-- 这里换成top就是向上的对号--&gt;</span><br><span class="line">&lt;i class=<span class="string">"arrow1"</span>&gt;&lt;/i&gt;</span><br><span class="line">&lt;i class=<span class="string">"arrow2"</span>&gt;&lt;/i&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.bottom&#123;</span><br><span class="line">width: 20px;</span><br><span class="line">height: 20px;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow1,.bottom .arrow2&#123;</span><br><span class="line">display: block;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 0px;/*宽高设为0才能上下左右的border显示为三角形*/</span><br><span class="line">height: 0px;</span><br><span class="line">border-left: 8px dashed transparent;/*transparent主要为了应用在网页中不盖住底色*/</span><br><span class="line">border-right: 8px dashed transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　然后下面关键的就来了，我们给第一个<em><i></i></em>只设置上边框的话在这种情况下是个三角形：<img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/border1.png?raw=true" alt="border1.png"></p><p>　　然后我们可以给第二个<em><i></i></em>再设置一个白色的三角形然后用绝对定位的偏移使它下移盖住灰色三角形的一部分：<img src="https://github.com/Daoma666/JS-CSS_train1/blob/master/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/border2.png?raw=true" alt="border2.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.bottom .arrow1&#123;</span><br><span class="line">border-top: 8px solid <span class="comment">#999;</span></span><br><span class="line">border-bottom: 8px dashed transparent;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow2&#123;</span><br><span class="line">    top: -2px;</span><br><span class="line">    border-top: 8px solid <span class="comment">#fff;</span></span><br><span class="line">    border-bottom: 8px dashed transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　然后我们一开始的那个向下的对号图标就出现啦，向上同理啦，下面就是向上向下放在一起的完整版CSS。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.bottom,.top&#123;</span><br><span class="line">width: 20px;</span><br><span class="line">height: 20px;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow1,.bottom .arrow2,.top .arrow1,.top .arrow2&#123;</span><br><span class="line">display: block;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 0px;</span><br><span class="line">height: 0px;</span><br><span class="line">border-left: 8px dashed transparent;</span><br><span class="line">border-right: 8px dashed transparent;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow1&#123;</span><br><span class="line">border-top: 8px solid <span class="comment">#999;</span></span><br><span class="line">border-bottom: 8px dashed transparent;</span><br><span class="line">&#125;</span><br><span class="line">.bottom .arrow2&#123;</span><br><span class="line">top: -2px;</span><br><span class="line">border-top: 8px solid <span class="comment">#fff;</span></span><br><span class="line">border-bottom: 8px dashed transparent;</span><br><span class="line">&#125; </span><br><span class="line">.top .arrow1&#123;</span><br><span class="line">border-top: 8px dashed transparent;</span><br><span class="line">border-bottom: 8px solid <span class="comment">#999;</span></span><br><span class="line">&#125;</span><br><span class="line">.top .arrow2&#123;</span><br><span class="line">top: 2px;</span><br><span class="line">border-top: 8px dashed transparent;</span><br><span class="line">border-bottom: 8px solid <span class="comment">#fff;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS使用border构建图标&quot;&gt;&lt;a href=&quot;#CSS使用border构建图标&quot; class=&quot;headerlink&quot; title=&quot;CSS使用border构建图标&quot;&gt;&lt;/a&gt;CSS使用border构建图标&lt;/h2&gt;&lt;h3 id=&quot;使用border画三角形&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的前端学习路线</title>
    <link href="http://yoursite.com/2018/05/13/%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://yoursite.com/2018/05/13/我的前端学习路线/</id>
    <published>2018-05-13T01:57:21.000Z</published>
    <updated>2018-05-13T03:17:01.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的前端学习路线"><a href="#我的前端学习路线" class="headerlink" title="我的前端学习路线"></a>我的前端学习路线</h2><p>　　我确认往前端发展是从2018年大三的寒假开始的，因为本科由于兴趣选择了<em>数字媒体专业</em>，自然而然就往前端这边靠了。要具体说一说的话原因也非常简单：JS非常简约易上手，浏览器就是调试器，还可以用代码构建形形色色的可视化页面，完美贴合我这种半计算机半艺术的专业。</p><p>　　干任何事都有个起点，因为我的专业是半计算机专业，这就意味着操作系统原理、汇编、计算机网络这些CS的课程基本都没有，有了也是非常水的讲着玩玩，所以我的<strong>起点水平</strong>也就是对计算机语言的基础知识基本掌握，面向对象的原理（继承、封装、多态）了解过没怎么用过；数据结构会基本的栈、队列、排序、二叉树这些，而且还是只知道原理不会用（不过前端走到现在从没用过，基本pop(),push(),sort()什么的JS都给你封装好了）；前端相关知识HTML、CSS基本标签、属性会用，JS基本语法会用，基本DOM操作会用，jQuery了解过一点。</p><p>　　其它的废话我就不多说了，这里着重记录一下我的学习历程，具体分为：我的书单、网上资源。</p><h2 id="我的前端书单（分先后顺序，书名后跟着难度和推荐度）"><a href="#我的前端书单（分先后顺序，书名后跟着难度和推荐度）" class="headerlink" title="我的前端书单（分先后顺序，书名后跟着难度和推荐度）"></a>我的前端书单（分先后顺序，书名后跟着难度和推荐度）</h2><p>　　我从小就不爱读书，爱看电影，因为感觉书非常无聊，不如电影动态的好看，但是到了现在要学技术了，就必须看书了，不知道大家有没有过这种体验：看动画片一集的时间看漫画能看十集，所以读书而且是读技术书对于<strong>快速</strong>增长学识非常关键。</p><h4 id="1-《Head-First-HTML-与-CSS》-难度：0星-推荐度：3星"><a href="#1-《Head-First-HTML-与-CSS》-难度：0星-推荐度：3星" class="headerlink" title="1.《Head First HTML 与 CSS》  难度：0星  推荐度：3星"></a>1.《Head First HTML 与 CSS》  难度：0星  推荐度：3星</h4><p>　　都称作是最最基本的无脑入门书，也有一些HTML5的新内容，对于我这种零零碎碎学了些前端的人正适合当作第一本书看。</p><h4 id="2-《JavaScript高级程序设计》-难度：2星-推荐度：5星"><a href="#2-《JavaScript高级程序设计》-难度：2星-推荐度：5星" class="headerlink" title="2.《JavaScript高级程序设计》  难度：2星  推荐度：5星"></a>2.《JavaScript高级程序设计》  难度：2星  推荐度：5星</h4><p>　　结合了网上各类大神的推荐和自己的水平，没有去看犀牛书而是看了这本，总体感觉非常系统的带你巩固了一下JS，如果是小白建议就看完第13章事件，基本上就可以完成一些简单页面了，后面的内容什么时候用到了或对JS彻底入门了再去看即可（因为看到第13章JS才算摸到门把）。</p><h4 id="3-《JavaScript语言精粹》-难度：3星-推荐度：5星"><a href="#3-《JavaScript语言精粹》-难度：3星-推荐度：5星" class="headerlink" title="3.《JavaScript语言精粹》  难度：3星  推荐度：5星"></a>3.《JavaScript语言精粹》  难度：3星  推荐度：5星</h4><p>　　当时看北妈的推荐读的这本，真的是如北妈所说：“读一页相当于《JavaScript高级程序设计》的十页”，看了这本书你基本就可以对原型、继承、闭包等有深刻的了解了，吃透这本小薄书我感觉<strong>JS才算真正入门了</strong>。</p><h4 id="4-《图解CSS3：核心技术与开发实践》-难度：1星-推荐度：3星"><a href="#4-《图解CSS3：核心技术与开发实践》-难度：1星-推荐度：3星" class="headerlink" title="4.《图解CSS3：核心技术与开发实践》 难度：1星 推荐度：3星"></a>4.《图解CSS3：核心技术与开发实践》 难度：1星 推荐度：3星</h4><p>　　因为只是基本的CSS了解过，对CSS3并不是很了解，所以看了这本书，但因为是14年的有时候还需要看最新的CSS参考手册自己去挨个试试，总体还不错。</p><h4 id="5-《CSS世界》-难度：3星-推荐度：-5星"><a href="#5-《CSS世界》-难度：3星-推荐度：-5星" class="headerlink" title="5.《CSS世界》  难度：3星  推荐度： 5星"></a>5.《CSS世界》  难度：3星  推荐度： 5星</h4><p>　　很多的CSS属性你知道是什么，但你搭配起来会出现一堆奇奇GAYGAY的问题，所以这本书就帮你了解CSS各属性间的关系和深层用法，我第一遍看因为没什么项目经验所以很多也只是看了，但是没用过所以没有概念，以后做的东西多了再回来看收获更多。</p><h4 id="6-《JavaScript设计模式与开发实践》"><a href="#6-《JavaScript设计模式与开发实践》" class="headerlink" title="6.《JavaScript设计模式与开发实践》"></a>6.《JavaScript设计模式与开发实践》</h4><p>　　最近正在看，看完再评价。</p><h4 id="7-《算法》"><a href="#7-《算法》" class="headerlink" title="7.《算法》"></a>7.《算法》</h4><p>　　最近正在看，感觉还是要了解一下算法，为了找工作也好，以后实际需要也好。</p><h2 id="我的其它书单"><a href="#我的其它书单" class="headerlink" title="我的其它书单"></a>我的其它书单</h2><p>　　学校的那些专业课的书就不说了，只提一下看过的觉得对前端这方面有点用的书单：</p><h4 id="1-《3D数学基础：图形与游戏开发》-难度：2星-推荐度：-4星"><a href="#1-《3D数学基础：图形与游戏开发》-难度：2星-推荐度：-4星" class="headerlink" title="1.《3D数学基础：图形与游戏开发》  难度：2星  推荐度： 4星"></a>1.《3D数学基础：图形与游戏开发》  难度：2星  推荐度： 4星</h4><p>　　看这书会基本的C++和高中数学即可，起码能对计算机图形学的最基础有点认识了，能知道物体在3D空间是如何通过代码进行运动的了，CSS3的transform变形函数里的translate()、rotate()、scale()等与之相关很大。</p><h4 id="2-《图解TCP-IP》-难度：2星-推荐度：-3星"><a href="#2-《图解TCP-IP》-难度：2星-推荐度：-3星" class="headerlink" title="2.《图解TCP/IP》  难度：2星  推荐度： 3星"></a>2.《图解TCP/IP》  难度：2星  推荐度： 3星</h4><p>　　暂时为了以后与计算机网络打交道，先了解一下，但是因为很多名词从来没见过，看过了也就看过了，没有任何概念，所以现在还看不出来有什么用，只是对TCP/IP模型那些宏观上的东西有点感觉。　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我的前端学习路线&quot;&gt;&lt;a href=&quot;#我的前端学习路线&quot; class=&quot;headerlink&quot; title=&quot;我的前端学习路线&quot;&gt;&lt;/a&gt;我的前端学习路线&lt;/h2&gt;&lt;p&gt;　　我确认往前端发展是从2018年大三的寒假开始的，因为本科由于兴趣选择了&lt;em&gt;数字媒体专
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS的面向对象</title>
    <link href="http://yoursite.com/2018/05/13/JS%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/05/13/JS的面向对象/</id>
    <published>2018-05-13T01:41:52.000Z</published>
    <updated>2018-05-27T11:47:58.186Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近刚开始看《JavaScrit设计模式与开发实践一书》，感觉着实不错，让我对JS的面向对象有了更多的认识，下面就来总结一下：</p><p>　　首先要了解的一点是：JavaScript是<strong>动态类型语言</strong>，与Java，C++这些<em>静态类型语言</em>不同，它无需类型检测。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>　　多态就是将“做什么”和“谁去做以及怎样去做”分离开，也就是将“不变的事物”与“可能改变的事物”分离开来，然后把不变的部分隔离出来，把可变的部分<em>封装</em>起来，这样即可实现：同一操作作用于不同的对象，可以产生不同的解释和不同的执行结果。</p><p>　　多态最根本的作用就是通过<strong>把过程化的条件分支语句转化为对象的多态性</strong>，从而消除这些条件分支语句。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>　　因为JavaScript没有一些语言中的public,private,protected等关键字，所以只能依赖<strong>变量的作用域</strong>来实现封装特性，而且只能模拟出public和private这两种封装性。</p><p>　　一般通过函数来创建作用域（如闭包就是实现了公开方法访问私有变量），但最新的ES6提供了let关键字，和Symbol创建私有属性，现在我还没看，等着一定会去了解。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>　　关于原型链继承请参考博客“JS中new运算符详解”和高程6.3节（一定要先搞懂跟new有关的构造器模式，再去看原型链）</p><p>　　JavaScript是一门基于原型的面向对象语言，它的对象系统就是使用<strong>原型模式</strong>来搭建的，所以它<strong>绝大部分的</strong>遵守原型编程范型的基本规则，即：</p><ol><li>绝大部分的数据都是对象</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并<em>克隆</em>它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它的<em>构造器的原型</em></li></ol><h4 id="1-绝大部分的数据都是对象"><a href="#1-绝大部分的数据都是对象" class="headerlink" title="1. 绝大部分的数据都是对象"></a>1. 绝大部分的数据都是对象</h4><p>　　JavaScript中的根对象是Object.prototype对象，它是一个空对象，所有的对象都是从Object.prototype对象克隆而来的，Object.prototype对象就是它们的原型。</p><h4 id="2-要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"><a href="#2-要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它" class="headerlink" title="2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"></a>2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</h4><p>　　JavaScript的函数既可以作为普通函数被调用，也可以被new运算符作为构造器被调用，其中的new运算符实际上就是克隆了一个原型的过程。</p><p>　　<strong>关于new运算符的内部具体操作请见我博客中的“JS中new运算符详解”！</strong></p><h4 id="3-对象会记住它的原型"><a href="#3-对象会记住它的原型" class="headerlink" title="3. 对象会记住它的原型"></a>3. 对象会记住它的原型</h4><p>　　JavaScript给对象提供了一个名为<strong>proto</strong>的隐藏属性（这是浏览器的实现，规范里应该是不可访问的[[prototype]]），该属性默认指向它的构造器的原型对象。</p><p>　　所以<em><strong>proto</strong></em>就是对象跟“对象构造器的原型”联系起来的纽带。</p><h4 id="4-如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型"><a href="#4-如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型" class="headerlink" title="4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型"></a>4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</h4><p>　　JavaScript的对象最初都是由Object.prototype对象克隆而来的，乍一看我们只能得到单一的继承自Object.prototype的对象，但<strong>对象构造器的原型</strong>并不仅限于Object.prototype上，而是可以动态指向其他对象。</p><p>　　所以我们一般通过设置构造器的prototype来实现原型继承：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var A=<span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">A.prototype=&#123;name:<span class="string">"Daoma666"</span>&#125;;</span><br><span class="line">var B=<span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">B.prototype=new A();</span><br><span class="line">var b=new B();</span><br><span class="line">console.log(b.name);//Daoma666</span><br></pre></td></tr></table></figure><p>　　在执行时，引擎做了什么事：</p><ol><li>首先尝试遍历对象b中所有属性，但没有找到name这个属性</li><li>查找name属性的请求被委托给对象b的构造器原型，它被b.<strong>proto</strong>记录着并且指向B.prototype，即new A()创建出来的对象，即一个指向构造器A的prototype的对象。</li><li>然而在该对象中依然没有找到name属性，于是请求继续委托给这个对象构造器的原型A.prototype。</li><li>然后在这里找到了name属性，并返回它的值</li></ol><p>　　最后我们还要注意一点，如果在A.prototype也没找到name属性时，请求会被传递给A.prototype的构造器原型Object.prototype，因为根对象是个空对象，且原型是null，所以这次请求就到此为止，b.name返回undefined。</p><hr><p>　　现在我们就能理解ECMAScript5提供的克隆对象的Object.create方法了，它天然的实现了原型继承。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.create=<span class="keyword">function</span>(obj)&#123;</span><br><span class="line">    var F=<span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">    F.prototype=obj;</span><br><span class="line">    <span class="built_in">return</span> new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　即上面的代码可以这样实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var A=<span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">A.prototype=&#123;name:<span class="string">"Daoma666"</span>&#125;;</span><br><span class="line">var b=Object.create(new A());</span><br><span class="line">console.log(b.name);//Daoma666</span><br></pre></td></tr></table></figure><p>　　此外还有需要注意的几点：</p><ol><li>Object.create()来创建对象比通过构造器创建对象要慢</li><li>设置构造器的prototype实现原型继承时，除了根对象，任何对象都会有一个原型；但通过Object.create(null)可以创建出没有原型的对象。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　最近刚开始看《JavaScrit设计模式与开发实践一书》，感觉着实不错，让我对JS的面向对象有了更多的认识，下面就来总结一下：&lt;/p&gt;
&lt;p&gt;　　首先要了解的一点是：JavaScript是&lt;strong&gt;动态类型语言&lt;/strong&gt;，与Java，C++这些&lt;em&gt;静态
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中insertAdjacentHTML()方法</title>
    <link href="http://yoursite.com/2018/05/12/JS%E4%B8%ADinsertAdjacentHTML-%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/12/JS中insertAdjacentHTML-方法/</id>
    <published>2018-05-12T07:51:26.000Z</published>
    <updated>2018-05-12T07:52:07.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中insertAdjacentHTML-方法"><a href="#JS中insertAdjacentHTML-方法" class="headerlink" title="JS中insertAdjacentHTML()方法"></a>JS中insertAdjacentHTML()方法</h2><p>　　一般我们在写JS时，想在一个DOM节点中插入HTML代码，这时有三种方法：</p><h4 id="1-使用innerHTML"><a href="#1-使用innerHTML" class="headerlink" title="1.使用innerHTML"></a>1.使用innerHTML</h4><p>　　缺点是会把原先该节点的代码全部覆盖掉。</p><h4 id="2-使用insertBefore-appendChild-方法"><a href="#2-使用insertBefore-appendChild-方法" class="headerlink" title="2.使用insertBefore(),appendChild()方法"></a>2.使用insertBefore(),appendChild()方法</h4><p>　　缺点一是麻烦，需要先createElement()创建一个节点，再插入内容，最后再append到DOM树中。二是性能低下，具体见：<a href="http://www.zhangxinxu.com/wordpress/?p=3210http://www.zhangxinxu.com/wordpress/?p=3210" title="小tip: DOM appendHTML实现及insertAdjacentHTML" target="_blank" rel="noopener">DOM appendHTML实现及insertAdjacentHTML</a></p><h4 id="3-使用insertAdjacentHTML-方法，更加灵活"><a href="#3-使用insertAdjacentHTML-方法，更加灵活" class="headerlink" title="3.使用insertAdjacentHTML()方法，更加灵活"></a>3.使用insertAdjacentHTML()方法，更加灵活</h4><p>　　insertAdjacentHTML 方法：在指定的地方插入html标签语句</p><p>　　原型：insertAdajcentHTML(swhere,stext)</p><p>　　参数：</p><p>　　swhere: 指定插入html标签语句的地方，</p><p>　　stext:要插入的内容</p><p>　　有四种值可用：</p><ol><li><p>beforeBegin: 插入到标签开始标记前</p></li><li><p>afterBegin:插入到标签开始标记之后</p></li><li><p>beforeEnd:插入到标签结束标记前</p></li><li><p>afterEnd:插入到标签结束标记后</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中insertAdjacentHTML-方法&quot;&gt;&lt;a href=&quot;#JS中insertAdjacentHTML-方法&quot; class=&quot;headerlink&quot; title=&quot;JS中insertAdjacentHTML()方法&quot;&gt;&lt;/a&gt;JS中insertAdja
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS实现居中的方法</title>
    <link href="http://yoursite.com/2018/05/09/CSS%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/09/CSS实现居中的方法/</id>
    <published>2018-05-09T02:56:22.000Z</published>
    <updated>2018-05-09T03:12:00.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS实现居中的方法"><a href="#CSS实现居中的方法" class="headerlink" title="CSS实现居中的方法"></a>CSS实现居中的方法</h2><h4 id="1-使用width和margin实现水平居中"><a href="#1-使用width和margin实现水平居中" class="headerlink" title="1.使用width和margin实现水平居中"></a>1.使用width和margin实现水平居中</h4><p>　　width指定完宽度，就可以直接margin:0 auto;实现水平居中了</p><h4 id="2-使用text-align实现水平居中"><a href="#2-使用text-align实现水平居中" class="headerlink" title="2.使用text-align实现水平居中"></a>2.使用text-align实现水平居中</h4><p>　　使内联元素居中，所以要在想居中的内联元素的父元素中使用</p><h4 id="3-使用top-left和margin实现水平垂直的居中（但不如下面第4种方法简单）"><a href="#3-使用top-left和margin实现水平垂直的居中（但不如下面第4种方法简单）" class="headerlink" title="3.使用top,left和margin实现水平垂直的居中（但不如下面第4种方法简单）"></a>3.使用top,left和margin实现水平垂直的居中（但不如下面第4种方法简单）</h4><p>　　方法就是top: 50%;left: 50%;然后margin: -所在盒子宽度/2 0 0 -所在盒子高度/2;(可用于弹窗弹出到页面正中间)</p><h4 id="4-使用-margin-auto-实现块级元素水平垂直的居中"><a href="#4-使用-margin-auto-实现块级元素水平垂直的居中" class="headerlink" title="4.使用 margin:auto 实现块级元素水平垂直的居中"></a>4.使用 margin:auto 实现块级元素水平垂直的居中</h4><p>HTML:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"father"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"son"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">    width: 300px; height: 150px;</span><br><span class="line">    background-color: <span class="comment">#f0f3f9;</span></span><br><span class="line">    position:relative;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123; </span><br><span class="line">/*重要部分*/</span><br><span class="line">    position: absolute; </span><br><span class="line">    top: 0; right: 0; bottom: 0; left: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">/*重要部分*/</span><br><span class="line">    width: 200px; height: 100px;</span><br><span class="line">    background-color: <span class="comment">#cd0000;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-使用line-height实现内联元素垂直居中"><a href="#5-使用line-height实现内联元素垂直居中" class="headerlink" title="5.使用line-height实现内联元素垂直居中"></a>5.使用line-height实现内联元素垂直居中</h4><p>　　如果该内联元素只有单行文本，那么连height都不用设置，直接设置一个line-height属性就可以。</p><p>　　原理为<strong>line-height=行距+font-size</strong>，即行距的上下等分机制。具体见《CSS世界》一书中5.2.2节，其中还有多行文本或替换元素的垂直居中如何用line-height和vertical-align实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS实现居中的方法&quot;&gt;&lt;a href=&quot;#CSS实现居中的方法&quot; class=&quot;headerlink&quot; title=&quot;CSS实现居中的方法&quot;&gt;&lt;/a&gt;CSS实现居中的方法&lt;/h2&gt;&lt;h4 id=&quot;1-使用width和margin实现水平居中&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS属性值的百分比</title>
    <link href="http://yoursite.com/2018/04/30/CSS%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94/"/>
    <id>http://yoursite.com/2018/04/30/CSS属性值的百分比/</id>
    <published>2018-04-30T01:32:10.000Z</published>
    <updated>2018-05-12T07:37:19.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS属性值的百分比"><a href="#CSS属性值的百分比" class="headerlink" title="CSS属性值的百分比"></a>CSS属性值的百分比</h2><p>　　经常能见到CSS属性值出现百分比，之前一直也没有整理过，现在为了以后不迷糊，遂整理一下。</p><h3 id="百分比单位"><a href="#百分比单位" class="headerlink" title="百分比单位"></a>百分比单位</h3><h4 id="1-乘以包含块的宽度：margin-padding-left-right-text-indent-width-max-width-min-width"><a href="#1-乘以包含块的宽度：margin-padding-left-right-text-indent-width-max-width-min-width" class="headerlink" title="1.乘以包含块的宽度：margin, padding, left, right, text-indent, width, max-width, min-width"></a>1.乘以包含块的宽度：margin, padding, left, right, text-indent, width, max-width, min-width</h4><p>　　其中padding和margin的百分比值无论是水平方向还是<strong>垂直方向</strong>均是相对于<strong>包含块宽度</strong>计算的！</p><h4 id="2-乘以包含块的高度：top-bottom-height-max-height-min-height"><a href="#2-乘以包含块的高度：top-bottom-height-max-height-min-height" class="headerlink" title="2.乘以包含块的高度：top, bottom, height, max-height, min-height"></a>2.乘以包含块的高度：top, bottom, height, max-height, min-height</h4><p>　　关于<strong>包含块（containing block）</strong>的概念，不能简单地理解成是父元素。如果是静态定位和相对定位，包含块一般就是其父元素。但是对于绝对定位的元素，包含块应该是离它最近的 position 为 absolute、relative、或者 fixed 的祖先元素。对固定定位的元素，它的包含块是视口（viewport）。</p><h4 id="3-乘以元素-border-box-的宽度：border-radius"><a href="#3-乘以元素-border-box-的宽度：border-radius" class="headerlink" title="3.乘以元素(border-box)的宽度：border-radius"></a>3.乘以元素(border-box)的宽度：border-radius</h4><h4 id="4-乘以元素的字体大小：line-height"><a href="#4-乘以元素的字体大小：line-height" class="headerlink" title="4.乘以元素的字体大小：line-height"></a>4.乘以元素的字体大小：line-height</h4><h4 id="5-乘以元素的行高-：vertical-align"><a href="#5-乘以元素的行高-：vertical-align" class="headerlink" title="5.乘以元素的行高 ：vertical-align"></a>5.乘以元素的行高 ：vertical-align</h4><p>　　vertical-align只能应用于内联元素和display值为table-cell的元素！ </p><h4 id="6-background-position中的百分比单位与CSS中其它百分比单位都不一样！具体见“前端配合设计师之background-position定位图片”这篇Blog"><a href="#6-background-position中的百分比单位与CSS中其它百分比单位都不一样！具体见“前端配合设计师之background-position定位图片”这篇Blog" class="headerlink" title="6.background-position中的百分比单位与CSS中其它百分比单位都不一样！具体见“前端配合设计师之background-position定位图片”这篇Blog"></a>6.background-position中的百分比单位与CSS中其它百分比单位都不一样！具体见“前端配合设计师之background-position定位图片”这篇Blog</h4><h4 id="7-字体大小中的百分比-font-size-中的百分比值应该乘以元素所继承到的字体大小，也就是父元素的字体大小"><a href="#7-字体大小中的百分比-font-size-中的百分比值应该乘以元素所继承到的字体大小，也就是父元素的字体大小" class="headerlink" title="7.字体大小中的百分比 font-size 中的百分比值应该乘以元素所继承到的字体大小，也就是父元素的字体大小"></a>7.字体大小中的百分比 font-size 中的百分比值应该乘以元素所继承到的字体大小，也就是父元素的字体大小</h4><p>　　这里再提一下常用的字体单位em和ex。<br>　　em——是一个相对于font-size的相对单位,因此line-height: 1.5em;就是和当前font-size相乘后的值。 ex——相当于字体中的“x”的高度。</p><h3 id="百分比的继承"><a href="#百分比的继承" class="headerlink" title="百分比的继承"></a>百分比的继承</h3><p>　　如果使用<em>数值</em>作为line-height的属性值，那么所有子元素继承的都是这个值；如果使用<em>百分比相对值</em>作为属性值，那么所有的子元素继承的是最终的计算值。</p><p>CSS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   body&#123;</span><br><span class="line">font-size: 14px;</span><br><span class="line">line-height: 1.5;/*子元素继承的line-height都是1.5*/</span><br><span class="line">line-height: 150%;/*子元素继承的line-height是14px*150%=21px*/</span><br><span class="line">line-height: 1.5em;/*子元素继承的line-height14px*1.5em=21px*/</span><br><span class="line">&#125;</span><br><span class="line">h3,p&#123;</span><br><span class="line">   margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">h3&#123;</span><br><span class="line">font-size: 32px;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">font-size: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   &lt;h3&gt;标题呵呵哈哈哈&lt;/h3&gt;</span><br><span class="line">&lt;p&gt;内容啊啊啊啊啊&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>　　所以一般推荐使用<em>数值</em>来操作line-height属性，比如1.5或15px，其中1.5默认就是1.5em，即相对于当前font-size的1.5倍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS属性值的百分比&quot;&gt;&lt;a href=&quot;#CSS属性值的百分比&quot; class=&quot;headerlink&quot; title=&quot;CSS属性值的百分比&quot;&gt;&lt;/a&gt;CSS属性值的百分比&lt;/h2&gt;&lt;p&gt;　　经常能见到CSS属性值出现百分比，之前一直也没有整理过，现在为了以后不迷
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端配合设计师之background-position定位图片</title>
    <link href="http://yoursite.com/2018/04/29/%E5%89%8D%E7%AB%AF%E9%85%8D%E5%90%88%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B9%8Bbackground-position%E5%AE%9A%E4%BD%8D%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/04/29/前端配合设计师之background-position定位图片/</id>
    <published>2018-04-29T02:54:58.000Z</published>
    <updated>2018-04-30T03:32:56.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端配合设计师之background-position定位图片"><a href="#前端配合设计师之background-position定位图片" class="headerlink" title="前端配合设计师之background-position定位图片"></a>前端配合设计师之background-position定位图片</h2><p>　　我们经常遇到UI设计师把同一类部件的小图片都放在一张图片里的情况，小图片就是整图分割后的各个部分，把各个部分放在一张图片上，而不是是分别存储成单独的图片，其目的就是要<strong>减少http请求次数，节省时间和带宽</strong>。对于我们前端来说，就是要把对应的小图片应用到适当的位置，这里就需要background-position属性。</p><p>　　这里需要搞清楚关于定位的一些东西：</p><p>1.两个值前面一个是横向的定位，我们称为x轴方向定位。后面一个值是纵向的定位，我们称为y轴方向定位。<strong>如果只有一个值，那默认的就是x轴方向，这时y轴方向就默认的是上下居中对齐，也就是center</strong>。</p><h4 id="2-背景图片定位的坐标原点就是对应容器元素的“左上角”，即元素padding的外边缘。（这个值可以通过background-origin进行定义）"><a href="#2-背景图片定位的坐标原点就是对应容器元素的“左上角”，即元素padding的外边缘。（这个值可以通过background-origin进行定义）" class="headerlink" title="2.背景图片定位的坐标原点就是对应容器元素的“左上角”，即元素padding的外边缘。（这个值可以通过background-origin进行定义）"></a>2.背景图片定位的坐标原点就是对应容器元素的“左上角”，即元素padding的外边缘。（这个值可以通过background-origin进行定义）</h4><h4 id="3-x-y值分别表示背景图片的左上角顶点相对于坐标原点（也就是容器的左顶点）的值。"><a href="#3-x-y值分别表示背景图片的左上角顶点相对于坐标原点（也就是容器的左顶点）的值。" class="headerlink" title="3.x y值分别表示背景图片的左上角顶点相对于坐标原点（也就是容器的左顶点）的值。"></a>3.x y值分别表示背景图片的左上角顶点相对于坐标原点（也就是容器的左顶点）的值。</h4><p>4.x y的值可以用px或百分比来表示。</p><h4 id="5-当x-y用百分比单位时，其表现与CSS中其他的百分比单位表现都不一样。"><a href="#5-当x-y用百分比单位时，其表现与CSS中其他的百分比单位表现都不一样。" class="headerlink" title="5.当x y用百分比单位时，其表现与CSS中其他的百分比单位表现都不一样。"></a>5.当x y用百分比单位时，其表现与CSS中其他的百分比单位表现都不一样。</h4><p>　　比如一个图片：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img &#123; position: absolute; left: 100%; &#125;</span><br></pre></td></tr></table></figure></p><p>　　一定是在容器外部，但像background-position:100% 100%就是定位在容器内的右下角。</p><p>　　那background-position百分比表示的背景图片的左上角顶点对应的容器坐标位置该如何计算呢？</p><p>　　具体公式为：</p><h5 id="positionX-容器的宽度-图片的宽度-percentX"><a href="#positionX-容器的宽度-图片的宽度-percentX" class="headerlink" title="positionX = (容器的宽度-图片的宽度) * percentX;"></a>positionX = (容器的宽度-图片的宽度) * percentX;</h5><h5 id="positionY-容器的高度-图片的高度-percentY"><a href="#positionY-容器的高度-图片的高度-percentY" class="headerlink" title="positionY = (容器的高度-图片的高度) * percentY;"></a>positionY = (容器的高度-图片的高度) * percentY;</h5><p>　　然后这样算出来的positionX和positionY就是相对于上面第三条结论的x和y，这就不难懂为什么background-position:100% 100%就是定位在容器内的右下角了吧。</p><p>6、x y也可以用“left、right、top、bottom、center”这五个关键字来表示，但注意：用“left、right、top、bottom、center”来表示的时候，“应用的是对齐规则，而不是坐标规则”。x为left是表示图片的左边和容器的左边对齐，为right的时候表示图片的右边和容器的右边对齐，y为top的时候表示图片的顶部和容器的顶部对齐，为bottom时表示图片的底部和容器的底部对齐，x y等于center的时候表示居中对齐。</p><p>7、x y用百分比或者px表示的时候，其值可以为负数。我们应用坐标规则就很容易理解负数表示的意义，x为负数时候表示图片左顶点在容器左顶点的左侧，y为负数时表示图片的左顶点在容器的左定点的上方。也就是向左和向上超出容器的范围。</p><h5 id="但是这里要注意，有的情况下用百分比的负数时并不会像你想的那样向左和向上超出容器的范围，因为第5条中介绍的百分比定位规则，就算你"><a href="#但是这里要注意，有的情况下用百分比的负数时并不会像你想的那样向左和向上超出容器的范围，因为第5条中介绍的百分比定位规则，就算你" class="headerlink" title="但是这里要注意，有的情况下用百分比的负数时并不会像你想的那样向左和向上超出容器的范围，因为第5条中介绍的百分比定位规则，就算你"></a>但是这里要注意，有的情况下用百分比的负数时并不会像你想的那样向左和向上超出容器的范围，因为第5条中介绍的百分比定位规则，就算你</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-position: -50% -50%;</span><br></pre></td></tr></table></figure><p>　　图片会像background-position: 40px 10px;一样定位在容器内部，此时就可能是你<strong>图片的长度大于容器的长度</strong>导致的，因为此时：</p><h5 id="positionX-容器的宽度-图片的宽度-50-的结果是个正值"><a href="#positionX-容器的宽度-图片的宽度-50-的结果是个正值" class="headerlink" title="positionX = (容器的宽度-图片的宽度) * -50% 的结果是个正值"></a>positionX = (容器的宽度-图片的宽度) * -50% 的结果是个正值</h5><h5 id="positionY-容器的高度-图片的高度-50-的结果也是个正值"><a href="#positionY-容器的高度-图片的高度-50-的结果也是个正值" class="headerlink" title="positionY = (容器的高度-图片的高度) * -50% 的结果也是个正值"></a>positionY = (容器的高度-图片的高度) * -50% 的结果也是个正值</h5><p>　　所以就不难理解为什么会出现像background-position: 40px 10px;这样的效果了。</p><p>　　详细请参考：<a href="http://www.zhangxinxu.com/wordpress/2015/03/background-object-position-value-percent/" title="CSS &lt;position&gt;值简介理解background百分比定位" target="_blank" rel="noopener">background百分比定位<position>值简介</position></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端配合设计师之background-position定位图片&quot;&gt;&lt;a href=&quot;#前端配合设计师之background-position定位图片&quot; class=&quot;headerlink&quot; title=&quot;前端配合设计师之background-position定位图
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中sort方法详解</title>
    <link href="http://yoursite.com/2018/04/25/JS%E4%B8%ADsort%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/25/JS中sort方法详解/</id>
    <published>2018-04-25T02:42:04.000Z</published>
    <updated>2018-04-25T02:42:41.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中sort方法详解"><a href="#JS中sort方法详解" class="headerlink" title="JS中sort方法详解"></a>JS中sort方法详解</h2><p>　　sort() 方法用于对数组的元素进行排序,并返回排序后的数组。默认排序顺序是根据字符串Unicode码点(<strong>注意这里不是按ASCII编码排序</strong>，这里按Unicode编码排序要和平常两个字符串的&lt;,&gt;,&lt;=,&gt;=,一位位字符按ASCII编码排序区分开。)</p><h4 id="语法：arrayObject-sort-func-；参数func可选，规定排序顺序，必须是函数。"><a href="#语法：arrayObject-sort-func-；参数func可选，规定排序顺序，必须是函数。" class="headerlink" title="语法：arrayObject.sort(func)；参数func可选，规定排序顺序，必须是函数。"></a>语法：arrayObject.sort(func)；参数func可选，规定排序顺序，必须是函数。</h4><p>　　注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照Unicode字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。<br>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var scores = [1, 10, 21, 2]; </span><br><span class="line">scores.sort(); </span><br><span class="line">// [1, 10, 2, 21]</span><br><span class="line">// 注意10在2之前,</span><br><span class="line">// 因为在 Unicode码点 指针顺序中<span class="string">"10"</span>在<span class="string">"2"</span>之前</span><br></pre></td></tr></table></figure><p>　　如果想按照其他标准进行排序，就需要提供<strong>比较函数</strong>，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有<strong>两个参数 a 和 b</strong>，其返回值如下：</p><h4 id="如果返回一个负数，则第一个参数应该排列在前面，即在排序后的数组中-a-应该出现在-b-之前。"><a href="#如果返回一个负数，则第一个参数应该排列在前面，即在排序后的数组中-a-应该出现在-b-之前。" class="headerlink" title="如果返回一个负数，则第一个参数应该排列在前面，即在排序后的数组中 a 应该出现在 b 之前。"></a>如果返回一个负数，则第一个参数应该排列在前面，即在排序后的数组中 a 应该出现在 b 之前。</h4><h4 id="如果-返回-0，表示a-等于-b，则a-和-b-的相对位置不变。（注意这里和排序算法的稳定性有关）"><a href="#如果-返回-0，表示a-等于-b，则a-和-b-的相对位置不变。（注意这里和排序算法的稳定性有关）" class="headerlink" title="如果 返回 0，表示a 等于 b，则a 和 b 的相对位置不变。（注意这里和排序算法的稳定性有关）"></a>如果 返回 0，表示a 等于 b，则a 和 b 的相对位置不变。（注意这里和排序算法的稳定性有关）</h4><h4 id="如果返回一个正数，则第二个参数应该排列在前面。"><a href="#如果返回一个正数，则第二个参数应该排列在前面。" class="headerlink" title="如果返回一个正数，则第二个参数应该排列在前面。"></a>如果返回一个正数，则第二个参数应该排列在前面。</h4><p>　　所以，比较函数格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(a, b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b ) &#123;        // 按某种排序标准进行比较, a 小于 b</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b ) &#123;</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">// a must be equal to b</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compareNumbers(a, b) &#123;</span><br><span class="line"><span class="built_in">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　你可能还有疑问，就是为什么比较函数要放两个参数？我们可以拿V8引擎(Chrome浏览器的JS引擎)来理解。</p><p>　　V8引擎使用C++开发，如果学过一点点数据结构课的话，肯定接触过排序这一块儿，什么快速排序、插入排序、冒泡排序的，然后<strong>大部分排序算法，步骤分解之后，最细节的操作都是两个数的相互比较</strong>，Chrome浏览器用的V8引擎就使用了快速排序。下面就贴一段当年学数据结构的时候快排的代码，V8的源码肯定不是这么简单，肯定是一种复杂的经过了各种优化（比如改善了稳定性，内存等）但基本的快排就是这样：左边右边一块儿往中间排，排出一个个有序的子段，然后再一个个子段中递归的排。</p><h4 id="排序稳定性是指排序后数组中的相等值的相对位置没有改变，而不稳定性排序则会改变相等值的相对位置。"><a href="#排序稳定性是指排序后数组中的相等值的相对位置没有改变，而不稳定性排序则会改变相等值的相对位置。" class="headerlink" title="排序稳定性是指排序后数组中的相等值的相对位置没有改变，而不稳定性排序则会改变相等值的相对位置。"></a>排序稳定性是指排序后数组中的相等值的相对位置没有改变，而不稳定性排序则会改变相等值的相对位置。</h4><p>C++快速排序算法(这里是从小到大的正序算法):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int left,int right)&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">           <span class="built_in">return</span>; </span><br><span class="line">       &#125; </span><br><span class="line">       int pivot=data[left],low=left,high=right;</span><br><span class="line">       <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">           <span class="keyword">while</span>(low&lt;high &amp;&amp; data[high]&gt;=pivot)&#123;</span><br><span class="line">               high--;</span><br><span class="line">           &#125;</span><br><span class="line">           data[low]=data[high];</span><br><span class="line">           <span class="keyword">while</span>(low&lt;high &amp;&amp; data[low]&lt;=pivot)&#123;</span><br><span class="line">               low++;</span><br><span class="line">           &#125;</span><br><span class="line">           data[high]=data[low];</span><br><span class="line">       &#125;</span><br><span class="line">       data[low]=pivot;</span><br><span class="line">       quick_sort(left,low-1);</span><br><span class="line">       quick_sort(low+1,right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>　　所以这样就清楚了，我们只要设置好了比较函数func(a,b)规定了每两个数排序的正逆序，就可以对整个数组进行快速排序，但要注意的是，<strong>因为快速排序是不稳定排序，所以sort方法也是不稳定的</strong>。</p><p>　　我们还可以令<strong>对象数组</strong>排序，这里是加强版排序，首先按last排序，然后按照first排序。</p><p>JS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var s=[</span><br><span class="line">&#123;first:<span class="string">"Tom"</span>,last:<span class="string">"cruse"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Jack"</span>,last:<span class="string">"awddwa"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Aommy"</span>,last:<span class="string">"rththr"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Fuck"</span>,last:<span class="string">"ererg"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Shit"</span>,last:<span class="string">"nbnb"</span>&#125;,</span><br><span class="line">&#123;first:<span class="string">"Jessy"</span>,last:<span class="string">"awddwa"</span>&#125;</span><br><span class="line">];</span><br><span class="line">var by=<span class="keyword">function</span>(name,minor)&#123;</span><br><span class="line"><span class="built_in">return</span> <span class="keyword">function</span>(o,p)&#123;</span><br><span class="line">var a,b;</span><br><span class="line"><span class="keyword">if</span>(typeof o===<span class="string">'object'</span> &amp;&amp; typeof p===<span class="string">'object'</span> &amp;&amp; o &amp;&amp; p)&#123;</span><br><span class="line">a=o[name];</span><br><span class="line">b=p[name];</span><br><span class="line"><span class="keyword">if</span>(a===b)&#123;</span><br><span class="line">//这里的minor(o,p)实际上是by(<span class="string">'first'</span>)(o,p)</span><br><span class="line"><span class="built_in">return</span> typeof minor ===  <span class="string">'function'</span> ? minor(o,p) : 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(typeof a=== typeof b)&#123;</span><br><span class="line"><span class="built_in">return</span> a&lt;b?-1:1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> typeof a &lt; typeof b ? -1 : 1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">throw&#123;</span><br><span class="line">name: <span class="string">'Error'</span>,</span><br><span class="line">message: <span class="string">'Expected an object when sorting by '</span>+name</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">//因为by函数使用了闭包，这里的带两个参数的比较函数实际上是by(name)函数,即func(o,p)=by(name)(o,p)</span><br><span class="line">//一个函数当参数的时候只写函数名即可,所以写成sort(by(<span class="string">'last'</span>))就行</span><br><span class="line">s.sort(by(<span class="string">"last"</span>,by(<span class="string">"first"</span>)));</span><br><span class="line"><span class="keyword">for</span>(var i <span class="keyword">in</span> s)&#123;</span><br><span class="line">console.log(s[i].first+<span class="string">" "</span>+s[i].last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　更多关于sort()的内容，请见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" title="Array.prototype.sort()" target="_blank" rel="noopener">MDN文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中sort方法详解&quot;&gt;&lt;a href=&quot;#JS中sort方法详解&quot; class=&quot;headerlink&quot; title=&quot;JS中sort方法详解&quot;&gt;&lt;/a&gt;JS中sort方法详解&lt;/h2&gt;&lt;p&gt;　　sort() 方法用于对数组的元素进行排序,并返回排序后的数组。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>label标签和任意高度元素展开收起的骚操作</title>
    <link href="http://yoursite.com/2018/04/24/label%E6%A0%87%E7%AD%BE%E5%92%8C%E4%BB%BB%E6%84%8F%E9%AB%98%E5%BA%A6%E5%85%83%E7%B4%A0%E5%B1%95%E5%BC%80%E6%94%B6%E8%B5%B7%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/04/24/label标签和任意高度元素展开收起的骚操作/</id>
    <published>2018-04-23T23:33:57.000Z</published>
    <updated>2018-05-09T10:54:38.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="label标签和任意高度元素展开收起的骚操作"><a href="#label标签和任意高度元素展开收起的骚操作" class="headerlink" title="label标签和任意高度元素展开收起的骚操作"></a>label标签和任意高度元素展开收起的骚操作</h2><p>　　<em><label></label></em> 标签为 input 元素定义标注（标记）。</p><p>　　<em><label></label></em> 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</p><p>　　<em><label></label></em> 标签的 for 属性应当与相关元素的 id 属性相同。</p><p>HTML:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"check"</span> <span class="built_in">type</span>=<span class="string">"checkbox"</span>&gt;</span><br><span class="line">&lt;p&gt;:checked 选择器匹配每个已被选中的 input 元素（只用于单选按钮和复选框）。&lt;/p&gt;</span><br><span class="line">&lt;div class=<span class="string">"element"</span>&gt;</span><br><span class="line">  &lt;p&gt;若指定了label标签的<span class="keyword">for</span>属性和input标签的id属性相同的话，则可以实现两者的关联，在该例子里就是label也可以点击触发:checked&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"check"</span> class=<span class="string">"check-in"</span>&gt;更多↓&lt;/label&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"check"</span> class=<span class="string">"check-out"</span>&gt;收起↑&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*把复选框隐藏掉*/</span><br><span class="line">input[<span class="built_in">type</span>=<span class="string">"checkbox"</span>]&#123;</span><br><span class="line">position: absolute;</span><br><span class="line">clip: rect(0,0,0,0);/*clip属性裁剪出一个绝对定位元素的可见尺寸*/</span><br><span class="line">&#125;</span><br><span class="line">/*实现任意高度元素展开收起 的骚操作*/</span><br><span class="line">.element &#123;</span><br><span class="line">  max-height: 0;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  transition: max-height 1.25s;</span><br><span class="line">&#125;</span><br><span class="line">:checked ~ .element &#123;</span><br><span class="line">  max-height: 666px; /*一个足够大的最大高度值*/</span><br><span class="line">&#125;</span><br><span class="line">/*为了更美观，实现两个label的显示交替*/</span><br><span class="line">:checked ~ .check-in&#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">.check-out&#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">:checked ~ .check-out&#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;label标签和任意高度元素展开收起的骚操作&quot;&gt;&lt;a href=&quot;#label标签和任意高度元素展开收起的骚操作&quot; class=&quot;headerlink&quot; title=&quot;label标签和任意高度元素展开收起的骚操作&quot;&gt;&lt;/a&gt;label标签和任意高度元素展开收起的骚
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS特殊的按钮闪烁效果</title>
    <link href="http://yoursite.com/2018/04/21/CSS%E7%89%B9%E6%AE%8A%E7%9A%84%E6%8C%89%E9%92%AE%E9%97%AA%E7%83%81%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2018/04/21/CSS特殊的按钮闪烁效果/</id>
    <published>2018-04-21T02:57:49.000Z</published>
    <updated>2018-04-21T02:58:11.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS特殊的按钮闪烁效果"><a href="#CSS特殊的按钮闪烁效果" class="headerlink" title="CSS特殊的按钮闪烁效果"></a>CSS特殊的按钮闪烁效果</h2><p>　　本来想练习线性渐变做按钮的，但无意中发现了一个闪烁的效果，具体见代码</p><p>HTML:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;a href=<span class="string">"javascript:void(0)"</span> class=<span class="string">"button cyan"</span>&gt;Daoma666&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>CSS：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">body&gt;div&#123;</span><br><span class="line">text-align: center;</span><br><span class="line">display: block;</span><br><span class="line">width: 800px;</span><br><span class="line">margin: 50px auto;</span><br><span class="line">&#125;</span><br><span class="line">.button</span><br><span class="line">&#123;</span><br><span class="line">font-family: Arial,helvetica,sans-serif;</span><br><span class="line">font-size: 13px;</span><br><span class="line">color: <span class="comment">#000;</span></span><br><span class="line">text-decoration: none;</span><br><span class="line">display: inline-block;</span><br><span class="line">text-align: center;</span><br><span class="line">padding: 7px 20px 9px;</span><br><span class="line">margin: .5em .5em .5em 0;/*根据相应字体大小font-size来定，在这个类里1em=13px*/</span><br><span class="line">cursor: pointer;</span><br><span class="line">text-shadow: 0 1px 1px rgba(0,0,0,0.4);</span><br><span class="line">text-transform: capitalize;</span><br><span class="line">transition: 0.1s linear;</span><br><span class="line">&#125;</span><br><span class="line">.cyan &#123;</span><br><span class="line">background: rgb(130,207,241);</span><br><span class="line">background: -webkit-linear-gradient(to bottom,  rgba(130,207,241,1) 0%,rgba(56,174,234,1) 100%);</span><br><span class="line">background: linear-gradient(to bottom,  rgba(130,207,241,1) 0%,rgba(56,174,234,1) 100%);</span><br><span class="line">border: 1px solid <span class="comment">#3cafcf;</span></span><br><span class="line">&#125;  </span><br><span class="line">.cyan:hover &#123;</span><br><span class="line">background: rgb(153,216,244);</span><br><span class="line">/*background: -webkit-linear-gradient(to bottom,  rgba(153,216,244,1) 0%,rgba(79,183,236,1) 100%);</span><br><span class="line">background: linear-gradient(to bottom,  rgba(153,216,244,1) 0%,rgba(79,183,236,1) 100%);*/</span><br><span class="line">//原先这里的background打错了，导致渐变无效，然后就出现了闪烁效果，感觉比较抓人眼球。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS特殊的按钮闪烁效果&quot;&gt;&lt;a href=&quot;#CSS特殊的按钮闪烁效果&quot; class=&quot;headerlink&quot; title=&quot;CSS特殊的按钮闪烁效果&quot;&gt;&lt;/a&gt;CSS特殊的按钮闪烁效果&lt;/h2&gt;&lt;p&gt;　　本来想练习线性渐变做按钮的，但无意中发现了一个闪烁的效果
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中的apply()使用详解</title>
    <link href="http://yoursite.com/2018/04/18/JS%E4%B8%AD%E7%9A%84apply-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/18/JS中的apply-使用详解/</id>
    <published>2018-04-17T23:20:35.000Z</published>
    <updated>2018-04-22T02:54:10.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中的apply-使用详解"><a href="#JS中的apply-使用详解" class="headerlink" title="JS中的apply()使用详解"></a>JS中的apply()使用详解</h2><h3 id="apply-要绑定给this的值-参数数组-方法用来调用函数及扩展作用域"><a href="#apply-要绑定给this的值-参数数组-方法用来调用函数及扩展作用域" class="headerlink" title="apply(要绑定给this的值,参数数组)方法用来调用函数及扩展作用域"></a>apply(要绑定给this的值,参数数组)方法用来调用函数及扩展作用域</h3><h4 id="eg-Function-apply-obj-args-方法能接收两个参数，其中"><a href="#eg-Function-apply-obj-args-方法能接收两个参数，其中" class="headerlink" title="eg:Function.apply(obj,args)方法能接收两个参数，其中"></a>eg:Function.apply(obj,args)方法能接收两个参数，其中</h4><h4 id="obj-这个对象将代替Function函数里的this对象"><a href="#obj-这个对象将代替Function函数里的this对象" class="headerlink" title="obj:这个对象将代替Function函数里的this对象"></a>obj:这个对象将代替Function函数里的this对象</h4><h4 id="args-这个是数组，它将作为参数传给Function-args"><a href="#args-这个是数组，它将作为参数传给Function-args" class="headerlink" title="args:这个是数组，它将作为参数传给Function(args);　　"></a>args:这个是数组，它将作为参数传给Function(args);　　</h4><p>　　之前我一直从语义上蒙圈，还以为是Function调用啥啥啥，结果不是。。。而是<strong>obj.Function(args)</strong>，即obj调用Function函数并传入参数数组args。</p><h3 id="call和apply的意思一样-只不过是参数要一个一个列出来"><a href="#call和apply的意思一样-只不过是参数要一个一个列出来" class="headerlink" title="call和apply的意思一样,只不过是参数要一个一个列出来."></a>call和apply的意思一样,只不过是参数要一个一个列出来.</h3><h4 id="eg-Function-call-obj-param1-param2-…-paramN"><a href="#eg-Function-call-obj-param1-param2-…-paramN" class="headerlink" title="eg:Function.call(obj,[param1[,param2[,…[,paramN]]]])"></a>eg:Function.call(obj,[param1[,param2[,…[,paramN]]]])</h4><h4 id="obj：这个对象将代替Function函数里的this对象"><a href="#obj：这个对象将代替Function函数里的this对象" class="headerlink" title="obj：这个对象将代替Function函数里的this对象"></a>obj：这个对象将代替Function函数里的this对象</h4><h4 id="params：这个是一个参数列表"><a href="#params：这个是一个参数列表" class="headerlink" title="params：这个是一个参数列表"></a>params：这个是一个参数列表</h4><p>具体见一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Student(name,age,grade)&#123;</span><br><span class="line">Person.apply(this,arguments);</span><br><span class="line">this.grade=grade;</span><br><span class="line">&#125;</span><br><span class="line">var student=new Student(<span class="string">"MaYun"</span>,21,<span class="string">"大三"</span>);</span><br><span class="line">alert(student.name+<span class="string">" "</span>+student.age+<span class="string">" "</span>+student.grade);</span><br></pre></td></tr></table></figure></p><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>　　这里Student里虽然没有给name和age属性赋值的语句，但调用了Person构造函数。所以var student=new Student(“MaYun”,21,”大三”);new出来的Student构造函数里：</p><p>　　因为遵循<strong>构造器调用模式</strong>(new)中this被绑定到<strong>新对象</strong>(即student)，所以</p><p>　　Person.apply(this,arguments);就相当于Person.apply(student,arguments);就相当于student.Person(name,age,grade);</p><p>　　此时Person中的this.name=name;this.age=age;中的this因为属于<strong>方法调用模式</strong>被绑定到<strong>调用该方法的对象</strong>上，所以就相当于student.name=name;student.age=age;</p><h4 id="巧妙使用apply-this-args-的args参数"><a href="#巧妙使用apply-this-args-的args参数" class="headerlink" title="巧妙使用apply(this,args)的args参数"></a>巧妙使用apply(this,args)的args参数</h4><p>　　如果见到apply(null,args);这种写法，这样其实不算调用什么东东了，只是可以将一个args数组默认的转换为一个参数列表(即[param1,param2,param3] 转换为 param1,param2,param3)来传惨。</p><h3 id="比如下面的例子想得到数组中最大的一项-。"><a href="#比如下面的例子想得到数组中最大的一项-。" class="headerlink" title="比如下面的例子想得到数组中最大的一项 。"></a>比如下面的例子想得到数组中最大的一项 。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array=[50,60,70,90,100];</span><br><span class="line">var max=Math.max(array);</span><br><span class="line">alert(max); //NaN</span><br><span class="line">max=Math.max.apply(null,array);</span><br><span class="line">alert(max); //100</span><br></pre></td></tr></table></figure><p>　　因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组  </p><p>　　但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的这个特点可以得到一个数组中最大的一项  。</p><h3 id="同样的push方法没有提供push一个数组中的每一项"><a href="#同样的push方法没有提供push一个数组中的每一项" class="headerlink" title="同样的push方法没有提供push一个数组中的每一项"></a>同样的push方法没有提供push一个数组中的每一项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a1=[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</span><br><span class="line">var a2=[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</span><br><span class="line">var b=[<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>];</span><br><span class="line">a1.push(b);</span><br><span class="line">alert(a1.length);//4,即把b数组作为单个元素push了,a1=[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,[<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>]]</span><br><span class="line">Array.prototype.push.apply(a2,b);</span><br><span class="line">alert(a2.length);//6,即把b数组中的每一项都push了,a2=[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>]</span><br></pre></td></tr></table></figure><p>　　因为push方法会修改原数组，所以这里用了a1和a2两个数组来作例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中的apply-使用详解&quot;&gt;&lt;a href=&quot;#JS中的apply-使用详解&quot; class=&quot;headerlink&quot; title=&quot;JS中的apply()使用详解&quot;&gt;&lt;/a&gt;JS中的apply()使用详解&lt;/h2&gt;&lt;h3 id=&quot;apply-要绑定给this的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>闭包与模仿块作用域</title>
    <link href="http://yoursite.com/2018/04/18/%E9%97%AD%E5%8C%85%E4%B8%8E%E6%A8%A1%E4%BB%BF%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/04/18/闭包与模仿块作用域/</id>
    <published>2018-04-17T23:20:18.000Z</published>
    <updated>2018-05-18T11:31:12.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包与模仿块作用域"><a href="#闭包与模仿块作用域" class="headerlink" title="闭包与模仿块作用域"></a>闭包与模仿块作用域</h2><p>　　最近看《JavaScript语言精粹》真是一页的含量顶其它书的十页啊，受益匪浅，在这里整理一下闭包的一些东东吧。</p><p>　　首先我也忘了之前有没有整理过关于原型的一些用法，先给出一段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method=<span class="keyword">function</span>(name,func)&#123;</span><br><span class="line">this.prototype[name]=func;</span><br><span class="line"><span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　具体要是忘了的话，去看原型那节，作用是给Function对象的原型添加了一个method方法，用于往该原型里新增方法，这样继承自Function对象的子对象们都会动态更新它们的方法。</p><p>　　然后就是我们主要整理的东西了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String.method(<span class="string">"deentityify"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">var entity=&#123;</span><br><span class="line">quot: <span class="string">'"'</span>,</span><br><span class="line">lt: <span class="string">'&lt;'</span>,</span><br><span class="line">gt: <span class="string">'&gt;'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> this.replace(/&amp;([^&amp;;]+);$/g,<span class="keyword">function</span>(a,b)&#123;</span><br><span class="line">var r=entity[b];</span><br><span class="line"><span class="built_in">return</span> typeof r === <span class="string">"string"</span> ? r : a;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;());</span><br><span class="line">document.writeln(<span class="string">"&amp;lt;body&amp;gt;&amp;quot;HAHAHA&amp;quot;&amp;lt;body&amp;gt;"</span>.deentityify())//&lt;body&gt;<span class="string">"HAHAHA"</span>&lt;body&gt;</span><br></pre></td></tr></table></figure></p><p>　　这段代码的主要功能是：给String对象添加一个deentityify方法。它的任务是寻找字符串中的HTML字符实体并把它们替换为对应的字符。<br>　　这里有四个需要注意的点：</p><h4 id="1-模仿块作用域"><a href="#1-模仿块作用域" class="headerlink" title="1.模仿块作用域"></a>1.模仿块作用域</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">var s=<span class="string">"test"</span>;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>　　JS中函数可以用来构造函数作用域，在函数里面可以看到外面的变量，但在函数外面则无法看到函数里面的变量，这是因为函数中搜索变量的过程是由内到外沿着作用域链逐层搜索，一直搜索到全局对象为止。</p><p>　　因为JS将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。所以最外层的把整个函数包起来的圆括号表示：将函数声明转换成函数表达式。</p><p>　　这段代码实际上定义并立即<strong>调用</strong>了一个匿名函数，其中最后的<em>()</em>圆括号是<strong>调用运算符</strong>。</p><p>　　要注意()调用运算符立刻调用了我们刚刚构造出来的函数，这个调用创建并返回的函数才是deentityify()方法，<br>　　即:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deentityify=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> this.replace(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在匿名函数中定义的任何变量，都会在执行结束时被销毁，这样就可以减少闭包占用的内存问题。</p><h4 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h4><p>　　一个<strong>函数</strong>可以访问它被创建时所处的上下文环境，这称为<strong>闭包</strong>。例子中第一个return的函数就是一个闭包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> this.replace(/&amp;([^&amp;;]+);$/g,<span class="keyword">function</span>(a,b)&#123;</span><br><span class="line">var r=entity[b];</span><br><span class="line"><span class="built_in">return</span> typeof r === <span class="string">"string"</span> ? r : a;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　上面的函数可以访问到deentityify方法上下文环境定义的entity对象，所以这个函数就可以被称作<strong>闭包</strong>。</p><p>　　在这里再讨论一下变量的生存周期：</p><p>　　全局变量的生存周期是永久，除非我们主动销毁(=null)这个全局变量。</p><p>　　在函数内用var关键字声明的局部变量，当退出函数时，会随着函数调用的结束而被销毁。</p><p>　　但是如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。像上面的闭包，它可以访问到deentityify()被调用时产生的环境，所以局部变量entity因为能被外界访问，所以就不会被销毁，除非我们手动销毁。</p><p>　　所以说闭包的作用有：</p><ol><li><p>可以延长局部变量的生存周期。</p></li><li><p>可以封装变量</p></li></ol><h4 id="3-模块模式"><a href="#3-模块模式" class="headerlink" title="3.模块模式"></a>3.模块模式</h4><p>　　模块是一个提供接口却隐藏状态与实现的函数或对象。它利用函数作用域与闭包来创建被绑定对象与私有成员的关联，模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可访问到的地方。</p><h4 id="4-String-prototype-replace-进阶用法"><a href="#4-String-prototype-replace-进阶用法" class="headerlink" title="4.String.prototype.replace()进阶用法"></a>4.String.prototype.replace()进阶用法</h4><p>　　我这也是第一次知道它的第二个参数可以是一个函数，且非常有用，具体见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" title="replace详细用法" target="_blank" rel="noopener">MDN文档</a></p><h5 id="指定一个函数作为参数"><a href="#指定一个函数作为参数" class="headerlink" title="指定一个函数作为参数"></a>指定一个函数作为参数</h5><p>　　你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后， 该函数就会执行。 函数的<strong>返回值</strong>作为替换字符串。 (注意:上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被<strong>多次调用</strong>， 每次匹配都会被调用。</p><p>　　下面是该函数的参数：</p><p>　　变量名    　　代表的值<br>　　match    　　匹配的子串。（对应于上述的$&amp;。）<br>　　p1,p2, …　假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）<br>　　offset　　匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）<br>　　string　　被匹配的原字符串。</p><p>　　代码中的正则表达式/&amp;([^&amp;;]+);$/g代表：从整个字符串中，从全局匹配出所有的以&amp;开头，中间有1个或多个非&amp;;的任意字符，然后以;结尾的字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闭包与模仿块作用域&quot;&gt;&lt;a href=&quot;#闭包与模仿块作用域&quot; class=&quot;headerlink&quot; title=&quot;闭包与模仿块作用域&quot;&gt;&lt;/a&gt;闭包与模仿块作用域&lt;/h2&gt;&lt;p&gt;　　最近看《JavaScript语言精粹》真是一页的含量顶其它书的十页啊，受益匪浅，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="http://yoursite.com/2018/04/18/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://yoursite.com/2018/04/18/函数柯里化/</id>
    <published>2018-04-17T23:19:07.000Z</published>
    <updated>2018-04-22T02:57:44.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>　　函数柯里化Currying指的是<strong>把函数与传递给它的参数相结合，产生出一个新的函数</strong>。</p><p>　　原理：Currying通过创建一个保存着原始函数(对象)和要被套用的参数的闭包来工作。它返回另一个函数，当函数被调用时，会返回调用原始函数(对象)的结果，并传递调用curry时的参数“加上”当前调用的参数。”加上”是通过Array.concat()方法连接两个参数数组。</p><p>　　上面的原理balabala一大顿，我都没看懂，所以为了更容易懂，还是得看代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method=<span class="keyword">function</span>(name,func)&#123;</span><br><span class="line">this.prototype[name]=func;</span><br><span class="line"><span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">Function.method(<span class="string">"curry"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">var slice=Array.prototype.slice,</span><br><span class="line">args=slice.apply(arguments),</span><br><span class="line">that=this;</span><br><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> that.apply(null,args.concat(slice.apply(arguments)));</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　然后接下来我们就可以看到它运用的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(num1,num2)&#123;</span><br><span class="line"><span class="built_in">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">var add1=add.curry(1);</span><br><span class="line">alert(add1(6)); //7</span><br></pre></td></tr></table></figure><p>　　这里的method方法中，要注意四点：</p><h4 id="1-arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。"><a href="#1-arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。" class="headerlink" title="1.arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。"></a>1.arguments对象保存着函数被调用时的参数列表，它是一个类数组对象，有一个length属性但没有任何数组的方法。</h4><p>　　第一个arguments是curry()函数的参数,return里的arguments是return function()的参数，这样可能听不懂，其实在例子中就是add1()函数里的参数。</p><h4 id="2-正因为第一点，所以要想在最后使用args-concat，必须将arguments对象转换为一个真的数组，这里用Array-prototype-slice-方法，它可以将一个类数组（Array-like）对象-集合转换成一个新数组。"><a href="#2-正因为第一点，所以要想在最后使用args-concat，必须将arguments对象转换为一个真的数组，这里用Array-prototype-slice-方法，它可以将一个类数组（Array-like）对象-集合转换成一个新数组。" class="headerlink" title="2.正因为第一点，所以要想在最后使用args.concat，必须将arguments对象转换为一个真的数组，这里用Array.prototype.slice()方法，它可以将一个类数组（Array-like）对象/集合转换成一个新数组。"></a>2.正因为第一点，所以要想在最后使用args.concat，必须将arguments对象转换为一个真的数组，这里用Array.prototype.slice()方法，它可以将一个类数组（Array-like）对象/集合转换成一个新数组。</h4><p>　　具体见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" title="Array.prototype.slice()" target="_blank" rel="noopener">MDN文档</a></p><h4 id="3-第一个that-this-中的this在这里属于方法调用模式，绑定到调用该方法的对象上，即一个Function对象。"><a href="#3-第一个that-this-中的this在这里属于方法调用模式，绑定到调用该方法的对象上，即一个Function对象。" class="headerlink" title="3.第一个that=this;中的this在这里属于方法调用模式，绑定到调用该方法的对象上，即一个Function对象。"></a>3.第一个that=this;中的this在这里属于方法调用模式，绑定到调用该方法的对象上，即一个Function对象。</h4><p>　　所以add.curry(1)，this被绑定到add函数对象上</p><h4 id="4-调用函数的方法apply-要绑定给this的值-参数数组"><a href="#4-调用函数的方法apply-要绑定给this的值-参数数组" class="headerlink" title="4.调用函数的方法apply(要绑定给this的值,参数数组)"></a>4.调用函数的方法apply(要绑定给this的值,参数数组)</h4><p>　　具体可见博客中“JS中的apply()使用详解一节”。</p><p>　　最后我们再结合代码来看curry方法的具体作用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.method(<span class="string">"curry"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">//curry方法通过创建一个保存着原始函数和要被套用的参数的闭包来工作。</span><br><span class="line">var slice=Array.prototype.slice,</span><br><span class="line">args=slice.apply(arguments),  //要被套用的参数</span><br><span class="line">that=this;  //that=this保存着原始函数对象</span><br><span class="line"><span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123; //闭包  &amp;&amp; 它返回另一个函数</span><br><span class="line"><span class="built_in">return</span> that.apply(null,args.concat(slice.apply(arguments)));</span><br><span class="line">//当函数被调用时，会返回调用原始函数的结果，并传递调用curry时的参数“加上”当前调用的参数</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　所以当执行add1(6)时，相当于执行了add.apply(null,args.concat(slice.apply(arguments))),即执行了add(curry中的参数1,自己的参数6),所以放回1+6=7.</p><p>#####　　这样就好理解柯里化的概念了：把函数与传递给它的参数相结合，产生出一个新的函数。</p><p>　　add函数使用curry(参数)方法=&gt;add.curry(参数);把函数与传递给它的参数 相结合，<br>　　产生一个新的函数add1=&gt;var add1=add.curry(1);<br>　　用处就是可以用add1函数给原函数add传参，现阶段光是理论懂了，但是不懂具体用在哪，后期一定会再补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数柯里化&quot;&gt;&lt;a href=&quot;#函数柯里化&quot; class=&quot;headerlink&quot; title=&quot;函数柯里化&quot;&gt;&lt;/a&gt;函数柯里化&lt;/h2&gt;&lt;p&gt;　　函数柯里化Currying指的是&lt;strong&gt;把函数与传递给它的参数相结合，产生出一个新的函数&lt;/strong
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>秒懂汉诺塔原理函数递归</title>
    <link href="http://yoursite.com/2018/04/15/%E7%A7%92%E6%87%82%E6%B1%89%E8%AF%BA%E5%A1%94%E5%8E%9F%E7%90%86%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2018/04/15/秒懂汉诺塔原理函数递归/</id>
    <published>2018-04-15T02:40:43.000Z</published>
    <updated>2018-04-15T10:33:45.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="秒懂汉诺塔原理函数递归"><a href="#秒懂汉诺塔原理函数递归" class="headerlink" title="秒懂汉诺塔原理函数递归"></a>秒懂汉诺塔原理函数递归</h2><p>　　想当年大一刚学C语言递归那一块儿的时候，遇到了“汉诺塔”问题，我的老天，那段时期想哭好吗，深刻的打击了我的编程热情，本身我就自觉智商不高，于是一直就没搞懂过这个问题，指导最近看了《JavaScript语言精粹》，才发现递归并没有那么难。。。我之前对于递归的了解只限于一个函数调用它自身，所以一直懵懵懂懂，现在需要重新认识一下它：</p><h3 id="递归函数是干啥用的"><a href="#递归函数是干啥用的" class="headerlink" title="递归函数是干啥用的"></a>递归函数是干啥用的</h3><p>　　递归函数就是会直接或间接调用自身的一种函数。它把一个问题分解为一组相似的子问题，每一个都用一个<em>寻常解</em>去解决。也就是说，递归用一般的方式去解决<strong>每个</strong>子问题。</p><h3 id="汉诺塔是什么"><a href="#汉诺塔是什么" class="headerlink" title="汉诺塔是什么"></a>汉诺塔是什么</h3><p>　　因为这是篇笔记，相信每个想了解汉诺塔原理的人都懂它是什么，怎么玩，但是就算你会玩，你不会写代码(大佬除外)。。。我就是从这个时候觉得自己智商比别人低的，不过这是我刚接触编程的时候。到现在接触了两三年的编程，我深感周围大佬没多少(可能因为我双非一本非计算机专业的缘故)，当初那些一看就会的人大部分接触的早O__O，人家初中高中奥数什么的早就接触啦，对于我们这种普通学生来说(我相信你要是985,211不会来看我的博客的)，大部分像我这样的人(为了不让大佬们黑我)都是学以致用的，参考别人的摸出门路了才会用，所以接下来我写的，应该都能懂。</p><h3 id="汉诺塔递归代码"><a href="#汉诺塔递归代码" class="headerlink" title="汉诺塔递归代码"></a>汉诺塔递归代码</h3><p>　　有时搜一篇资料，先看到源码，哇看不懂，再看原理，哇更不懂；也可能先看到原理，没代码我怎么会看懂，再看源码，哇原理我都看不懂看代码怎么会懂。。。所以这就陷入了死循环，至于能不能看懂，就看个人的喜好和悟性了，我的习惯是先看源码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">var hanoi=<span class="keyword">function</span>(n,src,aux,dst)&#123;</span><br><span class="line"><span class="keyword">if</span>(disc&gt;0)&#123;</span><br><span class="line">//第一步</span><br><span class="line">hanoi(n-1,src,dst,aux);</span><br><span class="line">//第二步</span><br><span class="line">document.writeln(<span class="string">"Move disc "</span>+n+<span class="string">" from "</span>+src+<span class="string">" to "</span>+dst);</span><br><span class="line">//第三步</span><br><span class="line">hanoi(n-1,aux,src,dst);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">hanoi(3,<span class="string">"Src"</span>,<span class="string">"Aux"</span>,<span class="string">"Dst"</span>);</span><br><span class="line">hanoi(4,<span class="string">"Src"</span>,<span class="string">"Aux"</span>,<span class="string">"Dst"</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure></p><h3 id="汉诺塔递归原理"><a href="#汉诺塔递归原理" class="headerlink" title="汉诺塔递归原理"></a>汉诺塔递归原理</h3><p>　　你可以发现它看上去非常的简单，一共就三步，毕竟hanoi函数就是把一堆圆盘从一根柱子移到另一根柱子，必要时使用辅助的柱子。函数的参数解释如下：<br>1.n是一开始由小到大排在src柱子上的圆盘数量<br>2.src代表起始柱子<br>3.aux(auxiliary)代表辅助柱子<br>4.dst(destination)代表目标柱子</p><p>　　hanoi函数把问题分解为了三个子问题，</p><h4 id="第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。"><a href="#第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。" class="headerlink" title="第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。"></a>第一步：它移动n-1个较小的圆盘到辅助柱子上，从而露出下面最大的圆盘。</h4><h4 id="第二步：移动下面最大的圆盘到目标柱子上。"><a href="#第二步：移动下面最大的圆盘到目标柱子上。" class="headerlink" title="第二步：移动下面最大的圆盘到目标柱子上。"></a>第二步：移动下面最大的圆盘到目标柱子上。</h4><h4 id="第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。"><a href="#第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。" class="headerlink" title="第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。"></a>第三步：将刚才较小的圆盘从辅助柱子上再移动到目标柱子上。</h4><p>　　然后通过递归地调用自身(只是参数不同)去处理一对圆盘的移动，从而解决那些子问题。</p><h3 id="对递归原理的理解"><a href="#对递归原理的理解" class="headerlink" title="对递归原理的理解"></a>对递归原理的理解</h3><p>　　hanoi(3,”Src”,”Aux”,”Dst”);代表把3个圆盘<strong>从</strong>Src柱子<strong>借助</strong>Aux柱子移动<strong>到</strong>Dst柱子。每一个大问题里包含三个子问题:如果起始柱子上有盘子，先把disc-1个较小的圆盘都放到辅助柱子上，然后把较大的放到目标柱子上，最后在把那disc-1个较小的圆盘放到目标柱子上。</p><p>　　相信读到这里的人都搞懂了<strong>怎么把这个大问题分解为3个子问题</strong>，并且发现如果按着原理思路来写，即可写出代码。但是过了不一会儿你就会产生疑问，因为你大问题上懂了，但不明白为啥每个子问题都可以这么用呢？每个子问题内为什么也起作用呢？</p><p>　　所以说之前的我和现在的我差在了哪里，不是智商，而是思考的方式不对！！你是不是正在苦苦思考这段代码的每一步，然后把一步步的执行过程都写出来了，想搞懂递归呢？结果就是蛋疼！你不但啥也没搞懂，还白白浪费了这段推代码的时间！正确的打开方式是这样的——<strong>递归当然只能以递归的思路理解，把它展开纯属自讨苦吃</strong>。</p><p>　　递归思路，说白了是如下三步：</p><h4 id="1-对于问题N，如果N-1已经解决了，那么N是否很容易解决。"><a href="#1-对于问题N，如果N-1已经解决了，那么N是否很容易解决。" class="headerlink" title="1.对于问题N，如果N-1已经解决了，那么N是否很容易解决。"></a>1.对于问题N，如果N-1已经解决了，那么N是否很容易解决。</h4><p>　　举例来说，如果要把一个N层汉诺塔从src搬到dst，那么：</p><p>　　如果前N-1层可以找别人搞定，咱只管搬第N层，会不会变得非常容易？</p><p>　　你看，这一下就简单了：这时当它只有两层就好了，先把前N-1层看作一个整体，把它搬到aux；然后把最下面的第N层搬到dst；然后再把前N-1层从aux搬到dst。</p><p>　　类似的，假如接到“搬前N-1层”这个任务的是我们，怎么搬呢？</p><p>　　简单，像前东家一样，把前N-2层外包出去，我们只搬第N-1层——其实和前面讨论过的“外包N-1层，只搬第N层”完全一样嘛。</p><p>　　依此类推，一层层“外包”下去——我不管你们有多伤脑筋，反正只要你们把我外包给你的活干了，我就能干了我的活！</p><p>　　这一步就是*<em>递推</em>。</p><h6 id="注意这里的搬法：搬第N层，就需要把前N-1层搬两次-起始到辅助，辅助再到目标-，另外再把第N层搬一次-起始到目标-；"><a href="#注意这里的搬法：搬第N层，就需要把前N-1层搬两次-起始到辅助，辅助再到目标-，另外再把第N层搬一次-起始到目标-；" class="headerlink" title="注意这里的搬法：搬第N层，就需要把前N-1层搬两次(起始到辅助，辅助再到目标)，另外再把第N层搬一次(起始到目标)；"></a>注意这里的搬法：搬第N层，就需要把前N-1层搬两次(起始到辅助，辅助再到目标)，另外再把第N层搬一次(起始到目标)；</h6><h6 id="搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。"><a href="#搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。" class="headerlink" title="搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。"></a>搬第N-1层，又需要把前N-2层搬两次，然后再把N-1层搬一次，依此类推。</h6><h6 id="an-2-a-n-1-1"><a href="#an-2-a-n-1-1" class="headerlink" title="an=2*a(n-1)+1"></a>an=2*a(n-1)+1</h6><h6 id="a-n-1-2-a-n-2-1"><a href="#a-n-1-2-a-n-2-1" class="headerlink" title="a(n-1)=2*a(n-2)+1"></a>a(n-1)=2*a(n-2)+1</h6><h6 id="……"><a href="#……" class="headerlink" title="……"></a>……</h6><h6 id="a2-2-a1-1"><a href="#a2-2-a1-1" class="headerlink" title="a2=2*a1+1"></a>a2=2*a1+1</h6><h6 id="a1-1"><a href="#a1-1" class="headerlink" title="a1=1"></a>a1=1</h6><h6 id="很容易知道，an需要搬2-n-1次。"><a href="#很容易知道，an需要搬2-n-1次。" class="headerlink" title="很容易知道，an需要搬2^n-1次。"></a>很容易知道，an需要搬2^n-1次。</h6><h4 id="2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。"><a href="#2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。" class="headerlink" title="2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。"></a>2、一步步递推下去，终究会有个“包工头”，接到“搬第一层”的任务。</h4><p>　　第一层怎么搬？</p><p>　　太简单了，让搬哪搬哪。</p><p>　　换句话说，到此，<strong>递推</strong>就到了极限，简单粗暴直接做就可以了。</p><h4 id="3-既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。"><a href="#3-既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。" class="headerlink" title="3.既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。"></a>3.既然第一层搬了，那么第二层当然就可以搬了；第二层搬了，第三层又可以搬了……依次类推，直到第N层。于是问题搞定。</h4><p>　　这一步就是<strong>回归</strong>。</p><p>　　如上三步加起来，就是<strong>递归</strong>。</p><p>　　推而广之，任何问题，不管规模为N时有多复杂，只要把N-1那块“外包”给别人做之后，我们在这个基础上可以轻易完成N，那么它很可能就适合用“递归”解决。</p><p>　　那么，怎么最终确定它能不能用“递归”做呢？</p><h5 id="看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。"><a href="#看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。" class="headerlink" title="看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。"></a>看当N取1或2之类最简情况时，问题是否可以解决——然后写程序解决它。</h5><p>　　容易看出，<strong>“递归”其实和“数学归纳法”的思路非常像</strong>：证明N=1时成立；证明若N=n-1成立，则N=n时也成立；如上两步得证，则命题在n&gt;1时一定成立（n为自然数）。你看，我们没必要从1开始逐一验证每个自然数，只要证明了“基础条件”、再证明了“递推条件”，大自然的规律会帮我们搞定一切。</p><p>　　换句话说，只要我们：</p><h5 id="1、写程序告诉电脑“如何分解一个问题”-即把汉诺塔问题分解为如上三步"><a href="#1、写程序告诉电脑“如何分解一个问题”-即把汉诺塔问题分解为如上三步" class="headerlink" title="1、写程序告诉电脑“如何分解一个问题”(即把汉诺塔问题分解为如上三步)"></a>1、写程序告诉电脑“如何分解一个问题”(即把汉诺塔问题分解为如上三步)</h5><h5 id="2、写程序告诉电脑“当该问题分解到最简时如何处理”-即第二步中的直接把它从src移到dst"><a href="#2、写程序告诉电脑“当该问题分解到最简时如何处理”-即第二步中的直接把它从src移到dst" class="headerlink" title="2、写程序告诉电脑“当该问题分解到最简时如何处理”(即第二步中的直接把它从src移到dst)"></a>2、写程序告诉电脑“当该问题分解到最简时如何处理”(即第二步中的直接把它从src移到dst)</h5><p>　　那么，“具体如何递推、如何回归”这个简单问题就不要再操心了，电脑自己能搞定。</p><p>　　——写出问题分解方法、写出分解到最简后如何解决，这是我们的任务；把问题搞定，是电脑的任务。这就是递归的魅力。</p><p>　　正是由于这种“我提供思路你搞定细节”的特点，“一切皆递归”的函数系语言才被称为“声明式编程”（而不是必须一步一步指导电脑如何做的“命令式编程”）。</p><p><a href="https://www.zhihu.com/question/24385418,&quot;如何理解汉诺塔的递归？&quot;" target="_blank" rel="noopener">更多的关于汉诺塔递归问题可以参考</a></p><p>　　</p><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;秒懂汉诺塔原理函数递归&quot;&gt;&lt;a href=&quot;#秒懂汉诺塔原理函数递归&quot; class=&quot;headerlink&quot; title=&quot;秒懂汉诺塔原理函数递归&quot;&gt;&lt;/a&gt;秒懂汉诺塔原理函数递归&lt;/h2&gt;&lt;p&gt;　　想当年大一刚学C语言递归那一块儿的时候，遇到了“汉诺塔”问题，我
      
    
    </summary>
    
    
  </entry>
  
</feed>
